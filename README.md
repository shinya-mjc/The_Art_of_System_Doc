# 📘 システム開発完全ガイド

---

## 📋 目次（クイックナビ：章のみ）

- [📘 システム開発完全ガイド](#-システム開発完全ガイド)
- [第1章：はじめに - このガイドの使い方](#第1章はじめに---このガイドの使い方)
- [第2章：システム開発の全体像](#第2章システム開発の全体像)
- [第3章：フェーズ別詳細解説](#第3章フェーズ別詳細解説)
- [第4章：重要ドキュメント詳細解説](#第4章重要ドキュメント詳細解説)
- [第5章：実践的手法とツール](#第5章実践的手法とツール)
- [第6章：国際標準規格（ISO）](#第6章国際標準規格iso)
- [第7章：完全用語集（あいうえお順・アルファベット順）](#第7章完全用語集あいうえお順アルファベット順)
- [第8章：実践テンプレート集](#第8章実践テンプレート集)
- [第9章：チェックリストとベストプラクティス](#第9章チェックリストとベストプラクティス)
- [第10章：FAQ（よくある質問）](#第10章faqよくある質問)
- [🎉 全章完了！](#-全章完了おめでとうございます)

---

## 📚 目次（詳細：H1〜H3、章ごとに折りたたみ）

<details><summary>第1章：はじめに - このガイドの使い方</summary>

- [1.1 このガイドの目的と特徴](#11-このガイドの目的と特徴)  
  - [🎯 このガイドの目的](#-このガイドの目的)  
  - [✨ このガイドの5大特徴](#-このガイドの5大特徴)
- [1.2 読み進め方（10分で概要を掴む）](#12-読み進め方10分で概要を掴む)  
  - [📖 推奨学習ルート](#-推奨学習ルート)  
  - [⏱️ 時間別読み方ガイド](#️-時間別読み方ガイド)
- [1.3 ドキュメントの重要性](#13-ドキュメントの重要性)  
  - [❓ なぜドキュメントが必要なのか？](#-なぜドキュメントが必要なのか)  
  - [🔥 ドキュメントがないと起こる問題](#-ドキュメントがないと起こる問題)  
  - [✅ ドキュメントがあると得られる効果](#-ドキュメントがあると得られる効果)  
  - [🏆 ドキュメントによる成功事例](#-ドキュメントによる成功事例)

[▲ 目次へ戻る](#-目次クイックナビ章のみ)
</details>

<details><summary>第2章：システム開発の全体像</summary>

- [2.1 システム開発とは何か](#21-システム開発とは何か)  
  - [🔧 システム開発の定義](#-システム開発の定義)  
  - [🎨 家を建てることに似ている](#-家を建てることに似ている)
- [2.2 開発モデル（ウォーターフォール vs アジャイル）](#22-開発モデルウォーターフォール-vs-アジャイル)  
  - [🌊 ウォーターフォール型開発](#-ウォーターフォール型開発)  
  - [🔄 アジャイル型開発](#-アジャイル型開発)  
    - [スクラム（Scrum）](#スクラムscrum)  
    - [カンバン（Kanban）](#カンバンkanban)  
  - [🤝 ハイブリッド型（現実的な選択）](#-ハイブリッド型現実的な選択)
- [2.3 全体フローの俯瞰図（超詳細版）](#23-全体フローの俯瞰図超詳細版)
- [2.4 各フェーズの関係性](#24-各フェーズの関係性)  
  - [🔗 V字モデル（テストとの対応関係）](#-v字モデルテストとの対応関係)  
  - [🎯 トレーサビリティ（追跡可能性）](#-トレーサビリティ追跡可能性)

[▲ 目次へ戻る](#-目次クイックナビ章のみ)
</details>

<details><summary>第3章：フェーズ別詳細解説</summary>

- [3.1 ①企画・課題定義フェーズ](#31-企画課題定義フェーズ)
- [3.2 ②要件定義フェーズ（最重要！）](#32-要件定義フェーズ最重要)
- [3.3 ③基本設計フェーズ](#33-基本設計フェーズ)
- [3.4 ④詳細設計フェーズ](#34-詳細設計フェーズ)
- [3.5 ⑤実装・開発フェーズ](#35-実装開発フェーズ)
- [3.6 ⑥テストフェーズ](#36-テストフェーズ)
- [3.7 ⑦リリース・展開フェーズ](#37-リリース展開フェーズ)
- [3.8 ⑧運用・保守フェーズ](#38-運用保守フェーズ)
- [第3章のまとめ](#第3章のまとめ)

[▲ 目次へ戻る](#-目次クイックナビ章のみ)
</details>

<details><summary>第4章：重要ドキュメント詳細解説</summary>

- [📚 本章で解説するドキュメント](#-本章で解説するドキュメント)
- [4.1 SRS（要求仕様書）](#41-srs要求仕様書software-requirements-specification)
- [4.2 アーキテクチャ記述書（AD）](#42-アーキテクチャ記述書adarchitecture-description)
- [4.3 テスト計画・仕様書](#43-テスト計画仕様書)
- [4.4 SLO文書（運用目標）](#44-slo文書運用目標service-level-objective)
- [4.5 RTM（トレーサビリティマトリクス）](#45-rtmトレーサビリティマトリクス)
- [4.6 ADR（設計決定記録）](#46-adr設計決定記録)
- [第4章のまとめ](#第4章のまとめ)

[▲ 目次へ戻る](#-目次クイックナビ章のみ)
</details>

<details><summary>第5章：実践的手法とツール</summary>

- [5.1 要件定義の技法](#51-要件定義の技法)
- [5.2 設計手法（C4モデル、UML）](#52-設計手法c4モデルuml)
- [5.3 テスト設計技法](#53-テスト設計技法)
- [5.4 Gherkinによる受入基準](#54-gherkinによる受入基準)
- [5.5 バージョン管理とトレーサビリティ](#55-バージョン管理とトレーサビリティ)
- [第5章のまとめ](#第5章のまとめ)

[▲ 目次へ戻る](#-目次クイックナビ章のみ)
</details>

<details><summary>第6章：国際標準規格（ISO）</summary>

- [6.1 ISO/IEC/IEEE 29148（要求工学）](#61-isoiecieee-29148要求工学)
- [6.2 ISO/IEC/IEEE 42010（アーキテクチャ記述）](#62-isoiecieee-42010アーキテクチャ記述)
- [6.3 ISO/IEC/IEEE 29119（テスト）](#63-isoiecieee-29119テスト)
- [6.4 その他の関連規格](#64-その他の関連規格)
- [第6章のまとめ](#第6章のまとめ)

[▲ 目次へ戻る](#-目次クイックナビ章のみ)
</details>

<details><summary>第7章：完全用語集（あいうえお順・アルファベット順）</summary>

- [7.1 日本語用語（あいうえお順）](#71-日本語用語あいうえお順)
- [7.2 アルファベット用語](#72-アルファベット用語)
- [7.3 略語一覧](#73-略語一覧)
- [第7章のまとめ](#第7章のまとめ)

[▲ 目次へ戻る](#-目次クイックナビ章のみ)
</details>

<details><summary>第8章：実践テンプレート集</summary>

- [8.1 SRSテンプレート（空フォーム）](#81-srsテンプレート空フォーム)
- [8.2 基本設計書テンプレート](#-基本設計書テンプレート簡略版)
- [8.3 詳細設計書テンプレート](#-詳細設計書テンプレート)
- [8.4 テスト仕様書テンプレート](#-テスト仕様書テンプレート)
- [8.5 その他のテンプレート](#85-その他のテンプレート)
- [第8章のまとめ](#第8章のまとめ)

[▲ 目次へ戻る](#-目次クイックナビ章のみ)
</details>

<details><summary>第9章：チェックリストとベストプラクティス</summary>

- [9.1 各フェーズのゲートチェックリスト](#91-各フェーズのゲートチェックリスト)
- [9.2 よくある失敗パターンと対策](#92-よくある失敗パターンと対策)
- [9.3 成功のための10の原則](#93-成功のための10の原則)
- [第9章のまとめ](#第9章のまとめ)

[▲ 目次へ戻る](#-目次クイックナビ章のみ)
</details>

<details><summary>第10章：FAQ（よくある質問）</summary>

- [10.1 初心者からの質問](#101-初心者からの質問)
- [10.2 実務上の疑問](#102-実務上の疑問)
- [10.3 トラブルシューティング](#103-トラブルシューティング)

[▲ 目次へ戻る](#-目次クイックナビ章のみ)
</details>

---

# 第1章：はじめに - このガイドの使い方

## 1.1 このガイドの目的と特徴

### 🎯 このガイドの目的

このガイドは、**システム開発に関わる全てのドキュメント**について、専門知識がゼロの方でも完全に理解できることを目的としています。

**対象読者：**

- 👶 システム開発を初めて担当する方
- 💼 開発プロジェクトに参加するビジネス側の方
- 🎓 IT業界への転職・就職を考えている方
- 🔰 ドキュメント作成に不安がある若手エンジニア
- 📊 プロジェクトマネージャーを目指す方
- 🏢 発注側として開発会社と接する方

### ✨ このガイドの5大特徴

```mermaid
graph TD
    A[このガイドの特徴] --> B[①専門用語を全て解説]
    A --> C[②図解が超豊富]
    A --> D[③実例とテンプレート付き]
    A --> E[④最新のベストプラクティス]
    A --> F[⑤すぐに使える実践的内容]
    
    B --> B1[難しい言葉も中学生レベルで説明]
    C --> C1[Mermaid図で視覚的に理解]
    D --> D1[コピペで使える雛形多数]
    E --> E1[2024-2025年の最新情報]
    F --> F1[明日から使える知識]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#f3e5f5,stroke:#7b1fa2
    style D fill:#e8f5e9,stroke:#2e7d32
    style E fill:#fff9c4,stroke:#f57f17
    style F fill:#fce4ec,stroke:#c2185b
```

## 1.2 読み進め方（10分で概要を掴む）

### 📖 推奨学習ルート

**【初めての方】**

```mermaid
graph LR
    A[第1章を読む<br/>5分] --> B[第2章で全体像把握<br/>10分]
    B --> C[第3章で興味ある<br/>フェーズを読む<br/>20分]
    C --> D[第7章の用語集を<br/>辞書として活用]
    
    style A fill:#c8e6c9
    style B fill:#fff9c4
    style C fill:#b3e5fc
    style D fill:#f8bbd0
```

**【実務で使う方】**

```mermaid
graph LR
    A[第2章で全体確認] --> B[担当フェーズの<br/>第3章を熟読]
    B --> C[第4章で該当<br/>ドキュメント詳細]
    C --> D[第8章で<br/>テンプレート入手]
    D --> E[第9章で<br/>チェックリスト確認]
    
    style A fill:#fff3e0
    style B fill:#f3e5f5
    style C fill:#e8f5e9
    style D fill:#fff9c4
    style E fill:#fce4ec
```

### ⏱️ 時間別読み方ガイド

| 時間 | 読むべき箇所 | 得られる知識 |
|------|------------|------------|
| **10分** | 第1章 + 第2章の図 | システム開発の全体像 |
| **30分** | 上記 + 第3章の見出し | 各フェーズで何をするか |
| **1時間** | 上記 + 興味のあるフェーズ詳細 | 特定フェーズの深い理解 |
| **3時間** | 第1〜5章 | 実務に使える知識 |
| **1日** | 全章通読 | 完璧な理解 |

## 1.3 ドキュメントの重要性

### ❓ なぜドキュメントが必要なのか？

システム開発には多くの人が関わります：

```mermaid
graph TD
    A[システム開発プロジェクト] --> B[お客様/発注者]
    A --> C[プロジェクトマネージャー]
    A --> D[システムエンジニア]
    A --> E[開発者/プログラマー]
    A --> F[デザイナー]
    A --> G[テスター/QA]
    A --> H[運用チーム]
    A --> I[経営層]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#ffcdd2,stroke:#c62828
    style C fill:#fff3e0,stroke:#ef6c00
    style D fill:#f3e5f5,stroke:#7b1fa2
    style E fill:#c8e6c9,stroke:#2e7d32
    style F fill:#fff9c4,stroke:#f57f17
    style G fill:#b3e5fc,stroke:#0277bd
    style H fill:#f8bbd0,stroke:#c2185b
    style I fill:#e0f2f1,stroke:#00695c
```

これらの人々が**同じ理解を持つため**にドキュメントが必要です。

### 🔥 ドキュメントがないと起こる問題

| 問題の種類 | 具体的な事例 | ビジネスへの影響 | 発生頻度 |
|-----------|------------|----------------|---------|
| **認識のズレ** | 「カート機能」と聞いて、<br/>お客様は「ショッピングカート」、<br/>開発者は「台車管理」を想像 | ✗ 全面的な作り直し<br/>✗ 数百万円の損失<br/>✗ 納期3ヶ月遅延 | 🔴 非常に多い |
| **引き継ぎ困難** | 担当者が退職。<br/>「なぜこの設計にしたのか」<br/>誰も分からない | ✗ 改修が危険<br/>✗ バグ修正に時間<br/>✗ 技術的負債の蓄積 | 🔴 非常に多い |
| **トラブル対応の遅れ** | 障害発生。<br/>どこをどう直せばいいか<br/>手がかりなし | ✗ サービス停止の長期化<br/>✗ 顧客の信頼喪失<br/>✗ 損害賠償リスク | 🟡 中程度 |
| **重複作業** | 過去に解決した問題を<br/>また一から調査・実装 | ✗ 工数の無駄<br/>✗ 同じバグの再発<br/>✗ 品質のばらつき | 🔴 非常に多い |
| **仕様の忘却** | 「あの機能、<br/>どういう仕様だったっけ？」<br/>作った本人も忘れる | ✗ 保守・改修ミス<br/>✗ 意図しない動作<br/>✗ セキュリティ問題 | 🟡 中程度 |

### ✅ ドキュメントがあると得られる効果

```mermaid
graph TD
    A[適切なドキュメント] --> B[🎯 認識の統一]
    A --> C[📚 知識の保存]
    A --> D[⚡ 迅速な対応]
    A --> E[🛡️ 品質向上]
    A --> F[💰 コスト削減]
    
    B --> B1[チーム全員が<br/>同じゴールを目指せる]
    C --> C1[「なぜこうしたのか」が<br/>後から分かる]
    D --> D1[トラブル時に<br/>素早く原因特定]
    E --> E1[レビューで<br/>問題を早期発見]
    F --> F1[手戻りが減り<br/>効率的な開発]
    
    style A fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
    style B fill:#e1f5ff,stroke:#0277bd
    style C fill:#fff3e0,stroke:#ef6c00
    style D fill:#f3e5f5,stroke:#7b1fa2
    style E fill:#fff9c4,stroke:#f57f17
    style F fill:#f8bbd0,stroke:#c2185b
```

### 🏆 ドキュメントによる成功事例

**事例1：大手ECサイトのリニューアル**

- **状況**：要件定義書を詳細に作成
- **結果**：仕様変更がほぼゼロ、予定通り3ヶ月でリリース
- **効果**：開発コストを当初見積もりの-15%で完了

**事例2：金融システムの改修**

- **状況**：過去の設計書とADR（設計決定記録）が完備
- **結果**：10年前のシステムでも安全に改修できた
- **効果**：調査期間を2週間短縮、バグゼロでリリース

**事例3：スタートアップのサービス開発**

- **状況**：軽量なドキュメント（ユーザーストーリー、ADR）のみ
- **結果**：素早い意思決定とピボット
- **効果**：市場投入までの期間を40%短縮

---

# 第2章：システム開発の全体像

## 2.1 システム開発とは何か

### 🔧 システム開発の定義

**システム開発**とは、コンピューターを使って業務や生活を便利にするソフトウェアを作ることです。

**具体例で理解しよう：**

| 私たちが普段使っているもの | どうやって作られたか |
|------------------------|-------------------|
| 📱 LINEアプリ | システム開発で作られた |
| 🛒 Amazonの買い物サイト | システム開発で作られた |
| 💳 銀行のATM | システム開発で作られた |
| 🎮 ゲーム | システム開発で作られた |
| 🏢 会社の勤怠管理システム | システム開発で作られた |

### 🎨 システム開発 = 家を建てることに似ている

システム開発は、**家を建てること**に非常に似ています：

```mermaid
graph LR
    A[家を建てる] -.似ている.- B[システムを作る]
    
    A --> A1[①どんな家にするか<br/>家族で相談]
    A1 -.対応.- B1[①要件定義<br/>何を作るか決める]
    
    A --> A2[②設計図を描く]
    A2 -.対応.- B2[②設計<br/>どう作るか決める]
    
    A --> A3[③大工さんが建てる]
    A3 -.対応.- B3[③実装<br/>コードを書く]
    
    A --> A4[④完成確認]
    A4 -.対応.- B4[④テスト<br/>正しく動くか確認]
    
    A --> A5[⑤引き渡し]
    A5 -.対応.- B5[⑤リリース<br/>使えるようにする]
    
    A --> A6[⑥住んでメンテ]
    A6 -.対応.- B6[⑥運用保守<br/>使い続ける]
    
    style A fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    style B fill:#e1f5ff,stroke:#0277bd,stroke-width:2px
```

**重要なポイント：**

- 🏠 家は設計図なしでは建てられない → 📄 システムも設計書なしでは作れない
- 🏠 家族の要望を聞かずに建てると住みにくい → 📄 要件定義をせずに作ると使いにくい
- 🏠 完成後も修理・改築が必要 → 📄 システムも運用・保守が必要

## 2.2 開発モデル（ウォーターフォール vs アジャイル）

システム開発には大きく2つのアプローチがあります。

### 🌊 ウォーターフォール型開発

**イメージ：滝のように一方向に流れる**

```mermaid
graph TD
    Start([プロジェクト開始]) --> Phase1[①企画・課題定義<br/>🎯 何のために作る？]
    Phase1 -->|完了| Phase2[②要件定義<br/>📋 何を作る？]
    Phase2 -->|完了| Phase3[③基本設計<br/>🏗️ どう作る？大枠]
    Phase3 -->|完了| Phase4[④詳細設計<br/>📐 どう作る？詳細]
    Phase4 -->|完了| Phase5[⑤実装・開発<br/>💻 コードを書く]
    Phase5 -->|完了| Phase6[⑥テスト<br/>🧪 正しく動く？]
    Phase6 -->|完了| Phase7[⑦リリース<br/>🚀 公開する]
    Phase7 --> Phase8[⑧運用・保守<br/>🔧 使い続ける]
    
    Phase2 -.戻らない.- Phase1
    Phase3 -.戻らない.- Phase2
    Phase4 -.戻らない.- Phase3
    Phase5 -.戻らない.- Phase4
    Phase6 -.戻らない.- Phase5
    
    style Start fill:#c8e6c9,stroke:#2e7d32
    style Phase1 fill:#ffebee,stroke:#c62828
    style Phase2 fill:#fff3e0,stroke:#e65100
    style Phase3 fill:#fff9c4,stroke:#f57f17
    style Phase4 fill:#f1f8e9,stroke:#558b2f
    style Phase5 fill:#e1f5fe,stroke:#0277bd
    style Phase6 fill:#ede7f6,stroke:#4527a0
    style Phase7 fill:#fce4ec,stroke:#c2185b
    style Phase8 fill:#e0f2f1,stroke:#00695c
```

**特徴：**

- ✅ **メリット**
  - 計画的で予測しやすい
  - 大規模プロジェクトに向いている
  - 各工程の責任が明確
  - ドキュメントがしっかり残る
  
- ❌ **デメリット**
  - 途中で変更しにくい
  - 最初の要件定義が非常に重要
  - 完成まで実物が見られない
  - 市場変化に対応しにくい

**向いているプロジェクト：**

- 🏦 銀行システム（安全性最優先）
- 🏥 医療システム（規制が厳しい）
- 🏭 工場の制御システム（仕様変更が少ない）
- 🏢 大企業の基幹システム

### 🔄 アジャイル型開発

**イメージ：小さく作って改善を繰り返す**

```mermaid
graph TD
    Start([プロジェクト開始]) --> Sprint1[スプリント1<br/>2週間]
    
    Sprint1 --> S1_1[計画]
    S1_1 --> S1_2[設計]
    S1_2 --> S1_3[実装]
    S1_3 --> S1_4[テスト]
    S1_4 --> S1_5[リリース]
    
    S1_5 --> Review1{レビュー<br/>フィードバック}
    Review1 --> Sprint2[スプリント2<br/>2週間]
    
    Sprint2 --> S2_1[計画<br/>改善反映]
    S2_1 --> S2_2[設計]
    S2_2 --> S2_3[実装]
    S2_3 --> S2_4[テスト]
    S2_4 --> S2_5[リリース]
    
    S2_5 --> Review2{レビュー<br/>フィードバック}
    Review2 --> Sprint3[スプリント3<br/>...]
    Sprint3 --> Continue[繰り返し]
    
    style Start fill:#c8e6c9,stroke:#2e7d32
    style Sprint1 fill:#e1f5fe,stroke:#0277bd
    style Sprint2 fill:#f3e5f5,stroke:#7b1fa2
    style Sprint3 fill:#fff9c4,stroke:#f57f17
    style Review1 fill:#ffcdd2,stroke:#c62828
    style Review2 fill:#ffcdd2,stroke:#c62828
```

**特徴：**

- ✅ **メリット**
  - 変更に柔軟に対応できる
  - 早く実物が見られる
  - ユーザーの反応を見ながら改善
  - 市場変化に素早く対応
  
- ❌ **デメリット**
  - 全体像が見えにくい
  - スケジュールが読みにくい
  - ドキュメントが少なくなりがち
  - チーム力が必要

**向いているプロジェクト：**

- 📱 スマホアプリ（ユーザーの反応を見たい）
- 🚀 スタートアップのサービス（市場の反応を試したい）
- 🎮 ゲーム開発（面白さを試しながら作る）
- 🌐 Webサービス（頻繁に改善したい）

**アジャイルの代表的な手法:**

#### スクラム（Scrum）

- **スプリント**: 1-4週間の開発サイクル
- **デイリースタンドアップ**: 毎日15分の進捗確認
- **スプリントプランニング**: スプリント開始時の計画会議
- **スプリントレビュー**: スプリント終了時の成果発表
- **レトロスペクティブ**: 振り返りと改善

#### カンバン（Kanban）

- **WIP制限**: 同時作業数を制限
- **ボード管理**: タスクの可視化（To Do / Doing / Done）
- **継続的改善**: 常に改善を繰り返す

### 🤝 ハイブリッド型（現実的な選択）

実際のプロジェクトでは、**両方の良いところを組み合わせる**ことが多いです。

```mermaid
graph LR
    A[上流工程<br/>企画・要件定義] -->|ウォーターフォール<br/>しっかり計画| B[設計]
    B -->|ウォーターフォール<br/>全体設計| C[開発・テスト]
    C -->|アジャイル<br/>繰り返し改善| D[リリース]
    
    style A fill:#fff3e0,stroke:#ef6c00
    style B fill:#fff9c4,stroke:#f57f17
    style C fill:#e1f5fe,stroke:#0277bd
    style D fill:#c8e6c9,stroke:#2e7d32
```

**💡 ポイント：**

- 最初の**企画・要件定義・設計**はウォーターフォールでしっかり
- **実装・テスト**はアジャイルで柔軟に
- **ドキュメントは必要最小限**だがしっかり残す

## 2.3 全体フローの俯瞰図（超詳細版）

### 🗺️ システム開発の全体マップ

```mermaid
graph TD
    Start([プロジェクト開始]) --> Phase1[①企画・課題定義<br/>🎯期間: 2-4週間]
    
    Phase1 --> Doc1[📄成果物]
    Doc1 --> Doc1a[・企画書]
    Doc1 --> Doc1b[・RFP提案依頼書]
    Doc1 --> Doc1c[・プロジェクト計画書]
    
    Phase1 --> Gate1{ゲート1<br/>企画承認}
    Gate1 -->|承認| Phase2[②要件定義<br/>📋期間: 4-8週間]
    Gate1 -->|否認| Rework1[見直し]
    Rework1 --> Phase1
    
    Phase2 --> Doc2[📄成果物]
    Doc2 --> Doc2a[・SRS要求仕様書]
    Doc2 --> Doc2b[・ユースケース図]
    Doc2 --> Doc2c[・画面遷移図]
    Doc2 --> Doc2d[・ER図データ設計]
    
    Phase2 --> Gate2{ゲート2<br/>要件承認}
    Gate2 -->|承認| Phase3[③基本設計<br/>🏗️期間: 4-8週間]
    Gate2 -->|否認| Rework2[見直し]
    Rework2 --> Phase2
    
    Phase3 --> Doc3[📄成果物]
    Doc3 --> Doc3a[・基本設計書]
    Doc3 --> Doc3b[・アーキテクチャ記述書AD]
    Doc3 --> Doc3c[・システム構成図]
    Doc3 --> Doc3d[・インフラ設計書]
    
    Phase3 --> Gate3{ゲート3<br/>設計承認}
    Gate3 -->|承認| Phase4[④詳細設計<br/>📐期間: 4-8週間]
    Gate3 -->|否認| Rework3[見直し]
    Rework3 --> Phase3
    
    Phase4 --> Doc4[📄成果物]
    Doc4 --> Doc4a[・詳細設計書]
    Doc4 --> Doc4b[・クラス図]
    Doc4 --> Doc4c[・シーケンス図]
    Doc4 --> Doc4d[・DB物理設計書]
    
    Phase4 --> Gate4{ゲート4<br/>詳細設計承認}
    Gate4 -->|承認| Phase5[⑤実装・開発<br/>💻期間: 8-16週間]
    Gate4 -->|否認| Rework4[見直し]
    Rework4 --> Phase4
    
    Phase5 --> Doc5[📄成果物]
    Doc5 --> Doc5a[・ソースコード]
    Doc5 --> Doc5b[・ADR設計決定記録]
    Doc5 --> Doc5c[・単体テストコード]
    Doc5 --> Doc5d[・コードレビュー記録]
    
    Phase5 --> Gate5{ゲート5<br/>コード品質}
    Gate5 -->|承認| Phase6[⑥テスト<br/>🧪期間: 4-8週間]
    Gate5 -->|否認| Rework5[修正]
    Rework5 --> Phase5
    
    Phase6 --> Doc6[📄成果物]
    Doc6 --> Doc6a[・テスト計画書]
    Doc6 --> Doc6b[・テスト仕様書]
    Doc6 --> Doc6c[・テスト結果報告書]
    Doc6 --> Doc6d[・バグ管理表]
    
    Phase6 --> Gate6{ゲート6<br/>品質承認}
    Gate6 -->|承認| Phase7[⑦リリース<br/>🚀期間: 1-2週間]
    Gate6 -->|否認| Rework6[修正]
    Rework6 --> Phase5
    
    Phase7 --> Doc7[📄成果物]
    Doc7 --> Doc7a[・リリースノート]
    Doc7 --> Doc7b[・展開手順書]
    Doc7 --> Doc7c[・ロールバック手順書]
    Doc7 --> Doc7d[・ユーザーマニュアル]
    
    Phase7 --> Phase8[⑧運用・保守<br/>🔧継続的]
    
    Phase8 --> Doc8[📄成果物]
    Doc8 --> Doc8a[・SLO/SLA文書]
    Doc8 --> Doc8b[・運用手順書Runbook]
    Doc8 --> Doc8c[・障害対応手順書]
    Doc8 --> Doc8d[・改善提案書]
    
    Phase8 --> Next{次期バージョン}
    Next -->|あり| Phase1
    Next -->|なし| End([プロジェクト終了])
    
    style Start fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
    style End fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
    style Phase1 fill:#ffebee,stroke:#c62828
    style Phase2 fill:#fff3e0,stroke:#e65100
    style Phase3 fill:#fff9c4,stroke:#f57f17
    style Phase4 fill:#f1f8e9,stroke:#558b2f
    style Phase5 fill:#e1f5fe,stroke:#0277bd
    style Phase6 fill:#ede7f6,stroke:#4527a0
    style Phase7 fill:#fce4ec,stroke:#c2185b
    style Phase8 fill:#e0f2f1,stroke:#00695c
    style Gate1 fill:#ffcdd2,stroke:#c62828
    style Gate2 fill:#ffcdd2,stroke:#c62828
    style Gate3 fill:#ffcdd2,stroke:#c62828
    style Gate4 fill:#ffcdd2,stroke:#c62828
    style Gate5 fill:#ffcdd2,stroke:#c62828
    style Gate6 fill:#ffcdd2,stroke:#c62828
```

### 📊 フェーズ別の重要度と難易度

```mermaid
graph TD
    subgraph 重要度と難易度マトリクス
    A[要件定義<br/>★★★★★<br/>最重要]
    B[基本設計<br/>★★★★☆<br/>重要]
    C[詳細設計<br/>★★★☆☆<br/>中]
    D[実装<br/>★★★☆☆<br/>中]
    E[テスト<br/>★★★★☆<br/>重要]
    F[運用<br/>★★★☆☆<br/>中]
    end
    
    style A fill:#ff5252,stroke:#c62828,color:#fff,stroke-width:3px
    style B fill:#ff9800,stroke:#e65100,stroke-width:2px
    style C fill:#ffc107,stroke:#f57f17
    style D fill:#66bb6a,stroke:#2e7d32
    style E fill:#ff9800,stroke:#e65100,stroke-width:2px
    style F fill:#42a5f5,stroke:#0277bd
```

**💡 重要なポイント：**

1. **要件定義が最重要** ⭐⭐⭐⭐⭐
   - ここでの失敗は後で取り返せない
   - 時間をかけてしっかり行う価値がある

2. **設計とテストも重要** ⭐⭐⭐⭐
   - 品質の土台を作る工程

3. **実装は「作業」に近い** ⭐⭐⭐
   - 設計がしっかりしていれば比較的スムーズ

4. **運用は継続的な改善** ⭐⭐⭐
   - リリース後も続く大切な工程

## 2.4 各フェーズの関係性

### 🔗 V字モデル（テストとの対応関係）

システム開発では、**各フェーズとテストが対応**しています：

```mermaid
graph TD
    subgraph "左側: 作る"
    A[要件定義<br/>何を作るか] 
    B[基本設計<br/>どう作るか]
    C[詳細設計<br/>詳しく設計]
    D[実装<br/>コードを書く]
    end
    
    subgraph "右側: 確認する"
    E[受入テスト<br/>要件通り？]
    F[統合テスト<br/>設計通り？]
    G[単体テスト<br/>詳細設計通り？]
    end
    
    A -.対応.- E
    B -.対応.- F
    C -.対応.- G
    D --> G
    G --> F
    F --> E
    
    style A fill:#fff3e0,stroke:#ef6c00
    style B fill:#fff9c4,stroke:#f57f17
    style C fill:#e8f5e9,stroke:#2e7d32
    style D fill:#e1f5fe,stroke:#0277bd
    style E fill:#f3e5f5,stroke:#7b1fa2
    style F fill:#ede7f6,stroke:#4527a0
    style G fill:#ce93d8,stroke:#6a1b9a
```

**対応関係の説明：**

| 作る工程 | テスト工程 | 確認内容 |
|---------|-----------|---------|
| ①要件定義 | ↔ 受入テスト | お客様の要求通りか？ |
| ②基本設計 | ↔ 統合テスト | システム全体が設計通りに動くか？ |
| ③詳細設計 | ↔ 単体テスト | 各部品が設計通りに動くか？ |

### 🎯 トレーサビリティ（追跡可能性）

**全てのフェーズは繋がっている**必要があります：

```mermaid
graph LR
    A[要件ID<br/>FR-001] --> B[設計ID<br/>DS-001]
    B --> C[実装<br/>Commit#123]
    C --> D[テストID<br/>TC-001]
    D --> E[バグID<br/>BUG-001]
    E --> F[修正<br/>Commit#456]
    
    A -.RTMで管理.- D
    
    style A fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    style B fill:#fff9c4,stroke:#f57f17
    style C fill:#e1f5fe,stroke:#0277bd
    style D fill:#f3e5f5,stroke:#7b1fa2
    style E fill:#ffcdd2,stroke:#c62828
    style F fill:#c8e6c9,stroke:#2e7d32
```

**トレーサビリティのメリット：**

- 🔍 **影響範囲の把握**：要件変更時、どこに影響するか一目瞭然
- 🐛 **バグの追跡**：バグがどの要件・設計に関係するか分かる
- 📊 **進捗管理**：どの要件が実装済みか、テスト済みか分かる
- 🔒 **監査対応**：規制の厳しい業界で必須

---

# 第3章：フェーズ別詳細解説

## 3.1 ①企画・課題定義フェーズ

### 📌 このフェーズの目的

**ビジネス課題を明確にし、システム開発で解決する方向性を決める**

家を建てることで例えると：「どんな家にしたいか家族で話し合う段階」

### 🎯 このフェーズで行うこと

```mermaid
graph TD
    A[企画・課題定義フェーズ] --> B[①現状分析]
    A --> C[②課題の特定]
    A --> D[③目標設定]
    A --> E[④実現方法の検討]
    A --> F[⑤費用対効果の試算]
    
    B --> B1[現在の業務プロセス調査]
    B --> B2[データ収集]
    B --> B3[問題点の洗い出し]
    
    C --> C1[根本原因の分析]
    C --> C2[優先順位付け]
    
    D --> D1[KPI設定]
    D --> D2[達成基準の明確化]
    
    E --> E1[システム化の検討]
    E --> E2[他の解決策との比較]
    E --> E3[技術選定]
    
    F --> F1[開発コスト試算]
    F --> F2[運用コスト試算]
    F --> F3[期待効果の算出]
    F --> F4[ROI計算]
    
    style A fill:#ffebee,stroke:#c62828,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#fff9c4,stroke:#f57f17
    style D fill:#e8f5e9,stroke:#2e7d32
    style E fill:#e1f5fe,stroke:#0277bd
    style F fill:#f3e5f5,stroke:#7b1fa2
```

### 📝 具体的な作業内容

#### ①現状分析

**何をするか：**
現在の業務がどうなっているかを調査します。

**具体的な方法：**

- 👥 **インタビュー**：現場の人に話を聞く
  - 「普段どんな作業をしていますか？」
  - 「どこで時間がかかっていますか？」
  - 「困っていることは何ですか？」

- 📊 **データ収集**：数字で現状を把握
  - 作業時間の記録
  - エラー発生率
  - 顧客満足度スコア
  - コスト（人件費、外注費など）

- 🔍 **業務フロー分析**：作業の流れを図にする

  ```mermaid
  graph LR
      A[顧客から問い合わせ] --> B[メール受信]
      B --> C[担当者が<br/>システムAを検索]
      C --> D[システムBを検索]
      D --> E[システムCを検索]
      E --> F[情報を統合]
      F --> G[回答メール作成]
      G --> H[送信]
      
      style C fill:#ffcdd2,stroke:#c62828
      style D fill:#ffcdd2,stroke:#c62828
      style E fill:#ffcdd2,stroke:#c62828
      style F fill:#ffcdd2,stroke:#c62828
  ```

  ↑ 赤い部分が「時間がかかっている」問題箇所

**アウトプット例：**

| 項目 | 現状値 | データ源 |
|-----|--------|---------|
| 平均対応時間 | 2時間 | 対応履歴の分析 |
| 1日の問い合わせ数 | 50件 | メールログ |
| 担当者数 | 10人 | 組織図 |
| 月間コスト | 500万円 | 人件費計算 |
| 顧客満足度 | 60% | アンケート結果 |

#### ②課題の特定

**何をするか：**
問題の「根本原因」を見つけます。

**技法：なぜなぜ分析（5 Why）**

```mermaid
graph TD
    A[問題: 顧客対応が遅い] --> B[なぜ？<br/>情報を探すのに時間がかかる]
    B --> C[なぜ？<br/>3つのシステムに分散している]
    C --> D[なぜ？<br/>過去に別々に導入したから]
    D --> E[なぜ？<br/>統合計画がなかった]
    E --> F[根本原因:<br/>全体最適の視点が欠けていた]
    
    style A fill:#ffcdd2,stroke:#c62828
    style F fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
```

**課題の優先順位付け：**

| 課題 | 影響度 | 緊急度 | 優先度 | 対応 |
|-----|--------|--------|--------|------|
| 情報検索に時間がかかる | 高 | 高 | **最優先** | システム統合 |
| 対応品質にばらつき | 中 | 中 | 中 | ナレッジベース整備 |
| モバイル対応していない | 低 | 低 | 後回し | 次期検討 |

#### ③目標設定（KPI設定）

**SMART原則**に従って目標を設定します：

```mermaid
graph LR
    A[SMART原則] --> B[S: Specific<br/>具体的]
    A --> C[M: Measurable<br/>測定可能]
    A --> D[A: Achievable<br/>達成可能]
    A --> E[R: Relevant<br/>関連性がある]
    A --> F[T: Time-bound<br/>期限がある]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:2px
```

**良い目標の例：**

| KPI | 現状値 | 目標値 | 期限 | 測定方法 |
|-----|--------|--------|------|---------|
| 平均対応時間 | 2時間 | 1時間 | 6ヶ月後 | システムログ |
| 顧客満足度 | 60% | 85% | 6ヶ月後 | アンケート |
| 対応コスト | 500万円/月 | 350万円/月 | 1年後 | 人件費計算 |
| 初回解決率 | 70% | 90% | 6ヶ月後 | 問い合わせ履歴 |

**❌ 悪い目標の例：**

- 「できるだけ早く」 → 測定できない
- 「使いやすくする」 → 具体的でない
- 「いつかやる」 → 期限がない

#### ④実現方法の検討

**選択肢を比較する：**

| 選択肢 | メリット | デメリット | コスト | 期間 | 評価 |
|-------|---------|----------|--------|------|------|
| **①新規システム開発** | ・要件にぴったり合う<br/>・カスタマイズ自由 | ・コストが高い<br/>・開発期間が長い | 2000万円 | 6ヶ月 | ⭐⭐⭐ |
| **②パッケージ導入** | ・早く始められる<br/>・コストが安い | ・カスタマイズ制限<br/>・運用コストあり | 500万円 | 2ヶ月 | ⭐⭐⭐⭐ |
| **③SaaS利用** | ・最も早い<br/>・初期コスト低い | ・カスタマイズ不可<br/>・月額費用あり | 初期50万円<br/>月20万円 | 1ヶ月 | ⭐⭐⭐⭐⭐ |
| **④業務改善のみ** | ・コスト最小<br/>・すぐできる | ・効果が限定的<br/>・根本解決しない | 50万円 | 1週間 | ⭐⭐ |

**💡 意思決定マトリクス：**

```mermaid
graph TD
    A[要件] --> B{カスタマイズ<br/>必須？}
    B -->|はい| C{予算<br/>2000万円以上？}
    B -->|いいえ| D{既存業務<br/>変更可能？}
    
    C -->|はい| E[①新規開発]
    C -->|いいえ| F[①と②の<br/>ハイブリッド]
    
    D -->|はい| G{月額費用<br/>許容できる？}
    D -->|いいえ| H[②パッケージ]
    
    G -->|はい| I[③SaaS]
    G -->|いいえ| H
    
    style E fill:#e1f5fe,stroke:#0277bd
    style F fill:#fff9c4,stroke:#f57f17
    style H fill:#f3e5f5,stroke:#7b1fa2
    style I fill:#c8e6c9,stroke:#2e7d32
```

**💡 各選択肢のリスクと対策：**

| 選択肢 | 主なリスク | リスク対策 |
|-------|----------|----------|
| **①新規開発** | ・開発遅延<br/>・コスト超過<br/>・品質問題 | ・アジャイル採用で段階的開発<br/>・MVP（最小機能）を先行リリース<br/>・経験豊富なPMをアサイン |
| **②パッケージ** | ・カスタマイズ限界<br/>・業務への適合不足<br/>・ベンダー依存 | ・要件の優先順位を明確化（Must/Should/Could）<br/>・パッケージの制約を事前に確認<br/>・複数ベンダーを比較検討 |
| **③SaaS** | ・ベンダーロックイン<br/>・データ移行困難<br/>・サービス終了リスク | ・データエクスポート機能を確認<br/>・API連携可能性を確認<br/>・SLA（サービス品質保証）を確認 |
| **④業務改善** | ・効果が限定的<br/>・根本解決しない<br/>・モチベーション低下 | ・改善効果を測定・可視化<br/>・次フェーズの計画を明示<br/>・現場の意見を積極的に取り入れる |

#### ⑤費用対効果の試算

**ROI（投資対効果）の計算：**

```
ROI = (得られる効果 - 投資額) ÷ 投資額 × 100%
```

**計算例：**

**【投資額】**

- 開発費：2,000万円
- 運用費（年間）：500万円
- 合計（3年間）：2,000 + 500×3 = 3,500万円

**【期待効果（年間）】**

- 人件費削減：1,000万円/年
- エラー減少による損失回避：300万円/年
- 顧客満足度向上による売上増：200万円/年
- 合計：1,500万円/年
- 3年間：4,500万円

**【ROI計算】**

```
ROI = (4,500万円 - 3,500万円) ÷ 3,500万円 × 100%
    = 28.6%

回収期間 = 3,500万円 ÷ 1,500万円/年 = 2.3年
```

**💡 判断基準：**

- ROI > 20%：投資価値あり
- 回収期間 < 3年：許容範囲内

### 📄 作成するドキュメント

#### ①企画書（プロジェクト提案書）

**使用テンプレート：**

```markdown
# プロジェクト企画書

## 1. エグゼクティブサマリー（1ページで要約）
- プロジェクト名：顧客対応統合システム構築プロジェクト
- 目的：顧客対応業務の効率化と顧客満足度向上
- 投資額：2,000万円
- 期待効果：年間1,500万円のコスト削減
- ROI：28.6%（3年間）
- 実施期間：2026年1月〜6月（6ヶ月）

## 2. 背景と課題

### 2.1 ビジネス背景
- 当社は年間10万件の顧客問い合わせを受け付けている
- 顧客満足度が競合他社より10ポイント低い（60% vs 70%）
- 業界の顧客体験向上トレンドに遅れている

### 2.2 現状の問題点

| 問題 | 定量データ | 根本原因 |
|-----|----------|---------|
| 対応時間が長い | 平均2時間/件 | 情報が3システムに分散 |
| 対応品質のばらつき | 初回解決率70% | ナレッジが属人化 |
| 夜間・休日対応不可 | 対応時間9-18時のみ | 自動化されていない |

### 2.3 課題の重要性
- 顧客満足度1ポイント低下で年間売上0.5%減少（実績データ）
- 競合他社がAI活用を開始（市場調査）
- 現状のまま3年後に顧客離れのリスク

## 3. 目的・目標

### 3.1 プロジェクトの目的
顧客情報を統合管理し、迅速で質の高い顧客対応を実現する

### 3.2 KPI（重要業績評価指標）

| KPI | 現状 | 6ヶ月後目標 | 1年後目標 | 測定方法 |
|-----|------|-----------|----------|---------|
| 平均対応時間 | 2時間 | 1時間 | 45分 | システムログ |
| 顧客満足度 | 60% | 75% | 85% | 月次アンケート |
| 初回解決率 | 70% | 85% | 90% | 問い合わせ履歴 |
| 対応可能時間 | 9時間/日 | 12時間/日 | 24時間/日 | システム稼働時間 |

### 3.3 ビジネス上の期待効果
- 顧客満足度向上による顧客維持率向上：2%UP
- 対応効率化による人件費削減：年間1,000万円
- 競合優位性の確保

## 4. 解決策

### 4.1 システム概要
顧客情報統合プラットフォームの構築

**主要機能：**
1. 顧客情報の統合検索（3システムを横断）
2. 対応履歴の一元管理
3. AIによる回答候補提示
4. FAQ自動検索機能
5. リアルタイムダッシュボード

### 4.2 システム構成図

[ここにシステム構成図を挿入]

### 4.3 技術選定

| 選定項目 | 選定結果 | 選定理由 |
|---------|---------|---------|
| クラウド基盤 | AWS | 実績豊富、拡張性高い |
| データベース | PostgreSQL | 高信頼性、コスト適正 |
| AI/ML | OpenAI API | 精度が高い、導入が容易 |
| フロントエンド | React | 開発効率が高い |

## 5. 実施計画

### 5.1 スケジュール

| フェーズ | 期間 | 主な作業 | 成果物 |
|---------|------|---------|--------|
| 要件定義 | 2026/1-2月 | ヒアリング、要件整理 | SRS |
| 基本設計 | 2026/2-3月 | アーキテクチャ設計 | 基本設計書 |
| 詳細設計 | 2026/3-4月 | 画面・DB設計 | 詳細設計書 |
| 開発 | 2026/4-5月 | 実装・単体テスト | ソースコード |
| テスト | 2026/5-6月 | 統合・総合テスト | テスト報告書 |
| リリース | 2026/6月 | 本番展開 | リリースノート |

### 5.2 マイルストーン

```mermaid
gantt
    title プロジェクトスケジュール
    dateFormat YYYY-MM
    section 企画
    企画承認           :milestone, 2025-12, 0d
    section 要件定義
    要件定義           :2026-01, 2M
    要件承認           :milestone, 2026-02, 0d
    section 設計
    基本設計           :2026-02, 2M
    詳細設計           :2026-03, 2M
    設計承認           :milestone, 2026-04, 0d
    section 開発・テスト
    開発               :2026-04, 2M
    テスト             :2026-05, 2M
    テスト合格         :milestone, 2026-06, 0d
    section リリース
    本番リリース       :2026-06, 1M
    プロジェクト完了   :milestone, 2026-06, 0d
```

### 5.3 体制

```mermaid
graph TD
    A[プロジェクトオーナー<br/>事業部長: 山田] --> B[プロジェクトマネージャー<br/>田中]
    
    B --> C[要件定義チーム]
    B --> D[開発チーム]
    B --> E[テストチーム]
    B --> F[インフラチーム]
    
    C --> C1[SE: 佐藤]
    C --> C2[業務担当: 鈴木]
    
    D --> D1[リーダー: 高橋]
    D --> D2[開発者: 3名]
    
    E --> E1[QAリーダー: 伊藤]
    E --> E2[テスター: 2名]
    
    F --> F1[インフラSE: 渡辺]
    
    style A fill:#ffebee,stroke:#c62828
    style B fill:#e1f5fe,stroke:#0277bd,stroke-width:2px
```

| 役割 | 氏名 | 責任範囲 | 稼働率 |
|-----|------|---------|--------|
| プロジェクトオーナー | 山田 | 最終意思決定、予算承認 | 10% |
| プロジェクトマネージャー | 田中 | 全体管理、進捗管理 | 100% |
| 要件定義リーダー | 佐藤 | 要件定義、設計レビュー | 100% |
| 開発リーダー | 高橋 | 開発管理、コードレビュー | 100% |
| QAリーダー | 伊藤 | テスト計画、品質保証 | 100% |

## 6. 予算

### 6.1 概算コスト

| カテゴリ | 項目 | 金額 | 備考 |
|---------|------|------|------|
| **開発費** | | **20,000,000円** | |
| | 要件定義・設計 | 5,000,000円 | 2ヶ月 × 2名 |
| | 開発 | 12,000,000円 | 3ヶ月 × 4名 |
| | テスト | 3,000,000円 | 2ヶ月 × 2名 |
| **インフラ費（初期）** | | **2,000,000円** | |
| | AWS環境構築 | 1,500,000円 | VPC、RDS等 |
| | ライセンス | 500,000円 | 各種ツール |
| **運用費（年間）** | | **5,000,000円** | |
| | AWS利用料 | 3,000,000円/年 | 月25万円 |
| | 保守費用 | 2,000,000円/年 | 月16.7万円 |
| **予備費** | | **1,000,000円** | 全体の5% |
| **合計（初期）** | | **23,000,000円** | |
| **合計（3年間）** | | **38,000,000円** | 初期 + 運用3年分 |

### 6.2 費用対効果

**【効果（年間）】**

| 効果項目 | 金額 | 算出根拠 |
|---------|------|---------|
| 人件費削減 | 10,000,000円 | 対応時間半減 → 5名分の工数削減 |
| エラー対応コスト削減 | 3,000,000円 | 誤回答30%減 → 再対応減少 |
| 残業代削減 | 2,000,000円 | 業務効率化による残業減 |
| **合計** | **15,000,000円/年** | |

**【ROI計算】**

```
3年間の効果：15,000,000円 × 3年 = 45,000,000円
3年間の投資：38,000,000円

ROI = (45,000,000 - 38,000,000) ÷ 38,000,000 × 100%
    = 18.4%

投資回収期間 = 38,000,000 ÷ 15,000,000
              = 2.5年
```

## 7. リスクと対策

| リスク | 影響度 | 発生確率 | 対策 |
|-------|--------|---------|------|
| 要件の追加・変更 | 高 | 中 | ・要件定義を丁寧に実施<br/>・変更管理プロセスの徹底 |
| 開発遅延 | 中 | 中 | ・バッファ期間の確保<br/>・週次進捗確認 |
| 既存システムとの連携問題 | 高 | 低 | ・早期の連携テスト実施<br/>・API仕様の事前確認 |
| キーメンバーの離脱 | 高 | 低 | ・ドキュメントの充実<br/>・ナレッジ共有の徹底 |
| セキュリティインシデント | 高 | 低 | ・セキュリティレビューの実施<br/>・脆弱性診断の実施 |

## 8. 成功基準

### 8.1 プロジェクト成功基準

| 基準 | 目標 | 測定方法 | 判定時期 |
|-----|------|---------|---------|
| QCD達成 | 品質・コスト・納期を全て達成 | 各指標で判定 | リリース時 |
| 品質（Quality） | 重大バグゼロでリリース | バグ管理表 | リリース時 |
| コスト（Cost） | 予算±10%以内 | 予実管理表 | リリース時 |
| 納期（Delivery） | 2026年6月末リリース | スケジュール | リリース時 |
| KPI達成 | 6ヶ月後に目標値の80%達成 | KPIダッシュボード | 6ヶ月後 |

### 8.2 ビジネス成功基準

| 基準 | 目標 | 測定時期 |
|-----|------|---------|
| 顧客満足度 | 60% → 75%以上 | リリース6ヶ月後 |
| 対応時間 | 2時間 → 1時間以内 | リリース6ヶ月後 |
| ROI | 18%以上 | 3年後 |

## 9. 承認

| 役職 | 氏名 | 承認日 | サイン |
|-----|------|--------|--------|
| 事業部長 | 山田太郎 | 2025/12/15 | [署名] |
| CIO | 佐藤花子 | 2025/12/16 | [署名] |
| CFO | 鈴木一郎 | 2025/12/17 | [署名] |

## 10. 変更履歴

| バージョン | 日付 | 変更者 | 変更内容 |
|-----------|------|--------|---------|
| 0.1 | 2025/11/20 | 田中 | 初稿作成 |
| 0.2 | 2025/12/01 | 田中 | レビュー指摘事項反映 |
| 1.0 | 2025/12/15 | 田中 | 承認版（確定） |

```

#### ②RFP（提案依頼書）

外部の開発会社に発注する場合に作成します。

**使用テンプレート：**

```markdown
# 提案依頼書（Request for Proposal）

発行日：2025年12月1日  
提案期限：2025年12月20日 17:00  
発行者：株式会社○○ システム企画部

## 1. プロジェクト概要

### 1.1 背景
当社では、年間10万件の顧客問い合わせに対応していますが、
情報が3つのシステムに分散しており、対応に平均2時間を要しています。
顧客満足度が60%と低迷しており、早急な改善が必要です。

### 1.2 目的
顧客情報を統合管理し、対応時間を半減（1時間以内）、
顧客満足度を85%以上に向上させることを目的とします。

### 1.3 プロジェクト規模
- 予算：2,000万円（税抜）
- 期間：2026年1月〜6月（6ヶ月）
- 対象ユーザー数：100名（カスタマーサポート部門）

## 2. 現状システムと課題

### 2.1 既存システム構成

| システム名 | 用途 | データ量 | 連携要否 |
|-----------|------|---------|---------|
| 顧客管理システム（System A） | 顧客基本情報 | 10万件 | ✓必須 |
| 問い合わせ管理システム（System B） | 対応履歴 | 50万件 | ✓必須 |
| 会計システム（System C） | 購買履歴 | 100万件 | ✓必須 |

### 2.2 課題一覧

| No. | 課題 | 現状 | 影響 |
|-----|------|------|------|
| 1 | 情報検索に時間がかかる | 3システムを順番に検索 | 対応時間2時間 |
| 2 | データの不整合 | 同期がリアルタイムでない | 誤回答が月30件 |
| 3 | 対応品質のばらつき | ナレッジが属人化 | 初回解決率70% |
| 4 | 夜間対応不可 | 人手が必要 | 機会損失 |

## 3. 要求事項

### 3.1 必須要件（Must Have）

これらは必ず実現していただく必要があります。

| 要件ID | 要件 | 詳細 |
|-------|------|------|
| REQ-001 | 統合検索機能 | 3システムを横断して顧客情報を検索できる |
| REQ-002 | リアルタイム連携 | データの同期遅延が1分以内 |
| REQ-003 | 対応履歴管理 | 過去の全ての対応履歴を参照・登録できる |
| REQ-004 | レスポンスタイム | 検索結果表示が3秒以内（95%パーセンタイル）<br/>※95%パーセンタイル: 100回のうち95回は3秒以内、という意味 |
| REQ-005 | 可用性 | 月間稼働率99.9%以上 |
| REQ-006 | セキュリティ | 個人情報保護法に準拠、ISMS認証取得済みの環境 |
| REQ-007 | 権限管理 | ロールベースアクセス制御（RBAC） |
| REQ-008 | ログ記録 | 全操作ログを記録（監査対応） |

### 3.2 推奨要件（Should Have）

実現していただきたいが、予算・期間の制約で次期以降も可能。

| 要件ID | 要件 | 詳細 | 優先度 |
|-------|------|------|--------|
| REQ-101 | AI回答提示 | 過去の対応からAIが回答候補を提示 | 高 |
| REQ-102 | FAQ自動検索 | 問い合わせ内容から自動的にFAQを検索 | 高 |
| REQ-103 | モバイル対応 | スマートフォン・タブレットで利用可能 | 中 |
| REQ-104 | 多言語対応 | 日本語・英語・中国語に対応 | 低 |
| REQ-105 | チャットボット | 簡単な問い合わせは自動応答 | 中 |

### 3.3 非機能要件

| カテゴリ | 要件 | 基準値 |
|---------|------|--------|
| 性能 | 同時アクセス数 | 100ユーザー |
| 性能 | データ量 | 顧客10万件、履歴100万件 |
| 性能 | 検索速度 | 3秒以内（95%ile） |
| 可用性 | 稼働率 | 99.9%（月間） |
| 可用性 | 目標復旧時間（RTO） | 1時間以内 |
| 可用性 | 目標復旧時点（RPO） | 1時間以内 |
| セキュリティ | 暗号化 | 通信・保存データとも暗号化必須 |
| セキュリティ | 脆弱性対応 | OWASP Top 10への対策必須 |
| 保守性 | ドキュメント | 設計書、運用手順書の提供必須 |
| 保守性 | ソースコード | 引き渡し必須、著作権は当社に帰属 |

## 4. 制約条件

### 4.1 技術的制約

| 項目 | 制約内容 | 理由 |
|-----|---------|------|
| クラウド | AWSまたはAzureを使用 | 社内標準 |
| データベース | PostgreSQLまたはMySQL | 運用実績あり |
| 認証 | 既存のAD（Active Directory）と連携 | シングルサインオン必須 |
| ネットワーク | 社内ネットワークからのみアクセス | セキュリティポリシー |

### 4.2 プロジェクト制約

| 項目 | 制約内容 |
|-----|---------|
| 予算 | 2,000万円（税抜）以内 |
| 納期 | 2026年6月30日（厳守） |
| リソース | 当社からPM1名、業務担当2名を提供 |
| 環境 | 開発環境は当社AWS環境を使用 |

### 4.3 法的・規制制約

| 項目 | 制約内容 |
|-----|---------|
| 個人情報保護法 | 準拠必須 |
| データセンター | 日本国内であること |
| 監査 | 年次監査への対応必須 |

## 5. 提案依頼事項

提案書には以下の内容を含めてください。

### 5.1 必須記載事項

| No. | 項目 | 詳細 |
|-----|------|------|
| 1 | 提案概要 | プロジェクトの理解と提案アプローチ（2ページ以内） |
| 2 | システム構成 | アーキテクチャ図、技術スタック |
| 3 | 機能概要 | 必須要件・推奨要件への対応方法 |
| 4 | スケジュール | WBS、ガントチャート、マイルストーン |
| 5 | 体制図 | プロジェクト体制、各メンバーの役割・経験年数 |
| 6 | 見積金額 | 詳細な内訳（工程別、工数×単価） |
| 7 | 類似実績 | 過去3年以内の類似案件実績（3件以上） |
| 8 | 品質保証 | テスト計画、品質管理手法 |
| 9 | リスク対策 | 想定リスクと対策 |
| 10 | 保守運用 | リリース後のサポート体制、費用 |

### 5.2 評価基準

提案は以下の基準で評価します。

| 評価項目 | 配点 | 評価ポイント |
|---------|------|------------|
| 技術力 | 30点 | ・提案内容の技術的妥当性<br/>・最新技術の活用<br/>・拡張性・保守性 |
| 実績・信頼性 | 25点 | ・類似案件の実績<br/>・企業の信頼性<br/>・技術者のスキル |
| コスト | 20点 | ・見積金額の妥当性<br/>・コストパフォーマンス |
| スケジュール | 15点 | ・納期遵守の実現性<br/>・スケジュールの妥当性 |
| 提案内容 | 10点 | ・課題理解の深さ<br/>・提案の独自性・創造性 |
| **合計** | **100点** | 80点以上を合格とする |

## 6. スケジュール

| イベント | 日時 | 備考 |
|---------|------|------|
| RFP公開 | 2025年12月1日 | 本文書 |
| 質問受付期限 | 2025年12月10日 17:00 | メールにて受付 |
| 質問回答 | 2025年12月13日 | 全社に同じ回答を共有 |
| 提案書提出期限 | 2025年12月20日 17:00 | 紙5部+PDF |
| 一次評価 | 2025年12月24日 | 書類選考 |
| プレゼンテーション | 2026年1月8-10日 | 一次通過企業のみ |
| 最終選定 | 2026年1月15日 | |
| 契約締結 | 2026年1月20日 | |
| プロジェクト開始 | 2026年1月27日 | キックオフミーティング |

## 7. 提案書提出要領

### 7.1 提出方法
- 紙媒体：5部（A4サイズ、片面印刷、製本）
- 電子データ：PDF形式（メールまたはファイル転送サービス）

### 7.2 提出先
```

〒100-0001
東京都千代田区千代田1-1-1
株式会社○○ システム企画部
RFP担当：田中太郎
Email: <tanaka@example.com>
Tel: 03-1234-5678

```

### 7.3 質問方法
質問は以下のフォーマットでメールにて受け付けます。

```

件名：【RFP質問】顧客対応統合システム
会社名：
担当者名：
質問No.：
該当箇所：（RFPの章番号）
質問内容：

```

## 8. 選定後の進め方

### 8.1 契約形態
- 基本：準委任契約（月額精算）
- 一部：請負契約（成果物納品ベース）

### 8.2 支払条件（案）
- 契約時：10%
- 基本設計完了時：20%
- 詳細設計完了時：20%
- 開発完了時：30%
- 受入テスト合格時：20%

### 8.3 知的財産権
- 開発成果物の著作権は全て当社に帰属
- オープンソースライセンスがある場合は事前報告必須

## 9. 禁止事項・注意事項

### 9.1 機密保持
- 本RFPの内容は機密情報として扱ってください
- 第三者への開示・漏洩を禁止します
- 提案書作成以外の目的で使用しないでください

### 9.2 費用負担
- 提案書作成にかかる費用は貴社負担とします
- 選定されなかった場合でも費用の請求はできません

### 9.3 その他
- 提案内容について追加ヒアリングをお願いすることがあります
- 選定理由についてのお問い合わせにはお答えできません
- 提案書は返却いたしません

## 10. 問い合わせ先

```

株式会社○○ システム企画部
プロジェクトマネージャー：田中太郎

〒100-0001
東京都千代田区千代田1-1-1 ○○ビル10F

Tel: 03-1234-5678
Email: <tanaka@example.com>
受付時間：平日9:00-18:00（土日祝日を除く）

```

---
以上
```

### 🎓 このフェーズのまとめ

**✅ やること：**

1. 現状分析（データ収集・業務フロー分析）
2. 課題特定（なぜなぜ分析）
3. 目標設定（SMART原則でKPI設定）
4. 実現方法検討（複数案を比較）
5. 費用対効果試算（ROI計算）

**📄 作るドキュメント：**

- 企画書（内部向け）
- RFP（外部発注の場合）
- プロジェクト計画書

**⚠️ よくある失敗：**

- 現状分析が不十分（思い込みで進める）
- 課題の優先順位が不明確
- 目標が曖昧（測定できない）
- ROIの根拠が薄い

**💡 成功のコツ：**

- 数字で語る（感覚ではなく実データ）
- ステークホルダー全員の合意を取る
- リスクを過小評価しない
- 早い段階で外部の専門家の意見を聞く

## 3.2 ②要件定義フェーズ（最重要！）

### 🌟 このフェーズの重要性

**「システム開発の成否は要件定義で80%決まる」**

このフェーズは**システム開発で最も重要**です。ここでの失敗が、後のすべてのトラブルの原因になります。

```mermaid
graph TD
    A[要件定義の質] --> B{良い}
    A --> C{悪い}
    
    B --> B1[✅ 仕様変更が少ない]
    B --> B2[✅ 開発がスムーズ]
    B --> B3[✅ 予算内で完成]
    B --> B4[✅ 納期通り]
    B --> B5[✅ 高品質]
    
    C --> C1[❌ 頻繁な仕様変更]
    C --> C2[❌ 開発の遅延]
    C --> C3[❌ 予算超過]
    C --> C4[❌ 納期遅延]
    C --> C5[❌ 品質問題]
    C --> C6[❌ プロジェクト失敗]
    
    style A fill:#fff3e0,stroke:#ef6c00,stroke-width:3px
    style B fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
    style C fill:#ffcdd2,stroke:#c62828,stroke-width:2px
    style C6 fill:#c62828,stroke:#b71c1c,color:#fff,stroke-width:3px
```

### 📌 このフェーズの目的

**「何を作るか（WHAT）」を明確に定義する**

家を建てることで例えると：「どんな間取り・設備にするか詳細に決める段階」

### 🎯 このフェーズで行うこと

```mermaid
graph TD
    A[要件定義フェーズ] --> B[①ステークホルダー特定]
    A --> C[②ヒアリング実施]
    A --> D[③要件の整理]
    A --> E[④優先順位付け]
    A --> F[⑤受入基準の定義]
    
    B --> B1[誰が関係者か洗い出す]
    B --> B2[それぞれの立場・関心事を理解]
    
    C --> C1[現場の声を聞く]
    C --> C2[困りごとを深掘り]
    C --> C3[暗黙の期待を引き出す]
    
    D --> D1[機能要件の整理]
    D --> D2[非機能要件の整理]
    D --> D3[制約条件の整理]
    
    E --> E1[Must/Should/Could/Won'tで分類]
    E --> E2[ビジネス価値で判断]
    E --> E3[リスクも考慮]
    
    F --> F1[合否判定できる基準を書く]
    F --> F2[Gherkin形式で記述]
    F --> F3[測定方法も明記]
    
    style A fill:#fff3e0,stroke:#ef6c00,stroke-width:3px
    style B fill:#e1f5fe,stroke:#0277bd
    style C fill:#f3e5f5,stroke:#7b1fa2
    style D fill:#fff9c4,stroke:#f57f17
    style E fill:#c8e6c9,stroke:#2e7d32
    style F fill:#fce4ec,stroke:#c2185b
```

### 📝 具体的な作業内容

#### ①ステークホルダーの特定

**ステークホルダー**とは、プロジェクトに関係する全ての人のことです。

**RACI図で整理する：**

```mermaid
graph TD
    A[ステークホルダー分析] --> B[R: Responsible<br/>実行責任者]
    A --> C[A: Accountable<br/>説明責任者]
    A --> D[C: Consulted<br/>相談される人]
    A --> E[I: Informed<br/>報告を受ける人]
    
    B --> B1[例: 開発リーダー<br/>実際に作る人]
    C --> C1[例: PM<br/>最終責任を負う人]
    D --> D1[例: 業務部門<br/>意見を求められる人]
    E --> E1[例: 経営層<br/>進捗を知る人]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:2px
    style B fill:#fff9c4,stroke:#f57f17
    style C fill:#ffcdd2,stroke:#c62828
    style D fill:#f3e5f5,stroke:#7b1fa2
    style E fill:#c8e6c9,stroke:#2e7d32
```

**RACI表の例：**

| タスク | PM<br/>田中 | SE<br/>佐藤 | 開発者<br/>高橋 | 業務<br/>鈴木 | 経営層<br/>山田 |
|-------|:-:|:-:|:-:|:-:|:-:|
| 要件定義 | **A** | R | C | C | I |
| 基本設計 | **A** | R | C | C | I |
| 実装 | **A** | C | R | I | I |
| テスト | **A** | R | R | C | I |
| リリース判定 | R | C | I | C | **A** |

- **R = Responsible（実行責任）**: 実際に作業する人
- **A = Accountable（説明責任）**: 最終的に責任を負う人（1つのタスクに1人だけ）
- **C = Consulted（相談）**: 意見を聞く人
- **I = Informed（報告）**: 結果を報告する人

#### ②ヒアリングの実施

**ヒアリングの技術**は要件定義の成否を分けます。

**❌ 悪いヒアリングの例：**

```
SE：「どんなシステムが欲しいですか？」
お客様：「使いやすいシステムです」
SE：「分かりました」
→ 具体的なことが何も分からない！
```

**✅ 良いヒアリングの例：**

```
SE：「現在、顧客対応でどんな作業をしていますか？」
お客様：「問い合わせメールを見て、3つのシステムで情報を探します」

SE：「3つのシステムとは？」
お客様：「顧客情報、購買履歴、対応履歴のシステムです」

SE：「それぞれどのくらい時間がかかりますか？」
お客様：「合計で30分くらいですね」

SE：「もし統合されていたら、どうなりますか？」
お客様：「1回の検索で済むので、5分で終わると思います」

SE：「では、25分短縮されるということですね。
     1日に何件くらい対応していますか？」
お客様：「1人あたり20件です」

SE：「ということは、1日あたり8時間以上削減できますね」
→ 具体的な効果が見えてきた！
```

**ヒアリングの5W1H：**

| 質問 | 例 | 引き出したいこと |
|-----|---|----------------|
| **Who**（誰が） | 誰が使いますか？ | ユーザー像、権限 |
| **What**（何を） | 何をしますか？ | 機能、データ |
| **When**（いつ） | いつ使いますか？ | タイミング、頻度 |
| **Where**（どこで） | どこで使いますか？ | 場所、環境 |
| **Why**（なぜ） | なぜ必要ですか？ | 目的、価値 |
| **How**（どう） | どう実現しますか？ | 方法、手順 |

**深掘りの技術：なぜを5回繰り返す**

```mermaid
graph TD
    A[問い合わせ対応が遅い] -->|なぜ？| B[情報検索に時間がかかる]
    B -->|なぜ？| C[3つのシステムを見る必要がある]
    C -->|なぜ？| D[データが統合されていない]
    D -->|なぜ？| E[別々に導入したから]
    E -->|なぜ？| F[全体最適の視点がなかった]
    
    F --> G[🎯 真の課題:<br/>システム統合が必要]
    
    style A fill:#ffcdd2,stroke:#c62828
    style F fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    style G fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
```

#### ③要件の整理

要件には大きく分けて**2種類**あります。

##### 機能要件（Functional Requirements: FR）

**「システムが何をするか」を定義します。**

**書き方のルール：**

1. **1文で1つの要件**を記述
2. **主語・述語を明確に**
3. **曖昧な表現を避ける**
4. **検証可能に**書く

**❌ 悪い例：**

```
FR-001: システムは使いやすくする
→ 何が「使いやすい」か分からない

FR-002: データを高速に処理する
→ 「高速」の基準が不明

FR-003: セキュリティを考慮する
→ 具体的に何をするのか不明
```

**✅ 良い例：**

```
FR-001: ユーザーは顧客名または電話番号で顧客を検索できる

FR-002: 検索結果は3秒以内に画面に表示される

FR-003: ログイン時に2要素認証（ワンタイムパスワード）を使用する
```

**機能要件の記述テンプレート：**

```markdown
## 機能要件

### FR-001: 顧客検索機能

**概要:**  
ユーザーは顧客名、電話番号、メールアドレスのいずれかで顧客を検索できる。

**詳細:**
- 検索条件
  - 顧客名：部分一致検索（前方、後方、中間一致）
  - 電話番号：完全一致検索（ハイフンあり・なし両対応）
  - メールアドレス：完全一致検索
- 検索条件は AND 条件で組み合わせ可能
- 検索結果は顧客名の50音順でソート
- 検索結果が100件を超える場合は、最初の100件のみ表示し、警告メッセージを表示

**受入基準（Gherkin）:**
```gherkin
機能: 顧客検索

シナリオ: 顧客名で検索
  前提 データベースに「山田太郎」という顧客が登録されている
  もし ユーザーが顧客名に「山田」を入力して検索する
  ならば 検索結果に「山田太郎」が表示される
  かつ 検索結果は3秒以内に表示される

シナリオ: 検索条件なしでの検索
  前提 ユーザーがログインしている
  もし ユーザーが何も入力せずに検索ボタンを押す
  ならば エラーメッセージ「検索条件を入力してください」が表示される
  かつ 検索は実行されない

シナリオ: 検索結果が100件を超える場合
  前提 検索条件に該当する顧客が150件存在する
  もし ユーザーが検索を実行する
  ならば 最初の100件が表示される
  かつ 「検索結果が100件を超えました。条件を絞り込んでください」というメッセージが表示される
```

**画面イメージ:**
[ここに画面のワイヤーフレームを添付]

**優先度:** Must（必須）

**関連要件:** FR-002（顧客詳細表示）、NFR-001（レスポンスタイム）

**備考:**

- 既存システムA、B、Cのデータを統合して検索する
- 検索ログは監査用に記録する

```

**機能要件一覧の例：**

| 要件ID | 機能名 | 概要 | 優先度 | 工数見積 |
|-------|--------|------|--------|---------|
| FR-001 | 顧客検索 | 顧客名・電話番号で検索 | Must | 10人日 |
| FR-002 | 顧客詳細表示 | 顧客の詳細情報を表示 | Must | 5人日 |
| FR-003 | 対応履歴登録 | 対応内容を記録 | Must | 15人日 |
| FR-004 | 対応履歴検索 | 過去の対応を検索 | Must | 8人日 |
| FR-005 | レポート出力 | 月次レポートをPDF出力 | Should | 12人日 |
| FR-006 | AI回答提示 | 過去データからAI提案 | Should | 20人日 |
| FR-007 | モバイル対応 | スマホ・タブレット対応 | Could | 15人日 |

**優先度の分類（MoSCoW法）：**

```mermaid
graph TD
    A[要件の優先順位] --> B[Must<br/>必須]
    A --> C[Should<br/>推奨]
    A --> D[Could<br/>任意]
    A --> E[Won't<br/>対象外]
    
    B --> B1[絶対に必要<br/>ないと困る]
    C --> C1[あると良い<br/>できれば欲しい]
    D --> D1[あれば嬉しい<br/>なくても大丈夫]
    E --> E1[今回は作らない<br/>将来検討]
    
    B --> B2[例: ログイン機能]
    C --> C2[例: PDF出力機能]
    D --> D2[例: モバイル対応]
    E --> E2[例: AI音声認識]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:2px
    style B fill:#ffcdd2,stroke:#c62828,stroke-width:2px
    style C fill:#fff9c4,stroke:#f57f17
    style D fill:#c8e6c9,stroke:#2e7d32
    style E fill:#e0e0e0,stroke:#757575
```

##### 非機能要件（Non-Functional Requirements: NFR）

**「システムの品質」に関する要件です。**

これが曖昧だと、**「動くけど使えない」システム**ができてしまいます。

**6つのカテゴリ（ISO 25010品質モデル）：**

```mermaid
graph TD
    A[非機能要件] --> B[①性能・効率性]
    A --> C[②可用性・信頼性]
    A --> D[③セキュリティ]
    A --> E[④保守性]
    A --> F[⑤使用性]
    A --> G[⑥移植性]
    
    B --> B1[レスポンスタイム<br/>スループット<br/>リソース使用量]
    
    C --> C1[稼働率<br/>障害復旧時間<br/>バックアップ]
    
    D --> D1[認証・認可<br/>暗号化<br/>監査ログ]
    
    E --> E1[コードの読みやすさ<br/>テストのしやすさ<br/>変更の容易さ]
    
    F --> F1[操作性<br/>学習のしやすさ<br/>エラーメッセージ]
    
    G --> G1[環境への適応性<br/>置き換え容易性]
    
    style A fill:#fff3e0,stroke:#ef6c00,stroke-width:3px
    style B fill:#e1f5fe,stroke:#0277bd
    style C fill:#f3e5f5,stroke:#7b1fa2
    style D fill:#ffcdd2,stroke:#c62828
    style E fill:#c8e6c9,stroke:#2e7d32
    style F fill:#fff9c4,stroke:#f57f17
    style G fill:#e0f2f1,stroke:#00695c
```

**①性能・効率性の要件：**

| 要件ID | 項目 | 要件 | 測定方法 |
|-------|------|------|---------|
| NFR-001 | レスポンスタイム | 検索結果表示：3秒以内（95%パーセンタイル） | システムログで測定 |
| NFR-002 | スループット | 同時100ユーザーのアクセスに対応 | 負荷テストで確認 |
| NFR-003 | データ量 | 顧客データ100万件を処理可能 | 性能テストで確認 |
| NFR-004 | バッチ処理時間 | 日次バッチ：1時間以内で完了 | ジョブ実行ログ |

**❌ 悪い書き方：**

```
NFR-001: システムは高速に動作する
→ 「高速」の定義が不明

NFR-002: 多くのユーザーが使える
→ 「多く」が何人か不明
```

**✅ 良い書き方：**

```
NFR-001: 検索処理は95%パーセンタイルで3秒以内に完了する
→ 測定可能で明確

NFR-002: 同時アクセス100ユーザーまで対応し、
         レスポンスタイムの劣化は10%以内とする
→ 具体的な数値で明確
```

**②可用性・信頼性の要件：**

```mermaid
graph LR
    A[可用性の指標] --> B[稼働率<br/>Availability]
    A --> C[MTBF<br/>平均故障間隔]
    A --> D[MTTR<br/>平均復旧時間]
    A --> E[RTO<br/>目標復旧時間]
    A --> F[RPO<br/>目標復旧時点]
    
    B --> B1[99.9% = <br/>年間8.7時間のダウン]
    C --> C1[故障せずに<br/>動く時間]
    D --> D1[故障から<br/>復旧までの時間]
    E --> E1[何時間以内に<br/>復旧するか]
    F --> F1[何時間前の<br/>データまで戻すか]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:2px
    style B fill:#c8e6c9,stroke:#2e7d32
    style E fill:#fff9c4,stroke:#f57f17
    style F fill:#ffcdd2,stroke:#c62828
```

| 要件ID | 項目 | 要件 | 基準値 |
|-------|------|------|--------|
| NFR-011 | 稼働率 | 月間稼働率99.9%以上 | 43分/月のダウンまで許容 |
| NFR-012 | RTO（目標復旧時間） | 障害発生から1時間以内に復旧 | 1時間 |
| NFR-013 | RPO（目標復旧時点） | データ損失は1時間以内 | 1時間前まで |
| NFR-014 | バックアップ | 毎日自動バックアップ、7日間保持 | 日次 |
| NFR-015 | 冗長化 | DBはマスター・スレーブ構成 | Active-Standby |

**稼働率の計算：**

```
稼働率 = (稼働時間 ÷ 全体時間) × 100%

例：月間（30日 = 43,200分）
99.9%  = 43,200分 - 43分 = ダウン許容43分/月
99.0%  = 43,200分 - 432分 = ダウン許容7.2時間/月
95.0%  = 43,200分 - 2,160分 = ダウン許容36時間/月
```

**可用性のレベル：**

| 稼働率 | 年間ダウンタイム | 用途例 |
|--------|----------------|--------|
| 99.999% (Five 9) | 5.26分 | 金融システム、医療システム |
| 99.99% (Four 9) | 52.6分 | ECサイト、決済システム |
| 99.9% (Three 9) | 8.76時間 | 一般的な業務システム |
| 99.0% | 3.65日 | 社内ツール |
| 95.0% | 18.25日 | 開発環境 |

**③セキュリティの要件：**

```mermaid
graph TD
    A[セキュリティ要件] --> B[認証<br/>Authentication]
    A --> C[認可<br/>Authorization]
    A --> D[暗号化<br/>Encryption]
    A --> E[監査<br/>Audit]
    A --> F[脆弱性対策<br/>Vulnerability]
    
    B --> B1[誰かを確認する<br/>例: パスワード、2FA]
    C --> C1[何ができるか制御<br/>例: ロールベースアクセス制御]
    D --> D1[データを保護<br/>例: SSL/TLS、データベース暗号化]
    E --> E1[操作を記録<br/>例: アクセスログ、変更履歴]
    F --> F1[攻撃を防ぐ<br/>例: SQLインジェクション対策]
    
    style A fill:#ffcdd2,stroke:#c62828,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#fff9c4,stroke:#f57f17
    style D fill:#c8e6c9,stroke:#2e7d32
    style E fill:#e1f5fe,stroke:#0277bd
    style F fill:#f3e5f5,stroke:#7b1fa2
```

| 要件ID | 項目 | 要件 | 基準 |
|-------|------|------|------|
| NFR-021 | 認証 | 2要素認証（ID/パスワード + ワンタイムパスワード） | 必須 |
| NFR-022 | パスワードポリシー | 8文字以上、英数字記号混在、90日で期限切れ | 必須 |
| NFR-023 | 認可 | ロールベースアクセス制御（RBAC） | 必須 |
| NFR-024 | 通信暗号化 | 全通信をTLS 1.3で暗号化 | 必須 |
| NFR-025 | データ暗号化 | 個人情報はAES-256で暗号化して保存 | 必須 |
| NFR-026 | セッション管理 | セッションタイムアウト：30分 | 必須 |
| NFR-027 | 監査ログ | 全操作をログに記録、5年間保存 | 必須 |
| NFR-028 | 脆弱性対策 | OWASP Top 10の全項目に対策実施 | 必須 |
| NFR-029 | 侵入検知 | 不正アクセス試行を検知しアラート | 必須 |

**OWASP Top 10（2021）とは：**

Web アプリケーションの代表的な脆弱性トップ10です。セキュリティの専門家でなくても、これらの脅威を理解することが重要です。

| No. | 脆弱性 | 初心者向け説明 | 対策例 |
|-----|--------|--------------|--------|
| 1 | アクセス制御の不備 | 「他人の情報が見えてしまう」問題<br/>例: 会員専用ページにログインせず閲覧可能 | ロールベースアクセス制御 |
| 2 | 暗号化の失敗 | 「盗聴される」問題<br/>例: パスワードが平文で送信される | TLS（HTTPS）、AES暗号化 |
| 3 | インジェクション | 「悪意のあるコードを注入される」問題<br/>例: 入力欄から不正なSQL文を実行される | プリペアドステートメント |
| 4 | 安全でない設計 | 「設計段階でセキュリティを考慮していない」問題<br/>例: パスワードリセット機能に認証がない | 脅威モデリング、セキュア設計 |
| 5 | セキュリティ設定ミス | 「初期設定のまま使っている」問題<br/>例: 管理画面のIDが"admin"、パスワードが"admin" | 設定のハードニング、定期レビュー |
| 6 | 脆弱なコンポーネント | 「古いライブラリを使っている」問題<br/>例: 既知の脆弱性があるバージョンのまま | 定期的なアップデート、脆弱性スキャン |
| 7 | 認証の失敗 | 「なりすまされる」問題<br/>例: パスワードが"123456"でもOK | 2要素認証、パスワードポリシー |
| 8 | データ完全性の失敗 | 「データを改ざんされる」問題<br/>例: 価格情報を書き換えられる | 署名、検証、改ざん検知 |
| 9 | ログ・監視不足 | 「攻撃に気づけない」問題<br/>例: 不正アクセスされても記録がない | 集中ログ管理、リアルタイム監視 |
| 10 | サーバーサイドリクエストフォージェリ | 「内部システムを攻撃される」問題<br/>例: 外部から内部APIを不正に呼び出される | URL検証、ホワイトリスト方式 |

**重要なポイント:**

- これらの脆弱性は**実際に悪用された事例が多数**存在します
- 対策を怠ると、**情報漏洩や金銭的損害**につながります
- 開発初期から**セキュリティを組み込む**ことが重要です

**④保守性の要件：**

| 要件ID | 項目 | 要件 |
|-------|------|------|
| NFR-031 | コーディング規約 | Google Java Style Guide に準拠 |
| NFR-032 | コメント | 公開メソッドには必ずJavadocコメント |
| NFR-033 | 単体テスト | カバレッジ80%以上 |
| NFR-034 | ドキュメント | 設計書、運用手順書を日本語で作成 |
| NFR-035 | ログ出力 | 全エラーはスタックトレース付きでログ出力 |
| NFR-036 | 設定の外部化 | 環境依存の設定は設定ファイルで管理 |

**⑤使用性（ユーザビリティ）の要件：**

| 要件ID | 項目 | 要件 |
|-------|------|------|
| NFR-041 | 学習時間 | 新人が1日で基本操作を習得できる |
| NFR-042 | 操作性 | 主要な操作は3クリック以内で完了 |
| NFR-043 | エラーメッセージ | エラー時は原因と対処方法を明示 |
| NFR-044 | ヘルプ | 全画面にヘルプボタンを配置 |
| NFR-045 | アクセシビリティ | WCAG 2.1 レベルAA準拠 |
| NFR-046 | 多言語対応 | 日本語・英語に対応 |

**⑥移植性の要件：**

| 要件ID | 項目 | 要件 |
|-------|------|------|
| NFR-051 | ブラウザ対応 | Chrome、Edge、Safari、Firefox最新版 |
| NFR-052 | OS対応 | Windows 10以降、macOS 10.15以降 |
| NFR-053 | 画面解像度 | 1920×1080以上を推奨、1366×768でも表示可能 |
| NFR-054 | モバイル | iOS 14以降、Android 10以降（オプション） |

#### ④受入基準の定義（Gherkin）

**Gherkin（ガーキン）**は、**人間にも機械にも読める**形式で受入基準を書く方法です。

**Gherkinの基本構造：**

**Gherkinの基本キーワード:**

- **前提（Given）**: テストの前提条件
- **もし（When）**: ユーザーの操作
- **ならば（Then）**: 期待される結果
- **かつ（And）**: 条件の追加
- **しかし（But）**: 否定条件

**構造:**

```gherkin
機能: [機能名]
  [機能の説明]

  シナリオ: [シナリオ名]
    前提 [前提条件]
    もし [操作]
    ならば [期待結果]
```

**具体例：顧客検索機能**

```gherkin
機能: 顧客検索
  カスタマーサポート担当者が顧客情報を素早く検索できる

  背景:
    前提 以下の顧客が登録されている
      | 顧客ID | 顧客名 | 電話番号 | メールアドレス |
      | C001 | 山田太郎 | 090-1234-5678 | yamada@example.com |
      | C002 | 鈴木花子 | 080-9876-5432 | suzuki@example.com |
      | C003 | 田中一郎 | 070-1111-2222 | tanaka@example.com |

  シナリオ: 顧客名で検索（正常系）
    前提 ユーザー「サポート太郎」がログインしている
    もし 顧客名に「山田」を入力して検索ボタンを押す
    ならば 検索結果に以下が表示される
      | 顧客ID | 顧客名 |
      | C001 | 山田太郎 |
    かつ 検索結果の表示時間は3秒以内である
    かつ 操作ログに「検索実行: 山田」が記録される

  シナリオ: 電話番号で検索（正常系）
    前提 ユーザー「サポート太郎」がログインしている
    もし 電話番号に「090-1234-5678」を入力して検索ボタンを押す
    ならば 検索結果に「山田太郎」が表示される

  シナリオ: 部分一致検索（正常系）
    前提 ユーザー「サポート太郎」がログインしている
    もし 顧客名に「田」を入力して検索ボタンを押す
    ならば 検索結果に以下が表示される
      | 顧客ID | 顧客名 |
      | C001 | 山田太郎 |
      | C003 | 田中一郎 |
    かつ 結果は顧客名の50音順でソートされている

  シナリオ: 検索条件なし（異常系）
    前提 ユーザー「サポート太郎」がログインしている
    もし 何も入力せずに検索ボタンを押す
    ならば エラーメッセージ「検索条件を入力してください」が表示される
    かつ 検索は実行されない

  シナリオ: 該当なし（準正常系）
    前提 ユーザー「サポート太郎」がログインしている
    もし 顧客名に「存在しない名前」を入力して検索ボタンを押す
    ならば メッセージ「該当する顧客が見つかりませんでした」が表示される
    かつ 検索結果は0件である

  シナリオ: 検索結果が100件を超える場合（境界値）
    前提 検索条件に該当する顧客が150件存在する
    もし 該当する条件で検索する
    ならば 最初の100件が表示される
    かつ 警告メッセージ「検索結果が100件を超えました」が表示される
    かつ 「条件を絞り込んでください」というガイドが表示される

  シナリオ: 権限のないユーザー（セキュリティ）
    前提 権限のないユーザー「外部ユーザー」がログインしている
    もし 顧客名に「山田」を入力して検索ボタンを押す
    ならば エラーメッセージ「この機能を使用する権限がありません」が表示される
    かつ 検索は実行されない
    かつ セキュリティログに「権限不足での検索試行」が記録される
```

**Gherkinのメリット：**

```mermaid
graph TD
    A[Gherkin] --> B[人間が読める]
    A --> C[機械が実行できる]
    A --> D[合否判定が明確]
    
    B --> B1[お客様も理解できる]
    B --> B2[開発者も理解できる]
    B --> B3[テスターも理解できる]
    
    C --> C1[自動テストに変換可能]
    C --> C2[CucumberやBehaveで実行]
    
    D --> D1[「できた」「できない」が<br/>明確に判定できる]
    
    style A fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
    style B fill:#e1f5fe,stroke:#0277bd
    style C fill:#fff9c4,stroke:#f57f17
    style D fill:#f3e5f5,stroke:#7b1fa2
```

### 📄 作成するドキュメント：SRS（要求仕様書）

**SRS = Software Requirements Specification**

これは要件定義フェーズの**最重要ドキュメント**です。

**SRSの標準構成（IEEE 29148準拠）：**

```markdown
# ソフトウェア要求仕様書（SRS）

**プロジェクト名：** 顧客対応統合システム  
**バージョン：** 1.0  
**作成日：** 2026年2月1日  
**承認日：** 2026年2月28日  
**作成者：** SE 佐藤太郎  
**承認者：** PM 田中花子

---

## 1. 目的と背景

### 1.1 システム開発の目的
本システムは、顧客対応業務の効率化と顧客満足度向上を目的とする。
具体的には、分散した顧客情報を統合管理し、対応時間を現状の2時間から
1時間以内に短縮することを目指す。

### 1.2 ビジネス上の背景
- 現状：年間10万件の顧客問い合わせに対応
- 課題：
  - 顧客情報が3システムに分散（検索に時間）
  - 対応品質のばらつき（ナレッジの属人化）
  - 顧客満足度が競合より低い（60% vs 70%）
- 目標：
  - 対応時間：2時間 → 1時間（50%削減）
  - 顧客満足度：60% → 85%
  - 対応コスト：年間1,000万円削減

### 1.3 スコープ（範囲）

**含むこと（In-Scope）：**
- ✅ 3システムの顧客情報統合
- ✅ 統合検索機能
- ✅ 対応履歴の一元管理
- ✅ レポート出力
- ✅ 基本的なAI機能（回答候補提示）

**含まないこと（Out-of-Scope）：**
- ❌ 既存3システムの改修
- ❌ コールセンター電話システムとの連携
- ❌ 音声認識機能
- ❌ チャットボット（次期検討）
- ❌ 多言語対応（日本語のみ）

## 2. 用語集

| 用語 | 定義 |
|-----|------|
| カスタマーサポート | 顧客からの問い合わせに対応する部門 |
| 対応履歴 | 顧客との過去のやりとりの記録 |
| 統合検索 | 複数システムを横断して一度に検索する機能 |
| SLA | Service Level Agreement（サービスレベル合意） |
| RPO | Recovery Point Objective（目標復旧時点） |
| RTO | Recovery Time Objective（目標復旧時間） |
| RBAC | Role-Based Access Control（ロールベースアクセス制御） |

## 3. 利害関係者（ステークホルダー）

| 役割 | 氏名 | 関心事 | 責任（RACI） |
|-----|------|--------|-------------|
| プロジェクトオーナー | 山田部長 | 投資対効果、戦略目標達成 | A（説明責任） |
| プロジェクトマネージャー | 田中 | QCD管理、リスク管理 | A（説明責任） |
| カスタマーサポート部長 | 鈴木 | 業務効率化、使いやすさ | C（相談） |
| カスタマーサポート担当 | 5名 | 日常業務での使いやすさ | C（相談）、I（報告） |
| システムエンジニア | 佐藤 | 技術的実現可能性、保守性 | R（実行責任） |
| 開発チーム | 3名 | 実装のしやすさ、品質 | R（実行責任） |
| インフラチーム | 渡辺 | 安定稼働、セキュリティ | R（実行責任） |
| 情報セキュリティ部 | 伊藤 | セキュリティ、コンプライアンス | C（相談）、I（報告） |

## 4. 機能要件

### 4.1 認証・権限管理

#### FR-001: ログイン機能
**優先度：** Must  
**概要：** ユーザーはID/パスワードとワンタイムパスワードでログインできる

**詳細：**
- 既存のActive Directoryアカウントでログイン
- 2要素認証（ワンタイムパスワード）必須
- ログイン失敗3回でアカウントロック（30分間）
- セッションタイムアウト：30分

**受入基準：**
```gherkin
シナリオ: 正常なログイン
  前提 有効なユーザー「sato@example.com」が存在する
  もし ユーザーIDに「sato@example.com」を入力
  かつ パスワードに正しいパスワードを入力
  かつ ワンタイムパスワードに正しいコードを入力
  かつ ログインボタンを押す
  ならば ホーム画面が表示される
  かつ セッションが確立される

シナリオ: パスワード誤り
  もし パスワードに誤ったパスワードを入力
  ならば エラーメッセージ「ユーザーIDまたはパスワードが正しくありません」が表示される
  かつ ログイン試行回数がカウントされる
  かつ 3回失敗するとアカウントがロックされる
```

**画面イメージ：** [添付: login_screen.png]

**テストケースID：** TC-001 〜 TC-005

#### FR-002: ロールベースアクセス制御

**優先度：** Must  
**概要：** ユーザーの役割に応じて機能へのアクセスを制御する

**ロール定義：**

| ロール | 権限 |
|-------|------|
| 管理者 | 全機能へのアクセス、ユーザー管理 |
| サポート担当（リーダー） | 全検索、履歴編集、レポート出力 |
| サポート担当（一般） | 基本検索、履歴参照・登録 |
| 閲覧のみ | 検索と参照のみ、編集不可 |

### 4.2 顧客管理

#### FR-011: 顧客検索機能

**優先度：** Must  
**概要：** 顧客名、電話番号、メールアドレスで顧客を検索できる

[前述のGherkin例を参照]

**画面イメージ：** [添付: customer_search.png]

**テストケースID：** TC-011 〜 TC-020

#### FR-012: 顧客詳細表示

**優先度：** Must  
**概要：** 選択した顧客の詳細情報を表示する

**表示項目：**

- 基本情報：顧客ID、氏名、電話、メール、住所
- 契約情報：契約サービス、契約日、契約金額
- 購買履歴：過去6ヶ月分の購買履歴（最新5件）
- 対応履歴：過去1年分の対応履歴（最新10件）
- 統計情報：問い合わせ回数、平均対応時間

**パフォーマンス要件：**

- データ取得：2秒以内
- 3システムからのデータ統合

### 4.3 対応履歴管理

#### FR-021: 対応履歴登録

**優先度：** Must  
**概要：** 顧客対応の内容を記録できる

**登録項目：**

- 顧客ID（自動）
- 対応日時（自動）
- 対応者（自動）
- 問い合わせ内容（必須、最大2000文字）
- 対応内容（必須、最大2000文字）
- カテゴリ（選択式：技術的質問、請求、クレーム、その他）
- 優先度（高、中、低）
- ステータス（対応中、完了、保留、エスカレーション）
- 次回フォローアップ日（任意）

**受入基準：**

```gherkin
シナリオ: 対応履歴の正常登録
  前提 顧客「山田太郎」の詳細画面を表示している
  もし 問い合わせ内容に「商品Aの使い方について質問」を入力
  かつ 対応内容に「マニュアルの3ページを案内」を入力
  かつ カテゴリで「技術的質問」を選択
  かつ 登録ボタンを押す
  ならば 「登録しました」というメッセージが表示される
  かつ 対応履歴一覧に新しい履歴が追加される
  かつ 対応日時・対応者が自動で記録される
```

#### FR-022: AI回答候補提示

**優先度：** Should  
**概要：** 過去の対応履歴から類似の回答候補をAIが提示する

**詳細：**

- 問い合わせ内容を入力すると、リアルタイムでAIが類似ケースを検索
- 上位3件の過去対応を表示
- 対応内容をワンクリックでコピー可能
- AI信頼度スコアを表示（80%以上を推奨）

**技術：**

- OpenAI API（GPT-4）を使用
- ベクトル検索（類似度計算）

### 4.4 レポート機能

#### FR-031: 月次レポート出力

**優先度：** Should  
**概要：** 月次の対応実績をPDFレポートとして出力できる

**レポート内容：**

- サマリー
  - 総問い合わせ件数
  - 平均対応時間
  - 顧客満足度
  - 担当者別対応件数
- カテゴリ別内訳（円グラフ）
- 時間帯別件数（棒グラフ）
- 対応時間の推移（折れ線グラフ）
- トップ10 FAQ

**出力形式：** PDF（A4縦）

## 5. 非機能要件

### 5.1 性能要件

| 要件ID | 項目 | 基準値 | 測定方法 |
|-------|------|--------|---------|
| NFR-001 | 検索レスポンス | 3秒以内（95%ile） | APM監視 |
| NFR-002 | 同時アクセス | 100ユーザー | 負荷テスト |
| NFR-003 | データ量 | 顧客100万件対応 | 性能テスト |
| NFR-004 | 詳細表示 | 2秒以内 | APM監視 |
| NFR-005 | レポート生成 | 30秒以内 | 処理時間測定 |

### 5.2 可用性要件

| 要件ID | 項目 | 基準値 |
|-------|------|--------|
| NFR-011 | 月間稼働率 | 99.9%以上 |
| NFR-012 | RTO | 1時間以内 |
| NFR-013 | RPO | 1時間以内 |
| NFR-014 | バックアップ | 毎日実施、7日保持 |
| NFR-015 | 冗長化 | DB マスター/スレーブ構成 |

### 5.3 セキュリティ要件

| 要件ID | 項目 | 基準 |
|-------|------|------|
| NFR-021 | 認証 | 2要素認証必須 |
| NFR-022 | 認可 | RBAC実装 |
| NFR-023 | 通信暗号化 | TLS 1.3 |
| NFR-024 | データ暗号化 | AES-256 |
| NFR-025 | 監査ログ | 全操作記録、5年保存 |
| NFR-026 | 脆弱性対策 | OWASP Top 10対応 |
| NFR-027 | セッション | 30分でタイムアウト |

[詳細は前述の表を参照]

## 6. 外部インタフェース

### 6.1 既存システムとの連携

| システム | 連携方式 | データ | 頻度 |
|---------|---------|--------|------|
| System A（顧客管理） | REST API | 顧客基本情報 | リアルタイム |
| System B（問い合わせ管理） | REST API | 対応履歴 | リアルタイム |
| System C（会計システム） | REST API | 購買履歴 | 日次バッチ |
| Active Directory | LDAP | 認証情報 | リアルタイム |

### 6.2 API仕様

#### 顧客検索API

```
GET /api/v1/customers/search
```

**リクエストパラメータ：**

```json
{
  "customerName": "山田",     // 顧客名（部分一致）
  "phone": "090-1234-5678",  // 電話番号（完全一致）
  "email": "yamada@example.com", // メールアドレス（完全一致）
  "limit": 100,              // 取得件数上限（デフォルト100）
  "offset": 0                // オフセット（ページング用）
}
```

**レスポンス（成功時）：**

```json
{
  "status": "success",
  "data": {
    "customers": [
      {
        "customerId": "C001",
        "customerName": "山田太郎",
        "phone": "090-1234-5678",
        "email": "yamada@example.com"
      }
    ],
    "total": 1,
    "hasMore": false
  },
  "responseTime": 1.234
}
```

**レスポンス（エラー時）：**

```json
{
  "status": "error",
  "error": {
    "code": "E0001",
    "message": "検索条件を指定してください"
  }
}
```

## 7. データ要件

### 7.1 データモデル

#### 顧客（Customer）

| 項目名 | 物理名 | 型 | 必須 | 説明 |
|-------|--------|----|----|------|
| 顧客ID | customer_id | VARCHAR(10) | ✓ | 主キー |
| 顧客名 | customer_name | VARCHAR(100) | ✓ | |
| 電話番号 | phone | VARCHAR(15) | | ハイフンあり形式 |
| メールアドレス | email | VARCHAR(255) | | |
| 住所 | address | VARCHAR(500) | | |
| 登録日時 | created_at | TIMESTAMP | ✓ | |
| 更新日時 | updated_at | TIMESTAMP | ✓ | |

#### 対応履歴（InquiryHistory）

| 項目名 | 物理名 | 型 | 必須 | 説明 |
|-------|--------|----|----|------|
| 履歴ID | history_id | BIGINT | ✓ | 主キー、自動採番 |
| 顧客ID | customer_id | VARCHAR(10) | ✓ | 外部キー |
| 対応日時 | inquiry_date | TIMESTAMP | ✓ | |
| 対応者ID | staff_id | VARCHAR(20) | ✓ | |
| 問い合わせ内容 | inquiry_content | TEXT | ✓ | |
| 対応内容 | response_content | TEXT | ✓ | |
| カテゴリ | category | VARCHAR(50) | ✓ | |
| 優先度 | priority | VARCHAR(10) | ✓ | 高/中/低 |
| ステータス | status | VARCHAR(20) | ✓ | |

### 7.2 データ保持期間

| データ種別 | 保持期間 | 理由 |
|-----------|---------|------|
| 顧客情報 | 無期限 | ビジネス継続に必須 |
| 対応履歴 | 5年 | 監査要件 |
| 操作ログ | 5年 | 監査要件 |
| バックアップ | 7日 | 短期復旧用 |
| アーカイブ | 10年 | 法令要件 |

### 7.3 個人情報の取り扱い

| 項目 | 対応 |
|-----|------|
| 個人情報保護法 | 準拠必須 |
| データセンター | 日本国内 |
| 暗号化 | AES-256 |
| アクセス制御 | ロールベース |
| 削除要求への対応 | 30日以内に完全削除 |
| 監査 | 年1回実施 |

## 8. 制約条件

### 8.1 技術的制約

| 項目 | 制約 | 理由 |
|-----|------|------|
| クラウド | AWS使用必須 | 社内標準 |
| データベース | PostgreSQL | 運用実績 |
| プログラミング言語 | Java 17 | 社内標準 |
| フレームワーク | Spring Boot 3.x | |
| フロントエンド | React 18 | |
| 認証 | Active Directory連携 | シングルサインオン |

### 8.2 運用制約

| 項目 | 制約 |
|-----|------|
| 保守時間 | 毎週日曜 2:00-4:00 |
| バックアップ時間 | 毎日 1:00-2:00 |
| メンテナンス | 月1回、第4日曜日 |
| サポート時間 | 平日 9:00-18:00 |

## 9. 受入条件（全体）

プロジェクトの成功基準を以下に定義します。

### 9.1 機能要件の完了基準

- ✅ Must要件がすべて実装されている
- ✅ Should要件の80%以上が実装されている
- ✅ 全機能の受入テストに合格している

### 9.2 品質基準

| 基準 | 目標値 | 測定方法 |
|-----|--------|---------|
| 重大バグ | 0件 | バグ管理表 |
| 軽微バグ | 5件以下 | バグ管理表 |
| コードカバレッジ | 80%以上 | Jacoco |
| 静的解析 | クリティカルエラー0 | SonarQube |
| 性能テスト | 全項目クリア | JMeter |
| セキュリティ診断 | 脆弱性なし | 外部診断 |

### 9.3 非機能要件の完了基準

- ✅ 性能要件をすべて満たしている
- ✅ セキュリティ診断に合格している
- ✅ 可用性テストに合格している
- ✅ 負荷テストに合格している

### 9.4 ドキュメントの完了基準

- ✅ ユーザーマニュアルが完成している
- ✅ 運用手順書が完成している
- ✅ システム保守マニュアルが完成している
- ✅ API仕様書が完成している

## 10. トレーサビリティ（RTM参照）

要件のトレーサビリティは別紙「RTM（要件トレーサビリティマトリクス）」で管理します。

[RTM.xlsx へのリンク]

## 11. 変更管理

### 11.1 変更管理プロセス

```mermaid
graph TD
    A[変更要求] --> B{影響度評価}
    B -->|大| C[ステアリング委員会]
    B -->|中| D[PM判断]
    B -->|小| E[SE判断]
    
    C --> F{承認}
    D --> F
    E --> F
    
    F -->|承認| G[SRS更新]
    F -->|却下| H[要求者に通知]
    
    G --> I[関係者に通知]
    G --> J[RTM更新]
    G --> K[スケジュール調整]
    
    style A fill:#fff3e0,stroke:#ef6c00
    style F fill:#ffcdd2,stroke:#c62828
    style G fill:#c8e6c9,stroke:#2e7d32
```

### 11.2 変更の影響度

| 影響度 | 定義 | 承認者 | 承認期間 |
|-------|------|--------|---------|
| **大** | 納期・コストに大きく影響<br/>アーキテクチャ変更 | ステアリング委員会 | 1週間 |
| **中** | 一部機能の変更<br/>工数5人日以上 | PM | 3日 |
| **小** | 軽微な修正<br/>工数5人日未満 | SE | 即日 |

## 12. 変更履歴

| バージョン | 日付 | 変更者 | 変更内容 | 承認者 |
|-----------|------|--------|---------|--------|
| 0.1 | 2026/01/15 | 佐藤 | 初稿作成 | - |
| 0.2 | 2026/01/25 | 佐藤 | レビュー指摘事項反映 | - |
| 0.5 | 2026/02/10 | 佐藤 | お客様フィードバック反映 | - |
| 1.0 | 2026/02/28 | 佐藤 | 承認版（確定） | 田中PM |
| 1.1 | 2026/03/10 | 佐藤 | AI機能の詳細追加 | 田中PM |

---
以上

```

### 🎓 このフェーズのまとめ

**✅ やること：**
1. ステークホルダー特定（RACI図）
2. ヒアリング（5W1H、なぜを5回）
3. 要件整理（機能要件 + 非機能要件）
4. 優先順位付け（MoSCoW法）
5. 受入基準定義（Gherkin）

**📄 作るドキュメント：**
- **SRS（要求仕様書）** ← 最重要！

**⚠️ よくある失敗：**
- ヒアリングが浅い（表面的な要望だけ聞く）
- 非機能要件を軽視（「速く」「安全に」だけで終わる）
- 受入基準が曖昧（合否判定できない）
- ステークホルダーの合意を取らない

**💡 成功のコツ：**
- **とにかくヒアリングに時間をかける**
- **「なぜ」を繰り返し、本質的なニーズを引き出す**
- **数字で語る**（「速く」ではなく「3秒以内」）
- **Gherkinで受入基準を書く**（合否が明確になる）
- **全ステークホルダーの承認を得る**（後で「聞いてない」を防ぐ）

**📊 工数の目安：**
- 小規模（〜3ヶ月）：要件定義に2-4週間
- 中規模（3〜6ヶ月）：要件定義に4-8週間
- 大規模（6ヶ月〜）：要件定義に8-12週間

**💰 コストの考え方：**
- 要件定義に十分な時間をかけることは**投資**
- ここで1週間余分にかけることで、後で1ヶ月の手戻りを防げる
- **「急がば回れ」が最も当てはまるフェーズ**

---

### 🔲 要件定義フェーズのチェックリスト

**完了基準として以下を確認してください:**

- [ ] **ステークホルダーの特定**
  - [ ] 全ての関係者を洗い出した
  - [ ] RACI表を作成した

- [ ] **ヒアリングの実施**
  - [ ] 5W1Hで要望を深掘りした
  - [ ] 議事録を作成・共有した

- [ ] **機能要件の整理**
  - [ ] 全ての機能要件を洗い出した
  - [ ] MoSCoW法で優先順位付けした
  - [ ] 各要件に一意のIDを付与した
  - [ ] 曖昧な表現を排除した

- [ ] **非機能要件の整理**
  - [ ] 性能要件を数値化した
  - [ ] 可用性・信頼性を定義した
  - [ ] セキュリティ要件を明確化した
  - [ ] 保守性・拡張性を考慮した

- [ ] **受入基準の作成**
  - [ ] Gherkin記法で受入基準を書いた
  - [ ] 正常系・異常系・境界値を網羅した

- [ ] **SRSの作成**
  - [ ] 要求仕様書（SRS）を作成した
  - [ ] 全ての要件をSRSに記載した

- [ ] **承認の取得**
  - [ ] 全ステークホルダーからの承認を得た
  - [ ] 承認の証跡を残した

- [ ] **成果物の保管**
  - [ ] 全ドキュメントをバージョン管理した
  - [ ] チーム全員がアクセス可能な場所に保管した


## 3.3 ③基本設計フェーズ

### 📌 このフェーズの目的

**「どう作るか（HOW）の大枠」を決める**

家を建てることで例えると：「建物の構造（木造 or 鉄骨造）、配置、設備の配線ルートなどを決める段階」

### 🎯 このフェーズで行うこと

```mermaid
graph TD
    A[基本設計フェーズ] --> B[①システム全体構成]
    A --> C[②アーキテクチャ設計]
    A --> D[③インフラ設計]
    A --> E[④データベース論理設計]
    A --> F[⑤画面・帳票設計]
    A --> G[⑥外部連携設計]
    A --> H[⑦セキュリティ設計]
    
    B --> B1[システム構成図]
    B --> B2[ネットワーク構成]
    
    C --> C1[アーキテクチャパターン選定]
    C --> C2[レイヤー構造]
    C --> C3[コンポーネント分割]
    
    D --> D1[サーバー構成]
    D --> D2[クラウドリソース]
    D --> D3[冗長化設計]
    
    E --> E1[ER図]
    E --> E2[テーブル定義]
    E --> E3[正規化]
    
    F --> F1[画面遷移図]
    F --> F2[ワイヤーフレーム]
    F --> F3[帳票レイアウト]
    
    G --> G1[API設計]
    G --> G2[連携方式]
    G --> G3[データフォーマット]
    
    H --> H1[認証認可方式]
    H --> H2[暗号化方式]
    H --> H3[監査ログ]
    
    style A fill:#fff9c4,stroke:#f57f17,stroke-width:3px
    style B fill:#e1f5fe,stroke:#0277bd
    style C fill:#f3e5f5,stroke:#7b1fa2
    style D fill:#c8e6c9,stroke:#2e7d32
    style E fill:#ffcdd2,stroke:#c62828
    style F fill:#fff3e0,stroke:#ef6c00
    style G fill:#e0f2f1,stroke:#00695c
    style H fill:#fce4ec,stroke:#c2185b
```

### 📝 具体的な作業内容

#### ①システム全体構成の設計

**初心者向け: 3層アーキテクチャの基本**

まず、シンプルな構成を理解しましょう。ほとんどのシステムは以下の3つの層で構成されます:

```mermaid
graph TD
    User[👤 ユーザー] -->|インターネット経由| Web[プレゼンテーション層<br/>Webブラウザ/アプリ画面]
    Web -->|リクエスト| App[アプリケーション層<br/>ビジネスロジック処理]
    App -->|データ取得・保存| DB[データ層<br/>データベース]
    
    style User fill:#e1f5fe,stroke:#0277bd
    style Web fill:#fff9c4,stroke:#f57f17
    style App fill:#c8e6c9,stroke:#2e7d32
    style DB fill:#ffcdd2,stroke:#c62828
```

**各層の役割:**

- **プレゼンテーション層**: ユーザーが見る画面（HTMLページ、アプリUI）
- **アプリケーション層**: 計算や処理を行う部分（APIサーバー、業務ロジック）
- **データ層**: データを保存・管理する部分（データベース）

---

**実務者向け: AWS環境の詳細構成**

実際の本番環境では、冗長化やセキュリティを考慮した複雑な構成になります:

**システム構成図の例：**

```mermaid
graph TD
    subgraph Internet
        User[👤 ユーザー<br/>100名]
    end
    
    subgraph "AWS Cloud（東京リージョン）"
        subgraph "Public Subnet"
            ALB[Application<br/>Load Balancer]
        end
        
        subgraph "Private Subnet - AZ-A"
            Web1[Web/AP Server<br/>EC2 t3.medium]
            Cache1[Redis<br/>ElastiCache]
        end
        
        subgraph "Private Subnet - AZ-C"
            Web2[Web/AP Server<br/>EC2 t3.medium]
            Cache2[Redis<br/>ElastiCache]
        end
        
        subgraph "Database Subnet"
            RDS_M[PostgreSQL<br/>RDS Master<br/>db.t3.large]
            RDS_S[PostgreSQL<br/>RDS Standby<br/>db.t3.large]
        end
        
        subgraph "Storage"
            S3[S3 Bucket<br/>ファイル保存]
        end
    end
    
    subgraph "On-Premises"
        AD[Active Directory<br/>認証サーバー]
        SysA[System A<br/>顧客管理]
        SysB[System B<br/>問い合わせ管理]
        SysC[System C<br/>会計システム]
    end
    
    User -->|HTTPS| ALB
    ALB --> Web1
    ALB --> Web2
    Web1 --> Cache1
    Web2 --> Cache2
    Web1 --> RDS_M
    Web2 --> RDS_M
    RDS_M -->|レプリケーション| RDS_S
    Web1 --> S3
    Web2 --> S3
    Web1 -->|Direct Connect| AD
    Web1 -->|REST API| SysA
    Web1 -->|REST API| SysB
    Web1 -->|REST API| SysC
    
    style User fill:#e1f5fe,stroke:#0277bd
    style ALB fill:#fff9c4,stroke:#f57f17
    style Web1 fill:#c8e6c9,stroke:#2e7d32
    style Web2 fill:#c8e6c9,stroke:#2e7d32
    style RDS_M fill:#ffcdd2,stroke:#c62828
    style RDS_S fill:#ffcdd2,stroke:#c62828
```

**システム構成の設計ポイント：**

| 項目 | 設計内容 | 理由 |
|-----|---------|------|
| **冗長化** | Web/APサーバーを2台構成 | 可用性99.9%を実現 |
| **ロードバランサー** | ALBを使用 | SSL終端、ヘルスチェック |
| **データベース** | RDS Multi-AZ | 自動フェイルオーバー |
| **キャッシュ** | Redis使用 | レスポンス時間短縮 |
| **可用性ゾーン** | 2つのAZに分散配置 | AZ障害時も稼働継続 |
| **バックアップ** | RDS自動バックアップ | RPO 1時間を実現 |

#### ②アーキテクチャ設計（C4モデル）

**C4モデル**は、システムを4つのレベルで表現する手法です。

**Level 1: Context図（コンテキスト図）**

システムと外部の関係を示します。

```mermaid
graph TD
    User[👤 カスタマーサポート担当]
    Admin[👤 システム管理者]
    
    System[📦 顧客対応統合システム]
    
    AD[🔐 Active Directory<br/>認証システム]
    SysA[📊 System A<br/>顧客管理システム]
    SysB[📊 System B<br/>問い合わせ管理システム]
    SysC[📊 System C<br/>会計システム]
    OpenAI[🤖 OpenAI API<br/>AI機能]
    
    User -->|顧客情報検索<br/>対応履歴登録| System
    Admin -->|ユーザー管理<br/>設定変更| System
    
    System -->|認証| AD
    System -->|顧客情報取得| SysA
    System -->|対応履歴取得| SysB
    System -->|購買履歴取得| SysC
    System -->|回答候補生成| OpenAI
    
    style User fill:#e1f5fe,stroke:#0277bd
    style Admin fill:#fff3e0,stroke:#ef6c00
    style System fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
    style AD fill:#ffcdd2,stroke:#c62828
    style SysA fill:#f3e5f5,stroke:#7b1fa2
    style SysB fill:#fff9c4,stroke:#f57f17
    style SysC fill:#fce4ec,stroke:#c2185b
    style OpenAI fill:#e0f2f1,stroke:#00695c
```

**Level 2: Container図（コンテナ図）**

システム内部の主要なコンテナ（実行単位）を示します。

```mermaid
graph TD
    User[👤 ユーザー]
    
    subgraph System[顧客対応統合システム]
        SPA[🖥️ Web Application<br/>React SPA]
        API[⚙️ API Application<br/>Spring Boot]
        Batch[⏰ Batch Application<br/>Spring Batch]
        DB[(🗄️ Database<br/>PostgreSQL)]
        Cache[(⚡ Cache<br/>Redis)]
        FileStorage[📁 File Storage<br/>S3]
    end
    
    AD[Active Directory]
    ExternalSys[External Systems]
    
    User -->|HTTPS| SPA
    SPA -->|REST API<br/>JSON| API
    API --> DB
    API --> Cache
    API --> FileStorage
    API --> AD
    API --> ExternalSys
    Batch --> DB
    Batch --> ExternalSys
    
    style User fill:#e1f5fe,stroke:#0277bd
    style SPA fill:#fff9c4,stroke:#f57f17
    style API fill:#c8e6c9,stroke:#2e7d32
    style Batch fill:#f3e5f5,stroke:#7b1fa2
    style DB fill:#ffcdd2,stroke:#c62828
    style Cache fill:#e0f2f1,stroke:#00695c
```

**技術スタック：**

| コンテナ | 技術 | バージョン | 理由 |
|---------|------|----------|------|
| Web Application | React | 18.x | モダンなUI、SPAに最適 |
| | TypeScript | 5.x | 型安全性 |
| | Material-UI | 5.x | デザインシステム |
| API Application | Java | 17 LTS | 社内標準 |
| | Spring Boot | 3.x | 実績豊富 |
| | Spring Security | 6.x | セキュリティ |
| Database | PostgreSQL | 15.x | 高性能、高信頼性 |
| Cache | Redis | 7.x | 高速キャッシュ |
| File Storage | AWS S3 | - | 高可用性、低コスト |

**Level 3: Component図（コンポーネント図）**

APIアプリケーション内部の主要コンポーネントを示します。

```mermaid
graph TD
    SPA[Web Application]
    
    subgraph API[API Application]
        Controller[Controller Layer]
        Service[Service Layer]
        Repository[Repository Layer]
        Integration[Integration Layer]
        
        Controller --> Service
        Service --> Repository
        Service --> Integration
    end
    
    DB[(Database)]
    External[External Systems]
    
    SPA -->|HTTP Request| Controller
    Controller -->|HTTP Response| SPA
    Repository --> DB
    Integration --> External
    
    style SPA fill:#fff9c4,stroke:#f57f17
    style Controller fill:#e1f5fe,stroke:#0277bd
    style Service fill:#c8e6c9,stroke:#2e7d32
    style Repository fill:#f3e5f5,stroke:#7b1fa2
    style Integration fill:#fff3e0,stroke:#ef6c00
```

**レイヤー構造：**

| レイヤー | 責務 | 例 |
|---------|------|---|
| **Controller** | HTTPリクエスト/レスポンス処理 | CustomerController |
| **Service** | ビジネスロジック | CustomerService |
| **Repository** | データアクセス | CustomerRepository |
| **Integration** | 外部システム連携 | SystemAIntegration |

**Level 4: Code図（コード図）について**

C4モデルには本来Level 4（Code図）もあり、個別クラスやメソッドレベルの設計を表します。ただし、この詳細レベルの設計は**詳細設計フェーズ**で作成するため、基本設計では省略することが一般的です。

**Level 4で扱う内容:**

- クラス図（Class Diagram）
- シーケンス図（Sequence Diagram）
- メソッドの入出力仕様
- アルゴリズムの詳細

→ これらは次の「詳細設計フェーズ」で説明します。

#### ③データベース論理設計

**ER図（Entity Relationship Diagram）：**

```mermaid
erDiagram
    CUSTOMER ||--o{ INQUIRY_HISTORY : has
    CUSTOMER ||--o{ PURCHASE_HISTORY : has
    INQUIRY_HISTORY }o--|| STAFF : handled_by
    INQUIRY_HISTORY }o--|| CATEGORY : belongs_to
    
    CUSTOMER {
        varchar customer_id PK
        varchar customer_name
        varchar phone
        varchar email
        varchar address
        timestamp created_at
        timestamp updated_at
    }
    
    INQUIRY_HISTORY {
        bigint history_id PK
        varchar customer_id FK
        varchar staff_id FK
        varchar category_id FK
        timestamp inquiry_date
        text inquiry_content
        text response_content
        varchar priority
        varchar status
        timestamp created_at
        timestamp updated_at
    }
    
    PURCHASE_HISTORY {
        bigint purchase_id PK
        varchar customer_id FK
        varchar product_id
        int quantity
        decimal amount
        date purchase_date
        timestamp created_at
    }
    
    STAFF {
        varchar staff_id PK
        varchar staff_name
        varchar email
        varchar role
        timestamp created_at
    }
    
    CATEGORY {
        varchar category_id PK
        varchar category_name
        varchar description
        timestamp created_at
    }
```

**主要テーブルの論理設計：**

#### CUSTOMER（顧客）テーブル

| # | 項目名 | 論理名 | 型 | 桁数 | 必須 | 主キー | 説明 |
|---|--------|--------|----|----|-----|--------|------|
| 1 | customer_id | 顧客ID | VARCHAR | 10 | ✓ | ✓ | C + 9桁数字 |
| 2 | customer_name | 顧客名 | VARCHAR | 100 | ✓ | | |
| 3 | phone | 電話番号 | VARCHAR | 15 | | | ハイフンあり形式 |
| 4 | email | メールアドレス | VARCHAR | 255 | | | |
| 5 | address | 住所 | VARCHAR | 500 | | | |
| 6 | postal_code | 郵便番号 | VARCHAR | 8 | | | xxx-xxxx形式 |
| 7 | birth_date | 生年月日 | DATE | - | | | |
| 8 | gender | 性別 | VARCHAR | 10 | | | 男性/女性/その他 |
| 9 | customer_rank | ランク | VARCHAR | 20 | | | ゴールド/シルバー等 |
| 10 | created_at | 登録日時 | TIMESTAMP | - | ✓ | | |
| 11 | updated_at | 更新日時 | TIMESTAMP | - | ✓ | | |
| 12 | deleted_flag | 削除フラグ | BOOLEAN | - | ✓ | | デフォルト:false |

**インデックス：**

- PRIMARY KEY (customer_id)
- INDEX idx_customer_name (customer_name)
- INDEX idx_phone (phone)
- INDEX idx_email (email)

#### INQUIRY_HISTORY（対応履歴）テーブル

| # | 項目名 | 論理名 | 型 | 桁数 | 必須 | 主キー | 説明 |
|---|--------|--------|----|----|-----|--------|------|
| 1 | history_id | 履歴ID | BIGINT | - | ✓ | ✓ | 自動採番 |
| 2 | customer_id | 顧客ID | VARCHAR | 10 | ✓ | | 外部キー |
| 3 | staff_id | 担当者ID | VARCHAR | 20 | ✓ | | 外部キー |
| 4 | category_id | カテゴリID | VARCHAR | 20 | ✓ | | 外部キー |
| 5 | inquiry_date | 問い合わせ日時 | TIMESTAMP | - | ✓ | | |
| 6 | inquiry_content | 問い合わせ内容 | TEXT | - | ✓ | | 最大2000文字 |
| 7 | response_content | 対応内容 | TEXT | - | ✓ | | 最大2000文字 |
| 8 | priority | 優先度 | VARCHAR | 10 | ✓ | | 高/中/低 |
| 9 | status | ステータス | VARCHAR | 20 | ✓ | | 対応中/完了/保留 |
| 10 | follow_up_date | フォローアップ日 | DATE | - | | | |
| 11 | satisfaction_score | 満足度 | INT | - | | | 1-5点 |
| 12 | created_at | 登録日時 | TIMESTAMP | - | ✓ | | |
| 13 | updated_at | 更新日時 | TIMESTAMP | - | ✓ | | |

**インデックス：**

- PRIMARY KEY (history_id)
- INDEX idx_customer_id (customer_id)
- INDEX idx_inquiry_date (inquiry_date)
- INDEX idx_staff_id (staff_id)
- INDEX idx_category_id (category_id)
- INDEX idx_status (status)

**外部キー制約：**

- FOREIGN KEY (customer_id) REFERENCES CUSTOMER(customer_id)
- FOREIGN KEY (staff_id) REFERENCES STAFF(staff_id)
- FOREIGN KEY (category_id) REFERENCES CATEGORY(category_id)

#### ④画面設計

**画面遷移図：**

```mermaid
graph TD
    Login[ログイン画面] --> Home[ホーム画面]
    
    Home --> Search[顧客検索画面]
    Home --> Report[レポート画面]
    Home --> Admin[管理画面]
    
    Search --> Detail[顧客詳細画面]
    Detail --> History[対応履歴詳細]
    Detail --> NewInquiry[対応履歴登録画面]
    
    NewInquiry --> Confirm[登録確認画面]
    Confirm --> Complete[登録完了画面]
    Complete --> Detail
    
    History --> Edit[履歴編集画面]
    Edit --> Detail
    
    Report --> ReportResult[レポート表示画面]
    
    Admin --> UserMgmt[ユーザー管理]
    Admin --> CategoryMgmt[カテゴリ管理]
    
    style Login fill:#ffcdd2,stroke:#c62828
    style Home fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
    style Search fill:#e1f5fe,stroke:#0277bd
    style Detail fill:#fff9c4,stroke:#f57f17
```

**画面一覧：**

| 画面ID | 画面名 | 機能概要 | 権限 |
|-------|--------|---------|------|
| SC-001 | ログイン画面 | ID/パスワード、2要素認証 | 全員 |
| SC-002 | ホーム画面 | ダッシュボード、メニュー | 全員 |
| SC-003 | 顧客検索画面 | 顧客検索、検索結果一覧 | 全員 |
| SC-004 | 顧客詳細画面 | 顧客情報、対応履歴一覧 | 全員 |
| SC-005 | 対応履歴登録画面 | 新規対応登録 | 担当者以上 |
| SC-006 | 対応履歴詳細画面 | 履歴詳細表示 | 全員 |
| SC-007 | 履歴編集画面 | 履歴編集 | リーダー以上 |
| SC-008 | レポート画面 | レポート条件設定 | リーダー以上 |
| SC-009 | 管理画面 | 各種設定 | 管理者のみ |

**ワイヤーフレーム例：顧客検索画面**

```
┌─────────────────────────────────────────────────────────┐
│  顧客対応統合システム                    👤 山田太郎 ログアウト │
├─────────────────────────────────────────────────────────┤
│ 🏠 ホーム  🔍 検索  📊 レポート  ⚙️ 設定                  │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  顧客検索                                                 │
│                                                          │
│  ┌──────────────────────────────────────┐                │
│  │ 顧客名    [__________________]  🔍検索 │                │
│  └──────────────────────────────────────┘                │
│  ┌──────────────────────────────────────┐                │
│  │ 電話番号  [__________________]       │                │
│  └──────────────────────────────────────┘                │
│  ┌──────────────────────────────────────┐                │
│  │ メール    [__________________]       │                │
│  └──────────────────────────────────────┘                │
│                                                          │
│  検索結果: 12件                                           │
│  ┌───────────────────────────────────────────────────┐   │
│  │ 顧客ID  │ 顧客名    │ 電話番号      │ 最終対応日 │   │
│  ├───────────────────────────────────────────────────┤   │
│  │ C00123 │ 山田太郎   │ 090-1234-5678 │ 2026/03/15 │   │
│  │ C00456 │ 山田花子   │ 080-9876-5432 │ 2026/03/10 │   │
│  │ ...                                                 │   │
│  └───────────────────────────────────────────────────┘   │
│                                                          │
│  [< 前へ]  1 / 2  [次へ >]                               │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

**画面設計のポイント：**

| 項目 | 設計内容 |
|-----|---------|
| レイアウト | Material Design準拠 |
| レスポンシブ | 1920×1080推奨、1366×768対応 |
| アクセシビリティ | WCAG 2.1 AA準拠 |
| カラースキーム | プライマリー:#1976D2、セカンダリー:#FFC107 |
| フォント | Noto Sans JP |
| エラー表示 | 赤色、画面上部にトースト表示 |
| 成功表示 | 緑色、画面上部にトースト表示 |

### 📄 作成するドキュメント：基本設計書

```markdown
# 基本設計書

**プロジェクト名：** 顧客対応統合システム  
**バージョン：** 1.0  
**作成日：** 2026年3月1日  
**承認日：** 2026年3月31日

## 1. 目的

本書は、要求仕様書（SRS）で定義された要件を実現するための
システムの基本的な設計方針と構成を定義する。

## 2. システム全体構成

### 2.1 システム構成図

[前述のシステム構成図を参照]

### 2.2 技術スタック

[前述の技術スタック表を参照]

### 2.3 システム要件

| 項目 | 要件 |
|-----|------|
| OS | Amazon Linux 2 |
| CPUアーキテクチャ | x86_64 |
| メモリ | Web/APサーバー: 8GB、DBサーバー: 16GB |
| ディスク | Web/APサーバー: 100GB、DBサーバー: 500GB |
| ネットワーク | 1Gbps以上 |

## 3. アーキテクチャ設計

### 3.1 アーキテクチャパターン

本システムは**レイヤードアーキテクチャ**を採用する。

#### レイヤー構成

```

┌─────────────────────────┐
│  Presentation Layer     │ ← UI（React）
├─────────────────────────┤
│  Application Layer      │ ← Controller
├─────────────────────────┤
│  Domain Layer           │ ← Service, Entity
├─────────────────────────┤
│  Infrastructure Layer   │ ← Repository, Integration
└─────────────────────────┘

```

#### レイヤー間の依存関係ルール

1. 上位レイヤーは下位レイヤーに依存できる
2. 下位レイヤーは上位レイヤーに依存してはならない
3. 各レイヤーは明確な責務を持つ

### 3.2 設計原則

| 原則 | 説明 | 適用例 |
|-----|------|--------|
| SOLID原則 | 単一責任、開放閉鎖、依存性逆転等 | 全クラス設計 |
| DRY | Don't Repeat Yourself | 共通処理の切り出し |
| YAGNI | You Aren't Gonna Need It | 過剰な機能追加を避ける |
| KISS | Keep It Simple, Stupid | シンプルな設計を優先 |

### 3.3 C4モデル図

#### Context図
[前述のContext図を参照]

#### Container図
[前述のContainer図を参照]

#### Component図
[前述のComponent図を参照]

## 4. データベース設計

### 4.1 ER図
[前述のER図を参照]

### 4.2 テーブル一覧

| No. | テーブル名 | 論理名 | 主キー | 件数見積 |
|-----|----------|--------|--------|---------|
| 1 | CUSTOMER | 顧客 | customer_id | 100万件 |
| 2 | INQUIRY_HISTORY | 対応履歴 | history_id | 500万件 |
| 3 | PURCHASE_HISTORY | 購買履歴 | purchase_id | 1000万件 |
| 4 | STAFF | 担当者 | staff_id | 100件 |
| 5 | CATEGORY | カテゴリ | category_id | 50件 |

### 4.3 正規化

本システムでは**第3正規形**まで正規化を実施する。

**正規化のルール：**
1. 第1正規形：繰り返し項目を排除
2. 第2正規形：部分関数従属を排除
3. 第3正規形：推移関数従属を排除

## 5. 画面設計

### 5.1 画面一覧
[前述の画面一覧表を参照]

### 5.2 画面遷移図
[前述の画面遷移図を参照]

### 5.3 共通UI設計

#### ヘッダー
全画面共通のヘッダーを配置
- ロゴ
- メニュー
- ユーザー名
- ログアウトボタン

#### フッター
全画面共通のフッター
- コピーライト
- バージョン情報

#### エラー表示
- トーストメッセージで画面上部に表示
- 3秒後に自動で消える
- 手動で閉じることも可能

## 6. API設計

### 6.1 REST API 設計方針

| 項目 | 方針 |
|-----|------|
| URL設計 | RESTful、リソース指向 |
| HTTPメソッド | GET（取得）、POST（作成）、PUT（更新）、DELETE（削除） |
| ステータスコード | 適切なHTTPステータスを返却 |
| 認証 | JWT（JSON Web Token） |
| バージョニング | URLに含める（/api/v1/） |
| レスポンス形式 | JSON |
| エラーフォーマット | 統一したエラーレスポンス |

### 6.2 APIエンドポイント一覧

| No. | メソッド | エンドポイント | 機能 | 権限 |
|-----|---------|--------------|------|------|
| 1 | POST | /api/v1/auth/login | ログイン | なし |
| 2 | POST | /api/v1/auth/logout | ログアウト | 全員 |
| 3 | GET | /api/v1/customers/search | 顧客検索 | 全員 |
| 4 | GET | /api/v1/customers/{id} | 顧客詳細取得 | 全員 |
| 5 | POST | /api/v1/inquiries | 対応履歴登録 | 担当者以上 |
| 6 | GET | /api/v1/inquiries/{id} | 対応履歴取得 | 全員 |
| 7 | PUT | /api/v1/inquiries/{id} | 対応履歴更新 | リーダー以上 |
| 8 | GET | /api/v1/reports/monthly | 月次レポート | リーダー以上 |

### 6.3 API詳細仕様（例：顧客検索）

[前述のAPI仕様を参照]

## 7. 外部システム連携設計

### 7.1 連携システム一覧

| システム名 | 連携方式 | プロトコル | 認証方式 | 頻度 |
|-----------|---------|-----------|---------|------|
| System A | REST API | HTTPS | API Key | リアルタイム |
| System B | REST API | HTTPS | API Key | リアルタイム |
| System C | REST API | HTTPS | API Key | 日次バッチ |
| Active Directory | LDAP | LDAPS | 証明書 | リアルタイム |
| OpenAI | REST API | HTTPS | API Key | リアルタイム |

### 7.2 連携シーケンス（例：顧客検索）

```mermaid
sequenceDiagram
    participant User as ユーザー
    participant UI as Webアプリ
    participant API as APIサーバー
    participant Cache as Redis
    participant DB as PostgreSQL
    participant SysA as System A
    participant SysB as System B
    
    User->>UI: 顧客名「山田」で検索
    UI->>API: GET /api/v1/customers/search?name=山田
    
    API->>Cache: キャッシュ確認
    alt キャッシュHit
        Cache-->>API: キャッシュデータ
        API-->>UI: 検索結果
    else キャッシュMiss
        par 並行取得
            API->>DB: 統合DBから検索
            DB-->>API: 顧客データ
        and
            API->>SysA: 顧客情報取得API
            SysA-->>API: 顧客詳細
        and
            API->>SysB: 対応履歴取得API
            SysB-->>API: 履歴データ
        end
        
        API->>API: データ統合
        API->>Cache: 結果をキャッシュ（5分）
        API-->>UI: 検索結果
    end
    
    UI->>User: 検索結果表示
```

## 8. セキュリティ設計

### 8.1 認証設計

**認証フロー：**

```mermaid
sequenceDiagram
    participant User as ユーザー
    participant UI as Webアプリ
    participant API as APIサーバー
    participant AD as Active Directory
    participant OTP as OTP検証サービス
    
    User->>UI: ID/パスワード入力
    UI->>API: POST /api/v1/auth/login
    API->>AD: LDAP認証
    alt 認証成功
        AD-->>API: 認証OK
        API->>OTP: ワンタイムパスワード送信
        OTP-->>User: メール/SMSで送信
        User->>UI: ワンタイムパスワード入力
        UI->>API: ワンタイムパスワード検証
        API->>API: JWT生成
        API-->>UI: JWT返却
        UI->>UI: JWT保存（SessionStorage）
    else 認証失敗
        AD-->>API: 認証NG
        API-->>UI: エラー
    end
```

### 8.2 認可設計（RBAC）

**ロールと権限マトリクス：**

| 機能 | 管理者 | リーダー | 担当者 | 閲覧のみ |
|-----|:-----:|:------:|:-----:|:-------:|
| 顧客検索 | ✓ | ✓ | ✓ | ✓ |
| 顧客詳細表示 | ✓ | ✓ | ✓ | ✓ |
| 対応履歴登録 | ✓ | ✓ | ✓ | ✗ |
| 対応履歴編集 | ✓ | ✓ | ✗ | ✗ |
| 対応履歴削除 | ✓ | ✓ | ✗ | ✗ |
| レポート出力 | ✓ | ✓ | ✗ | ✗ |
| ユーザー管理 | ✓ | ✗ | ✗ | ✗ |
| システム設定 | ✓ | ✗ | ✗ | ✗ |

### 8.3 暗号化設計

| 対象 | 暗号化方式 | 適用箇所 |
|-----|----------|---------|
| 通信 | TLS 1.3 | 全HTTP通信 |
| パスワード | bcrypt（コスト12） | DB保存時 |
| 個人情報 | AES-256 | DB保存時 |
| JWT | RS256（RSA） | トークン署名 |
| API Key | AES-256 | 設定ファイル |

### 8.4 監査ログ設計

**記録する情報：**

- ユーザーID
- 操作日時
- 操作内容（CRUD）
- 対象リソース
- IPアドレス
- 結果（成功/失敗）

**保存場所：** 別テーブル（AUDIT_LOG）  
**保存期間：** 5年

## 9. 性能設計

### 9.1 性能目標

[前述のNFR表を参照]

### 9.2 性能最適化設計

| 施策 | 内容 | 効果 |
|-----|------|------|
| データベースインデックス | 検索頻度の高いカラムにインデックス | 検索速度向上 |
| キャッシュ（Redis） | 検索結果を5分間キャッシュ | レスポンス2秒→0.5秒 |
| コネクションプール | DB接続を再利用 | オーバーヘッド削減 |
| ページング | 大量データは100件ずつ取得 | メモリ使用量削減 |
| 非同期処理 | 重い処理はバックグラウンド | UI応答性向上 |
| CDN | 静的ファイルをCDN配信 | ページロード高速化 |

### 9.3 ボトルネック対策

**想定ボトルネック：**

1. データベースクエリ
   - 対策：適切なインデックス、クエリ最適化
2. 外部API呼び出し
   - 対策：並列実行、タイムアウト設定
3. 大量データの処理
   - 対策：ページング、ストリーミング処理

## 10. 可用性設計

### 10.1 冗長化設計

[前述のシステム構成図を参照]

### 10.2 障害対応設計

**障害パターンと対応：**

| 障害 | 検知方法 | 自動復旧 | 手動対応 | RTO |
|-----|---------|---------|---------|-----|
| Webサーバー停止 | ヘルスチェック | ALBが自動切り替え | - | 1分 |
| DBマスター停止 | RDSヘルスチェック | 自動フェイルオーバー | - | 30分 |
| AZ障害 | マルチAZ配置 | 自動切り替え | - | 5分 |
| リージョン障害 | 手動監視 | - | 手動切り替え | 4時間 |

### 10.3 バックアップ設計

| 対象 | 方法 | 頻度 | 保持期間 | RPO |
|-----|------|------|---------|-----|
| データベース | RDS自動バックアップ | 日次 | 7日 | 1時間 |
| ファイル | S3バケット | リアルタイム | 無期限 | 0分 |
| 設定ファイル | Git管理 | コミット時 | 無期限 | - |

## 11. 運用設計

### 11.1 監視設計

**監視項目：**

| カテゴリ | 監視項目 | 閾値 | アラート |
|---------|---------|------|---------|
| リソース | CPU使用率 | 80%以上 | Warning |
| | メモリ使用率 | 90%以上 | Critical |
| | ディスク使用率 | 80%以上 | Warning |
| 性能 | レスポンスタイム | 3秒以上 | Warning |
| | エラー率 | 1%以上 | Critical |
| 可用性 | サーバー死活 | ダウン | Critical |
| | DBコネクション | 枯渇 | Critical |

**使用ツール：**

- CloudWatch（AWS標準）
- Application Insights（APM）
- CloudWatch Logs（ログ集約）

### 11.2 ログ設計

**ログレベル：**

- ERROR：エラー発生時
- WARN：警告レベルの事象
- INFO：通常の処理フロー
- DEBUG：詳細なデバッグ情報（本番では無効）

**ログフォーマット：**

```
[日時] [レベル] [クラス名] [メソッド名] [メッセージ] key1=value1 key2=value2
```

**例：**

```
[2026-03-15 10:30:45.123] [INFO] [CustomerService] [searchCustomer] 
Customer search started userId=user001 criteria={name:山田} 

[2026-03-15 10:30:45.456] [INFO] [CustomerService] [searchCustomer] 
Customer search completed userId=user001 resultCount=5 duration=333ms
```

### 11.3 デプロイ設計

**デプロイ方式：** Blue/Green デプロイメント

```mermaid
graph LR
    A[現行環境<br/>Blue] --> C[ロードバランサー]
    B[新環境<br/>Green] -.切り替え.-> C
    C --> D[ユーザー]
    
    E[デプロイ] --> B
    E --> F[テスト]
    F -->|OK| G[切り替え]
    F -->|NG| H[ロールバック]
    
    style A fill:#e1f5fe,stroke:#0277bd
    style B fill:#c8e6c9,stroke:#2e7d32
    style C fill:#fff9c4,stroke:#f57f17
    style G fill:#c8e6c9,stroke:#2e7d32
    style H fill:#ffcdd2,stroke:#c62828
```

**デプロイ手順：**

1. 新環境（Green）を構築
2. アプリケーションをデプロイ
3. 自動テスト実行
4. 問題なければLB切り替え
5. 旧環境（Blue）を待機状態に
6. 問題あれば即座にBlueに戻す（ロールバック）

## 12. 変更履歴

| バージョン | 日付 | 変更者 | 変更内容 | 承認者 |
|-----------|------|--------|---------|--------|
| 0.1 | 2026/02/20 | 佐藤 | 初稿作成 | - |
| 0.5 | 2026/03/10 | 佐藤 | レビュー反映 | - |
| 1.0 | 2026/03/31 | 佐藤 | 承認版 | 田中PM |

---
以上

```

### 🎓 このフェーズのまとめ

**✅ やること：**
1. システム全体構成の決定
2. アーキテクチャ設計（C4モデル）
3. データベース論理設計（ER図）
4. 画面設計（遷移図、ワイヤーフレーム）
5. API設計
6. セキュリティ設計
7. 性能・可用性設計

**📄 作るドキュメント：**
- 基本設計書
- アーキテクチャ記述書（AD）
- 画面設計書
- API仕様書

**⚠️ よくある失敗：**
- アーキテクチャが複雑すぎる
- 性能を後回しにする
- セキュリティを軽視する
- 運用を考慮していない設計

**💡 成功のコツ：**
- **シンプルに保つ**（KISS原則）
- **将来の拡張性も考慮**（でも過剰設計はしない）
- **非機能要件を重視**（性能、セキュリティ、可用性）
- **図を多用**（文章だけだと分かりにくい）
- **技術選定の根拠を明確に**（なぜその技術を選んだか）


## 3.4 ④詳細設計フェーズ

### 📌 このフェーズの目的

**「どう作るか（HOW）の詳細」を決める**

家を建てることで例えると：「壁の中の配線1本1本、コンセントの位置、スイッチの高さまで全て決める段階」

### 🎯 このフェーズで行うこと

```mermaid
graph TD
    A[詳細設計フェーズ] --> B[①クラス設計]
    A --> C[②処理フロー設計]
    A --> D[③データベース物理設計]
    A --> E[④API詳細設計]
    A --> F[⑤エラーハンドリング設計]
    A --> G[⑥単体テスト設計]
    
    B --> B1[クラス図作成]
    B --> B2[メソッド定義]
    B --> B3[属性定義]
    
    C --> C1[シーケンス図]
    C --> C2[フローチャート]
    C --> C3[処理詳細記述]
    
    D --> D1[物理テーブル定義]
    D --> D2[インデックス設計]
    D --> D3[パーティション設計]
    
    E --> E1[リクエスト/レスポンス詳細]
    E --> E2[エラーコード定義]
    E --> E3[バリデーションルール]
    
    F --> F1[例外クラス設計]
    F --> F2[エラーメッセージ定義]
    F --> F3[ロギング設計]
    
    G --> G1[テストケース設計]
    G --> G2[テストデータ準備]
    G --> G3[モック設計]
    
    style A fill:#f1f8e9,stroke:#558b2f,stroke-width:3px
    style B fill:#e1f5fe,stroke:#0277bd
    style C fill:#f3e5f5,stroke:#7b1fa2
    style D fill:#ffcdd2,stroke:#c62828
    style E fill:#fff9c4,stroke:#f57f17
    style F fill:#fce4ec,stroke:#c2185b
    style G fill:#c8e6c9,stroke:#2e7d32
```

### 📝 具体的な作業内容

#### ①クラス設計（詳細）

**クラス図の例：顧客検索機能**

```mermaid
classDiagram
    class CustomerController {
        -CustomerService customerService
        -CustomerValidator validator
        +ResponseEntity~CustomerListResponse~ searchCustomer(CustomerSearchRequest request)
        +ResponseEntity~CustomerDetailResponse~ getCustomerDetail(String customerId)
        -void validateSearchRequest(CustomerSearchRequest request)
    }
    
    class CustomerService {
        -CustomerRepository customerRepository
        -SystemAIntegration systemAIntegration
        -SystemBIntegration systemBIntegration
        -RedisTemplate~String,Customer~ redisTemplate
        -Logger logger
        +List~Customer~ searchCustomer(CustomerSearchCriteria criteria)
        +Customer getCustomerById(String customerId)
        -List~Customer~ searchFromDatabase(CustomerSearchCriteria criteria)
        -void enrichCustomerData(List~Customer~ customers)
        -void cacheSearchResult(String key, List~Customer~ customers)
    }
    
    class CustomerRepository {
        -JdbcTemplate jdbcTemplate
        +List~Customer~ findByCriteria(CustomerSearchCriteria criteria)
        +Optional~Customer~ findById(String customerId)
        +int countByCriteria(CustomerSearchCriteria criteria)
        -String buildSearchQuery(CustomerSearchCriteria criteria)
        -Map~String,Object~ buildParameters(CustomerSearchCriteria criteria)
    }
    
    class Customer {
        -String customerId
        -String customerName
        -String phone
        -String email
        -String address
        -LocalDate birthDate
        -CustomerRank rank
        -LocalDateTime createdAt
        -LocalDateTime updatedAt
        +String getCustomerId()
        +void setCustomerId(String customerId)
        +String getDisplayName()
        +int getAge()
        +boolean isPremiumCustomer()
    }
    
    class CustomerSearchCriteria {
        -String customerName
        -String phone
        -String email
        -int limit
        -int offset
        +boolean isEmpty()
        +String toQueryString()
    }
    
    class CustomerValidator {
        +void validateSearchCriteria(CustomerSearchCriteria criteria)
        +void validateCustomerId(String customerId)
        -boolean isValidPhoneNumber(String phone)
        -boolean isValidEmail(String email)
    }
    
    CustomerController --> CustomerService : uses
    CustomerController --> CustomerValidator : uses
    CustomerService --> CustomerRepository : uses
    CustomerService --> Customer : creates
    CustomerRepository --> Customer : creates
    CustomerService --> CustomerSearchCriteria : uses
    CustomerRepository --> CustomerSearchCriteria : uses
    CustomerValidator --> CustomerSearchCriteria : validates
```

**クラス詳細設計書の例：**

#### CustomerService クラス

**パッケージ：** `com.example.customer.service`

**責務：**

- 顧客情報の検索・取得に関するビジネスロジック
- 複数システムからのデータ統合
- キャッシュ制御

**属性（フィールド）：**

| 属性名 | 型 | 説明 | 初期化 |
|-------|----|----|--------|
| customerRepository | CustomerRepository | データアクセス | @Autowired |
| systemAIntegration | SystemAIntegration | System A連携 | @Autowired |
| systemBIntegration | SystemBIntegration | System B連携 | @Autowired |
| redisTemplate | RedisTemplate<String,List<Customer>> | キャッシュ | @Autowired |
| logger | Logger | ログ出力 | LoggerFactory |
| CACHE_TTL | int | キャッシュ有効期限（秒） | 300 (5分) |

**メソッド：**

##### searchCustomer メソッド

```java
/**
 * 顧客を検索する
 * 
 * @param criteria 検索条件
 * @return 検索結果の顧客リスト
 * @throws ValidationException 検索条件が不正な場合
 * @throws SystemException システムエラーが発生した場合
 */
public List<Customer> searchCustomer(CustomerSearchCriteria criteria) 
    throws ValidationException, SystemException
```

**処理フロー：**

```mermaid
flowchart TD
    Start([開始]) --> Input[検索条件を受け取る]
    Input --> Log1[ログ出力: 検索開始]
    Log1 --> Validate{検索条件の<br/>妥当性チェック}
    
    Validate -->|NG| Error1[ValidationException<br/>をスロー]
    Error1 --> End1([終了])
    
    Validate -->|OK| CacheKey[キャッシュキー生成]
    CacheKey --> CheckCache{キャッシュ<br/>存在確認}
    
    CheckCache -->|Hit| CacheGet[キャッシュから取得]
    CacheGet --> Log2[ログ出力: キャッシュヒット]
    Log2 --> Return[結果を返す]
    
    CheckCache -->|Miss| DBSearch[データベース検索]
    DBSearch --> CountCheck{件数<br/>チェック}
    
    CountCheck -->|0件| EmptyList[空リストを返す]
    EmptyList --> Log3[ログ出力: 該当なし]
    Log3 --> Return
    
    CountCheck -->|100件超| Limit[上位100件に制限]
    CountCheck -->|100件以下| Sort[50音順ソート]
    
    Limit --> LogWarn[ログ出力: 件数超過警告]
    LogWarn --> Sort
    
    Sort --> Enrich[外部システムから<br/>追加情報取得]
    Enrich --> CacheSet[結果をキャッシュ]
    CacheSet --> Log4[ログ出力: 検索完了]
    Log4 --> Return
    
    Return --> End2([終了])
    
    style Start fill:#c8e6c9,stroke:#2e7d32
    style End1 fill:#ffcdd2,stroke:#c62828
    style End2 fill:#c8e6c9,stroke:#2e7d32
    style Error1 fill:#ffcdd2,stroke:#c62828
    style Validate fill:#fff9c4,stroke:#f57f17
    style CheckCache fill:#e1f5fe,stroke:#0277bd
    style CountCheck fill:#f3e5f5,stroke:#7b1fa2
```

**詳細ロジック：**

```java
public List<Customer> searchCustomer(CustomerSearchCriteria criteria) {
    // 1. ログ出力（開始）
    logger.info("Customer search started: {}", criteria.toQueryString());
    long startTime = System.currentTimeMillis();
    
    // 2. 検証
    if (criteria.isEmpty()) {
        logger.warn("Search criteria is empty");
        throw new ValidationException("検索条件を指定してください");
    }
    
    // 3. キャッシュ確認
    String cacheKey = generateCacheKey(criteria);
    List<Customer> cachedResult = redisTemplate.opsForValue().get(cacheKey);
    
    if (cachedResult != null) {
        logger.info("Cache hit: key={}", cacheKey);
        return cachedResult;
    }
    
    // 4. データベース検索
    logger.debug("Searching database with criteria: {}", criteria);
    List<Customer> customers = customerRepository.findByCriteria(criteria);
    
    // 5. 件数チェック
    if (customers.isEmpty()) {
        logger.info("No customers found");
        return Collections.emptyList();
    }
    
    if (customers.size() > 100) {
        logger.warn("Search result exceeds limit: actualCount={}", customers.size());
        customers = customers.subList(0, 100);
    }
    
    // 6. ソート
    customers.sort((c1, c2) -> {
        Collator collator = Collator.getInstance(Locale.JAPANESE);
        return collator.compare(c1.getCustomerName(), c2.getCustomerName());
    });
    
    // 7. 外部システムから追加情報取得（並列実行）
    enrichCustomerData(customers);
    
    // 8. キャッシュに保存
    redisTemplate.opsForValue().set(cacheKey, customers, CACHE_TTL, TimeUnit.SECONDS);
    
    // 9. ログ出力（完了）
    long duration = System.currentTimeMillis() - startTime;
    logger.info("Customer search completed: resultCount={}, duration={}ms", 
                customers.size(), duration);
    
    return customers;
}

/**
 * キャッシュキーを生成
 */
private String generateCacheKey(CustomerSearchCriteria criteria) {
    return "customer:search:" + 
           criteria.getCustomerName() + ":" + 
           criteria.getPhone() + ":" + 
           criteria.getEmail();
}

/**
 * 外部システムから追加情報を取得して顧客データを拡充
 */
private void enrichCustomerData(List<Customer> customers) {
    // 並列処理でSystem AとSystem Bから情報取得
    customers.parallelStream().forEach(customer -> {
        try {
            // System Aから追加情報
            CustomerDetail detail = systemAIntegration.getCustomerDetail(
                customer.getCustomerId()
            );
            customer.setRank(detail.getRank());
            
            // System Bから対応履歴サマリー
            InquirySummary summary = systemBIntegration.getInquirySummary(
                customer.getCustomerId()
            );
            customer.setLastInquiryDate(summary.getLastInquiryDate());
            customer.setInquiryCount(summary.getTotalCount());
            
        } catch (IntegrationException e) {
            logger.warn("Failed to enrich customer data: customerId={}, error={}", 
                        customer.getCustomerId(), e.getMessage());
            // エラーでも処理は続行（追加情報が取れないだけ）
        }
    });
}
```

**例外処理：**

| 例外 | 発生条件 | 処理 |
|-----|---------|------|
| ValidationException | 検索条件が空 | エラーメッセージを含めて上位にスロー |
| SQLException | DB接続エラー | ログ出力後、SystemExceptionに変換 |
| TimeoutException | クエリタイムアウト | ログ出力後、SystemExceptionに変換 |
| IntegrationException | 外部連携エラー | ログ出力して処理継続（追加情報なし） |

**性能考慮点：**

| 項目 | 対策 | 効果 |
|-----|------|------|
| キャッシュ | Redisで5分間キャッシュ | レスポンス2秒→0.5秒 |
| インデックス | customer_name, phone, email | 検索速度10倍向上 |
| 並列処理 | 外部API呼び出しを並列化 | 外部連携時間を50%短縮 |
| コネクションプール | HikariCP使用 | 接続オーバーヘッド削減 |
| N+1問題回避 | JOINで一括取得 | クエリ数を1/100に削減 |

#### ②処理フロー設計（シーケンス図）

**顧客検索処理の詳細シーケンス：**

```mermaid
sequenceDiagram
    autonumber
    participant User as 👤ユーザー
    participant UI as React UI
    participant Controller as CustomerController
    participant Validator as CustomerValidator
    participant Service as CustomerService
    participant Cache as Redis Cache
    participant Repo as CustomerRepository
    participant DB as PostgreSQL
    participant SysA as System A
    participant SysB as System B
    
    User->>UI: 顧客名「山田」を入力して検索
    UI->>UI: バリデーション（クライアント側）
    
    UI->>Controller: GET /api/v1/customers/search?name=山田
    Note over Controller: JWT認証チェック
    
    Controller->>Validator: validateSearchCriteria(criteria)
    Validator->>Validator: 検索条件チェック
    alt 検証NG
        Validator-->>Controller: ValidationException
        Controller-->>UI: 400 Bad Request
        UI-->>User: エラーメッセージ表示
    end
    
    Validator-->>Controller: OK
    Controller->>Service: searchCustomer(criteria)
    
    Note over Service: ログ: 検索開始
    Service->>Service: generateCacheKey()
    Service->>Cache: get(cacheKey)
    
    alt キャッシュHit
        Cache-->>Service: 顧客リスト（キャッシュ）
        Note over Service: ログ: キャッシュヒット
        Service-->>Controller: 顧客リスト
    else キャッシュMiss
        Cache-->>Service: null
        
        Service->>Repo: findByCriteria(criteria)
        Repo->>Repo: buildSearchQuery()
        Repo->>DB: SELECT * FROM customer WHERE...
        DB-->>Repo: ResultSet
        Repo->>Repo: mapToCustomerList()
        Repo-->>Service: 顧客リスト
        
        alt 件数チェック
            Service->>Service: size() > 100?
            Note over Service: ログ: 件数超過警告
            Service->>Service: subList(0, 100)
        end
        
        Service->>Service: sort（50音順）
        
        par 並列処理
            Service->>SysA: getCustomerDetail(customerId)
            SysA-->>Service: 顧客詳細（ランク等）
        and
            Service->>SysB: getInquirySummary(customerId)
            SysB-->>Service: 対応履歴サマリー
        end
        
        Service->>Service: enrichCustomerData()
        Service->>Cache: set(cacheKey, customers, 300秒)
        Cache-->>Service: OK
        
        Note over Service: ログ: 検索完了, duration=XXXms
        Service-->>Controller: 顧客リスト
    end
    
    Controller->>Controller: toResponse()
    Controller-->>UI: 200 OK + CustomerListResponse
    UI->>UI: データ整形
    UI-->>User: 検索結果表示
```

#### ③データベース物理設計

**物理テーブル定義：CUSTOMER**

```sql
-- ============================================
-- テーブル: CUSTOMER（顧客）
-- 説明: 顧客の基本情報を管理するテーブル
-- ============================================

CREATE TABLE customer (
    -- 主キー
    customer_id         VARCHAR(10)     NOT NULL
        CONSTRAINT pk_customer PRIMARY KEY
        COMMENT '顧客ID（C + 9桁数字、例: C000000001）',
    
    -- 基本情報
    customer_name       VARCHAR(100)    NOT NULL
        COMMENT '顧客名（姓名）',
    customer_name_kana  VARCHAR(100)    NULL
        COMMENT '顧客名カナ（セイメイ）',
    phone               VARCHAR(15)     NULL
        COMMENT '電話番号（ハイフンあり、例: 090-1234-5678）',
    email               VARCHAR(255)    NULL
        COMMENT 'メールアドレス',
    postal_code         VARCHAR(8)      NULL
        COMMENT '郵便番号（ハイフンあり、例: 123-4567）',
    address             VARCHAR(500)    NULL
        COMMENT '住所',
    
    -- 詳細情報
    birth_date          DATE            NULL
        COMMENT '生年月日',
    gender              VARCHAR(10)     NULL
        COMMENT '性別（男性/女性/その他/回答しない）',
    customer_rank       VARCHAR(20)     NOT NULL DEFAULT 'BRONZE'
        COMMENT '顧客ランク（PLATINUM/GOLD/SILVER/BRONZE）',
    
    -- システム項目
    created_at          TIMESTAMP       NOT NULL DEFAULT CURRENT_TIMESTAMP
        COMMENT '登録日時',
    created_by          VARCHAR(50)     NOT NULL
        COMMENT '登録者',
    updated_at          TIMESTAMP       NOT NULL DEFAULT CURRENT_TIMESTAMP
        COMMENT '更新日時',
    updated_by          VARCHAR(50)     NOT NULL
        COMMENT '更新者',
    deleted_flag        BOOLEAN         NOT NULL DEFAULT FALSE
        COMMENT '削除フラグ（TRUE: 削除済み、FALSE: 有効）',
    version             BIGINT          NOT NULL DEFAULT 0
        COMMENT 'バージョン番号（楽観的ロック用）'
)
ENGINE = InnoDB
DEFAULT CHARSET = utf8mb4
COLLATE = utf8mb4_unicode_ci
COMMENT = '顧客マスタ';

-- ============================================
-- インデックス
-- ============================================

-- 顧客名検索用（部分一致検索）
CREATE INDEX idx_customer_name 
    ON customer(customer_name);

-- 顧客名カナ検索用（50音順ソート）
CREATE INDEX idx_customer_name_kana 
    ON customer(customer_name_kana);

-- 電話番号検索用（完全一致）
CREATE INDEX idx_phone 
    ON customer(phone);

-- メールアドレス検索用（完全一致、ユニーク）
CREATE UNIQUE INDEX idx_email 
    ON customer(email) 
    WHERE email IS NOT NULL AND deleted_flag = FALSE;

-- 登録日時検索用（範囲検索）
CREATE INDEX idx_created_at 
    ON customer(created_at);

-- 削除フラグ + 更新日時（論理削除データ除外）
CREATE INDEX idx_deleted_updated 
    ON customer(deleted_flag, updated_at);

-- ============================================
-- 制約
-- ============================================

-- 顧客IDフォーマットチェック（C + 9桁数字）
ALTER TABLE customer
    ADD CONSTRAINT chk_customer_id_format
    CHECK (customer_id ~ '^C[0-9]{9}$');

-- 電話番号フォーマットチェック（ハイフンあり、10-13桁）
ALTER TABLE customer
    ADD CONSTRAINT chk_phone_format
    CHECK (phone IS NULL OR phone ~ '^[0-9]{2,4}-[0-9]{2,4}-[0-9]{4}$');

-- メールアドレスフォーマットチェック
ALTER TABLE customer
    ADD CONSTRAINT chk_email_format
    CHECK (email IS NULL OR email ~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$');

-- 性別の値チェック
ALTER TABLE customer
    ADD CONSTRAINT chk_gender
    CHECK (gender IS NULL OR gender IN ('男性', '女性', 'その他', '回答しない'));

-- 顧客ランクの値チェック
ALTER TABLE customer
    ADD CONSTRAINT chk_customer_rank
    CHECK (customer_rank IN ('PLATINUM', 'GOLD', 'SILVER', 'BRONZE'));

-- ============================================
-- トリガー
-- ============================================

-- 更新日時自動更新トリガー
CREATE OR REPLACE FUNCTION update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    NEW.version = OLD.version + 1;  -- 楽観的ロック用
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_customer_update
    BEFORE UPDATE ON customer
    FOR EACH ROW
    EXECUTE FUNCTION update_timestamp();

-- ============================================
-- パーティショニング設計
-- ============================================

-- 当初はパーティション不要
-- データ量が500万件を超えた場合、以下を検討：
-- - created_atでレンジパーティション（年単位）
-- - 古いデータは別テーブルにアーカイブ

-- 例（将来の参考）:
-- CREATE TABLE customer_2026 PARTITION OF customer
--     FOR VALUES FROM ('2026-01-01') TO ('2027-01-01');
```

**インデックス設計の詳細：**

| インデックス名 | カラム | タイプ | 用途 | カーディナリティ | サイズ見積 |
|-------------|--------|--------|------|----------------|----------|
| pk_customer | customer_id | PRIMARY KEY | 主キー検索 | 高（100万） | 20MB |
| idx_customer_name | customer_name | BTREE | 顧客名検索 | 高（80万） | 15MB |
| idx_customer_name_kana | customer_name_kana | BTREE | カナ検索・ソート | 高（80万） | 15MB |
| idx_phone | phone | BTREE | 電話番号検索 | 高（70万） | 12MB |
| idx_email | email | UNIQUE BTREE | メール検索 | 高（50万） | 10MB |
| idx_created_at | created_at | BTREE | 登録日範囲検索 | 中（365） | 5MB |
| idx_deleted_updated | deleted_flag, updated_at | BTREE | 有効データ抽出 | 低（2） | 8MB |

**合計インデックスサイズ：** 約85MB（データ100万件時）

**パフォーマンスチューニング：**

```sql
-- ============================================
-- 統計情報更新
-- ============================================

-- 定期的に実行（毎日深夜）
ANALYZE customer;

-- ============================================
-- バキューム（不要領域回収）
-- ============================================

-- 週次で実行
VACUUM ANALYZE customer;

-- ============================================
-- スロークエリの確認
-- ============================================

-- 実行計画確認
EXPLAIN ANALYZE
SELECT * FROM customer
WHERE customer_name LIKE '%山田%'
AND deleted_flag = FALSE;

-- インデックスの使用状況確認
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE tablename = 'customer'
ORDER BY idx_scan DESC;
```

#### ④API詳細設計

**リクエスト/レスポンスの詳細定義：**

##### 顧客検索API

**エンドポイント：** `GET /api/v1/customers/search`

**リクエストパラメータ（Query String）：**

| パラメータ名 | 型 | 必須 | 説明 | 例 | バリデーション |
|------------|----|----|------|---|--------------|
| customerName | string | No | 顧客名（部分一致） | 山田 | 1-100文字 |
| phone | string | No | 電話番号（完全一致） | 090-1234-5678 | 電話番号形式 |
| email | string | No | メール（完全一致） | <test@example.com> | メール形式 |
| limit | integer | No | 取得件数 | 50 | 1-100、デフォルト100 |
| offset | integer | No | オフセット | 0 | 0以上、デフォルト0 |
| sortBy | string | No | ソートキー | customerName | customerName/createdAt |
| sortOrder | string | No | ソート順 | asc | asc/desc、デフォルトasc |

**リクエスト例：**

```http
GET /api/v1/customers/search?customerName=山田&limit=20&offset=0 HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Accept: application/json
```

**レスポンス（成功時）：**

```json
{
  "status": "success",
  "data": {
    "customers": [
      {
        "customerId": "C000000001",
        "customerName": "山田太郎",
        "customerNameKana": "ヤマダタロウ",
        "phone": "090-1234-5678",
        "email": "yamada@example.com",
        "address": "東京都渋谷区...",
        "customerRank": "GOLD",
        "lastInquiryDate": "2026-03-15T10:30:00Z",
        "inquiryCount": 5,
        "createdAt": "2025-01-10T09:00:00Z"
      },
      {
        "customerId": "C000000123",
        "customerName": "山田花子",
        "customerNameKana": "ヤマダハナコ",
        "phone": "080-9876-5432",
        "email": "hanako@example.com",
        "address": "大阪府大阪市...",
        "customerRank": "SILVER",
        "lastInquiryDate": "2026-03-10T14:20:00Z",
        "inquiryCount": 3,
        "createdAt": "2025-02-20T11:30:00Z"
      }
    ],
    "pagination": {
      "total": 12,
      "limit": 20,
      "offset": 0,
      "hasMore": false
    }
  },
  "meta": {
    "requestId": "req-abc123",
    "timestamp": "2026-03-20T12:00:00Z",
    "responseTime": 234
  }
}
```

**レスポンス（エラー時）：**

```json
{
  "status": "error",
  "error": {
    "code": "E0001",
    "message": "検索条件を指定してください",
    "details": [
      {
        "field": "customerName",
        "message": "顧客名、電話番号、メールアドレスのいずれかを指定してください"
      }
    ]
  },
  "meta": {
    "requestId": "req-def456",
    "timestamp": "2026-03-20T12:00:00Z",
    "path": "/api/v1/customers/search"
  }
}
```

**HTTPステータスコード：**

| コード | 意味 | 使用場面 |
|-------|------|---------|
| 200 | OK | 正常終了（結果0件でも200） |
| 400 | Bad Request | リクエストパラメータ不正 |
| 401 | Unauthorized | 認証エラー（JWTが無効） |
| 403 | Forbidden | 権限エラー |
| 429 | Too Many Requests | レート制限超過 |
| 500 | Internal Server Error | サーバー内部エラー |
| 503 | Service Unavailable | メンテナンス中 |

**エラーコード体系：**

| コード範囲 | カテゴリ | 例 |
|----------|---------|---|
| E0001-E0999 | バリデーションエラー | E0001: 必須パラメータなし |
| E1001-E1999 | ビジネスロジックエラー | E1001: 顧客が存在しない |
| E2001-E2999 | 認証・認可エラー | E2001: トークン期限切れ |
| E3001-E3999 | 外部連携エラー | E3001: System A接続エラー |
| E9001-E9999 | システムエラー | E9001: データベース接続エラー |

#### ⑤エラーハンドリング設計

**例外クラス階層：**

```mermaid
classDiagram
    class RuntimeException {
        <<Java標準>>
    }
    
    class ApplicationException {
        -String errorCode
        -String message
        -Object[] args
        +ApplicationException(errorCode, message)
        +String getErrorCode()
    }
    
    class ValidationException {
        -List~FieldError~ fieldErrors
        +ValidationException(message)
        +addFieldError(field, message)
    }
    
    class BusinessException {
        +BusinessException(errorCode, message)
    }
    
    class SystemException {
        -Throwable cause
        +SystemException(message, cause)
    }
    
    class IntegrationException {
        -String externalSystem
        +IntegrationException(system, message)
    }
    
    RuntimeException <|-- ApplicationException
    ApplicationException <|-- ValidationException
    ApplicationException <|-- BusinessException
    ApplicationException <|-- SystemException
    ApplicationException <|-- IntegrationException
```

**グローバル例外ハンドラー：**

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    private static final Logger logger = LoggerFactory.getLogger(
        GlobalExceptionHandler.class
    );
    
    /**
     * バリデーションエラー
     */
    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(
        ValidationException ex,
        HttpServletRequest request
    ) {
        logger.warn("Validation error: {}", ex.getMessage());
        
        ErrorResponse response = ErrorResponse.builder()
            .status("error")
            .error(Error.builder()
                .code(ex.getErrorCode())
                .message(ex.getMessage())
                .details(ex.getFieldErrors())
                .build())
            .meta(Meta.builder()
                .requestId(request.getAttribute("requestId"))
                .timestamp(LocalDateTime.now())
                .path(request.getRequestURI())
                .build())
            .build();
        
        return ResponseEntity
            .status(HttpStatus.BAD_REQUEST)
            .body(response);
    }
    
    /**
     * ビジネスロジックエラー
     */
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(
        BusinessException ex,
        HttpServletRequest request
    ) {
        logger.warn("Business error: code={}, message={}", 
                    ex.getErrorCode(), ex.getMessage());
        
        ErrorResponse response = ErrorResponse.builder()
            .status("error")
            .error(Error.builder()
                .code(ex.getErrorCode())
                .message(ex.getMessage())
                .build())
            .meta(Meta.builder()
                .requestId(request.getAttribute("requestId"))
                .timestamp(LocalDateTime.now())
                .path(request.getRequestURI())
                .build())
            .build();
        
        return ResponseEntity
            .status(HttpStatus.BAD_REQUEST)
            .body(response);
    }
    
    /**
     * システムエラー
     */
    @ExceptionHandler(SystemException.class)
    public ResponseEntity<ErrorResponse> handleSystemException(
        SystemException ex,
        HttpServletRequest request
    ) {
        logger.error("System error", ex);
        
        // 本番環境では詳細なエラーメッセージを隠す
        String message = isProduction() 
            ? "システムエラーが発生しました。しばらく経ってから再度お試しください。"
            : ex.getMessage();
        
        ErrorResponse response = ErrorResponse.builder()
            .status("error")
            .error(Error.builder()
                .code("E9999")
                .message(message)
                .build())
            .meta(Meta.builder()
                .requestId(request.getAttribute("requestId"))
                .timestamp(LocalDateTime.now())
                .path(request.getRequestURI())
                .build())
            .build();
        
        return ResponseEntity
            .status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(response);
    }
    
    /**
     * 予期しないエラー
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleUnexpectedException(
        Exception ex,
        HttpServletRequest request
    ) {
        logger.error("Unexpected error", ex);
        
        ErrorResponse response = ErrorResponse.builder()
            .status("error")
            .error(Error.builder()
                .code("E9999")
                .message("予期しないエラーが発生しました")
                .build())
            .meta(Meta.builder()
                .requestId(request.getAttribute("requestId"))
                .timestamp(LocalDateTime.now())
                .path(request.getRequestURI())
                .build())
            .build();
        
        return ResponseEntity
            .status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(response);
    }
    
    private boolean isProduction() {
        String profile = System.getProperty("spring.profiles.active");
        return "production".equals(profile);
    }
}
```

#### ⑥単体テスト設計

**テストケース設計書：**

**対象：** CustomerService.searchCustomer() メソッド

| TestID | テスト種別 | テスト内容 | 入力 | 期待結果 | 優先度 |
|--------|----------|----------|------|---------|--------|
| UT-CS-001 | 正常系 | 顧客名で検索成功 | name="山田" | 該当顧客が返される | High |
| UT-CS-002 | 正常系 | 電話番号で検索成功 | phone="090-1234-5678" | 該当顧客が返される | High |
| UT-CS-003 | 正常系 | 複数条件AND検索 | name="山田", phone="090-*" | AND条件で検索される | High |
| UT-CS-004 | 正常系 | 検索結果0件 | name="存在しない名前" | 空リストが返される | Medium |
| UT-CS-005 | 正常系 | 検索結果100件超 | name="a" | 100件に制限される | High |
| UT-CS-006 | 正常系 | キャッシュHit | 2回目の同一検索 | キャッシュから取得 | High |
| UT-CS-007 | 異常系 | 検索条件なし | 空のCriteria | ValidationException | High |
| UT-CS-008 | 異常系 | 不正な電話番号 | phone="abc" | ValidationException | Medium |
| UT-CS-009 | 異常系 | DB接続エラー | - | SystemException | High |
| UT-CS-010 | 異常系 | タイムアウト | 重いクエリ | SystemException | Medium |
| UT-CS-011 | 境界値 | 検索条件の最大長 | name=100文字 | 正常に検索される | Medium |
| UT-CS-012 | 境界値 | 検索条件の最小長 | name=1文字 | 正常に検索される | Low |
| UT-CS-013 | セキュリティ | SQLインジェクション | name="' OR '1'='1" | エスケープされて安全 | High |

**テストコード例：**

```java
@ExtendWith(MockitoExtension.class)
class CustomerServiceTest {
    
    @Mock
    private CustomerRepository customerRepository;
    
    @Mock
    private SystemAIntegration systemAIntegration;
    
    @Mock
    private SystemBIntegration systemBIntegration;
    
    @Mock
    private RedisTemplate<String, List<Customer>> redisTemplate;
    
    @Mock
    private ValueOperations<String, List<Customer>> valueOperations;
    
    @InjectMocks
    private CustomerService customerService;
    
    @BeforeEach
    void setUp() {
        // Redisのモック設定
        when(redisTemplate.opsForValue()).thenReturn(valueOperations);
    }
    
    /**
     * UT-CS-001: 顧客名で検索成功
     */
    @Test
    @DisplayName("顧客名で検索成功")
    void testSearchCustomer_ByName_Success() {
        // Arrange（準備）
        CustomerSearchCriteria criteria = new CustomerSearchCriteria();
        criteria.setCustomerName("山田");
        
        List<Customer> mockCustomers = Arrays.asList(
            createCustomer("C000000001", "山田太郎"),
            createCustomer("C000000002", "山田花子")
        );
        
        when(valueOperations.get(anyString())).thenReturn(null); // キャッシュなし
        when(customerRepository.findByCriteria(criteria)).thenReturn(mockCustomers);
        
        // Act（実行）
        List<Customer> result = customerService.searchCustomer(criteria);
        
        // Assert（検証）
        assertNotNull(result);
        assertEquals(2, result.size());
        assertEquals("山田太郎", result.get(0).getCustomerName());
        assertEquals("山田花子", result.get(1).getCustomerName());
        
        // モックの呼び出し確認
        verify(customerRepository, times(1)).findByCriteria(criteria);
        verify(valueOperations, times(1)).set(anyString(), eq(result), eq(300L), eq(TimeUnit.SECONDS));
    }
    
    /**
     * UT-CS-004: 検索結果0件
     */
    @Test
    @DisplayName("検索結果0件の場合、空リストが返される")
    void testSearchCustomer_NoResult() {
        // Arrange
        CustomerSearchCriteria criteria = new CustomerSearchCriteria();
        criteria.setCustomerName("存在しない名前");
        
        when(valueOperations.get(anyString())).thenReturn(null);
        when(customerRepository.findByCriteria(criteria))
            .thenReturn(Collections.emptyList());
        
        // Act
        List<Customer> result = customerService.searchCustomer(criteria);
        
        // Assert
        assertNotNull(result);
        assertTrue(result.isEmpty());
    }
    
    /**
     * UT-CS-005: 検索結果100件超
     */
    @Test
    @DisplayName("検索結果が100件を超える場合、100件に制限される")
    void testSearchCustomer_ExceedsLimit() {
        // Arrange
        CustomerSearchCriteria criteria = new CustomerSearchCriteria();
        criteria.setCustomerName("a");
        
        List<Customer> mockCustomers = IntStream.rangeClosed(1, 150)
            .mapToObj(i -> createCustomer("C" + String.format("%09d", i), "Customer" + i))
            .collect(Collectors.toList());
        
        when(valueOperations.get(anyString())).thenReturn(null);
        when(customerRepository.findByCriteria(criteria)).thenReturn(mockCustomers);
        
        // Act
        List<Customer> result = customerService.searchCustomer(criteria);
        
        // Assert
        assertEquals(100, result.size());
    }
    
    /**
     * UT-CS-006: キャッシュHit
     */
    @Test
    @DisplayName("キャッシュがヒットした場合、キャッシュから取得する")
    void testSearchCustomer_CacheHit() {
        // Arrange
        CustomerSearchCriteria criteria = new CustomerSearchCriteria();
        criteria.setCustomerName("山田");
        
        List<Customer> cachedCustomers = Arrays.asList(
            createCustomer("C000000001", "山田太郎")
        );
        
        when(valueOperations.get(anyString())).thenReturn(cachedCustomers);
        
        // Act
        List<Customer> result = customerService.searchCustomer(criteria);
        
        // Assert
        assertEquals(cachedCustomers, result);
        
        // リポジトリは呼ばれない
        verify(customerRepository, never()).findByCriteria(any());
    }
    
    /**
     * UT-CS-007: 検索条件なし
     */
    @Test
    @DisplayName("検索条件がない場合、ValidationExceptionがスローされる")
    void testSearchCustomer_EmptyCriteria() {
        // Arrange
        CustomerSearchCriteria criteria = new CustomerSearchCriteria();
        
        // Act & Assert
        ValidationException exception = assertThrows(
            ValidationException.class,
            () -> customerService.searchCustomer(criteria)
        );
        
        assertEquals("検索条件を指定してください", exception.getMessage());
    }
    
    /**
     * UT-CS-009: DB接続エラー
     */
    @Test
    @DisplayName("DB接続エラーが発生した場合、SystemExceptionがスローされる")
    void testSearchCustomer_DatabaseError() {
        // Arrange
        CustomerSearchCriteria criteria = new CustomerSearchCriteria();
        criteria.setCustomerName("山田");
        
        when(valueOperations.get(anyString())).thenReturn(null);
        when(customerRepository.findByCriteria(criteria))
            .thenThrow(new DataAccessException("DB接続エラー") {});
        
        // Act & Assert
        SystemException exception = assertThrows(
            SystemException.class,
            () -> customerService.searchCustomer(criteria)
        );
        
        assertTrue(exception.getMessage().contains("データベース"));
    }
    
    /**
     * UT-CS-013: SQLインジェクション対策
     */
    @Test
    @DisplayName("SQLインジェクションの試行が安全に処理される")
    void testSearchCustomer_SqlInjection() {
        // Arrange
        CustomerSearchCriteria criteria = new CustomerSearchCriteria();
        criteria.setCustomerName("' OR '1'='1");
        
        when(valueOperations.get(anyString())).thenReturn(null);
        when(customerRepository.findByCriteria(criteria))
            .thenReturn(Collections.emptyList());
        
        // Act
        List<Customer> result = customerService.searchCustomer(criteria);
        
        // Assert
        // エラーにならず、安全に空の結果が返される
        assertNotNull(result);
        assertTrue(result.isEmpty());
        
        // PreparedStatementが使われているため安全
        verify(customerRepository, times(1)).findByCriteria(criteria);
    }
    
    // ヘルパーメソッド
    private Customer createCustomer(String id, String name) {
        Customer customer = new Customer();
        customer.setCustomerId(id);
        customer.setCustomerName(name);
        customer.setPhone("090-1234-5678");
        customer.setEmail(name.toLowerCase() + "@example.com");
        customer.setCreatedAt(LocalDateTime.now());
        return customer;
    }
}
```

**テストカバレッジ目標：**

| 対象 | 目標カバレッジ | 測定ツール |
|-----|--------------|-----------|
| 行カバレッジ | 80%以上 | JaCoCo |
| 分岐カバレッジ | 70%以上 | JaCoCo |
| メソッドカバレッジ | 90%以上 | JaCoCo |

### 📄 作成するドキュメント：詳細設計書

```markdown
# 詳細設計書

**プロジェクト名：** 顧客対応統合システム  
**バージョン：** 1.0  
**作成日：** 2026年4月1日  
**承認日：** 2026年4月30日

## 1. 目的

本書は、基本設計書で定義されたシステム構成とアーキテクチャに基づき、
実装レベルの詳細設計を定義する。

## 2. クラス設計

### 2.1 パッケージ構成

```

com.example.customer
├── controller      # プレゼンテーション層
├── service         # ビジネスロジック層
├── repository      # データアクセス層
├── integration     # 外部連携層
├── model           # ドメインモデル
│   ├── entity      # エンティティ
│   ├── dto         # データ転送オブジェクト
│   └── enums       # 列挙型
├── exception       # 例外クラス
├── validator       # バリデータ
└── util            # ユーティリティ

```

### 2.2 クラス一覧

[前述のクラス図と詳細を参照]

## 3. 処理フロー

### 3.1 シーケンス図

[前述のシーケンス図を参照]

### 3.2 フローチャート

[前述のフローチャートを参照]

## 4. データベース物理設計

### 4.1 物理テーブル定義

[前述のCREATE TABLE文を参照]

### 4.2 インデックス設計

[前述のインデックス定義を参照]

## 5. API詳細仕様

### 5.1 エンドポイント詳細

[前述のAPI詳細を参照]

### 5.2 エラーハンドリング

[前述のエラーハンドリング設計を参照]

## 6. 単体テスト設計

### 6.1 テストケース一覧

[前述のテストケース表を参照]

### 6.2 テストコード

[前述のテストコード例を参照]

## 7. セキュリティ実装詳細

### 7.1 SQLインジェクション対策

**必須事項：**
- PreparedStatementを必ず使用
- ユーザー入力を直接SQLに連結しない
- ORMのパラメータバインディングを使用

### 7.2 XSS対策

**必須事項：**
- ユーザー入力は全てエスケープ
- ReactはデフォルトでXSS対策されているが、
  dangerouslySetInnerHTMLは使用禁止
- Content-Security-Policyヘッダーを設定

### 7.3 CSRF対策

**必須事項：**
- CSRF トークンを使用
- SameSite Cookie属性を設定
- Originヘッダーの検証

## 8. 性能実装詳細

### 8.1 キャッシュ実装

[Redisキャッシュの実装詳細]

### 8.2 コネクションプール設定

```properties
# HikariCP設定
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000
```

## 9. ログ実装詳細

### 9.1 ログ出力方針

[前述のログ設計を参照]

### 9.2 ログ設定（logback.xml）

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>/var/log/app/application.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>/var/log/app/application.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <root level="INFO">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="FILE" />
    </root>
    
    <logger name="com.example.customer" level="DEBUG" />
    <logger name="org.springframework.jdbc" level="DEBUG" />
</configuration>
```

## 10. 変更履歴

| バージョン | 日付 | 変更者 | 変更内容 | 承認者 |
|-----------|------|--------|---------|--------|
| 0.1 | 2026/03/20 | 高橋 | 初稿作成 | - |
| 0.5 | 2026/04/10 | 高橋 | レビュー反映 | - |
| 1.0 | 2026/04/30 | 高橋 | 承認版 | 田中PM |

---
以上

```

### 🎓 このフェーズのまとめ

**✅ やること：**
1. クラス詳細設計（メソッド、属性、処理ロジック）
2. 処理フロー設計（シーケンス図、フローチャート）
3. データベース物理設計（CREATE文、インデックス）
4. API詳細設計（リクエスト/レスポンス詳細）
5. エラーハンドリング設計
6. 単体テスト設計

**📄 作るドキュメント：**
- 詳細設計書
- クラス設計書
- テスト設計書

**⚠️ よくある失敗：**
- 設計が曖昧で実装者が困る
- エラーハンドリングが不統一
- テストが考慮されていない設計
- 性能を考慮していない

**💡 成功のコツ：**
- **実装者が迷わないレベルまで詳細化**
- **コピペで実装できるくらい具体的に**
- **例外パターンも全て洗い出す**
- **テストのしやすさを考慮した設計**
- **コードサンプルを含める**


## 3.5 ⑤実装・開発フェーズ

### 📌 このフェーズの目的

**「実際にコードを書いて、システムを作る」**

家を建てることで例えると：「大工さんが実際に木を組み立て、壁を作り、家を形にしていく段階」

### 🎯 このフェーズで行うこと

```mermaid
graph TD
    A[実装・開発フェーズ] --> B[①環境構築]
    A --> C[②コーディング]
    A --> D[③単体テスト]
    A --> E[④コードレビュー]
    A --> F[⑤リファクタリング]
    A --> G[⑥ドキュメント作成]
    
    B --> B1[開発環境セットアップ]
    B --> B2[ライブラリ導入]
    B --> B3[CI/CD構築]
    
    C --> C1[コーディング規約遵守]
    C --> C2[詳細設計に基づく実装]
    C --> C3[コミット・プッシュ]
    
    D --> D1[テストコード作成]
    D --> D2[テスト実行]
    D --> D3[カバレッジ確認]
    
    E --> E1[プルリクエスト作成]
    E --> E2[レビュー実施]
    E --> E3[指摘事項修正]
    
    F --> F1[コードの整理]
    F --> F2[重複コード削除]
    F --> F3[可読性向上]
    
    G --> G1[ADR作成]
    G --> G2[README更新]
    G --> G3[API仕様書更新]
    
    style A fill:#e1f5fe,stroke:#0277bd,stroke-width:3px
    style B fill:#fff9c4,stroke:#f57f17
    style C fill:#c8e6c9,stroke:#2e7d32
    style D fill:#f3e5f5,stroke:#7b1fa2
    style E fill:#ffcdd2,stroke:#c62828
    style F fill:#e0f2f1,stroke:#00695c
    style G fill:#fce4ec,stroke:#c2185b
```

### 📝 具体的な作業内容

#### ①開発環境構築

**必要なツール・環境：**

| カテゴリ | ツール | バージョン | 用途 |
|---------|--------|----------|------|
| IDE | IntelliJ IDEA | 2024.3 | Java開発 |
| | VS Code | 1.85 | フロントエンド開発 |
| バージョン管理 | Git | 2.43 | ソースコード管理 |
| | GitHub | - | リモートリポジトリ |
| ビルドツール | Maven | 3.9 | Java依存関係管理 |
| | npm | 10.2 | Node.js依存関係管理 |
| データベース | PostgreSQL | 15.5 | ローカルDB |
| | DBeaver | 23.3 | DB管理ツール |
| コンテナ | Docker | 24.0 | ローカル環境構築 |
| | Docker Compose | 2.23 | 複数コンテナ管理 |
| テスト | JUnit | 5.10 | 単体テスト |
| | Mockito | 5.8 | モックフレームワーク |
| 静的解析 | SonarQube | 10.3 | コード品質チェック |
| | Checkstyle | 10.12 | コーディング規約チェック |

**ローカル開発環境セットアップ手順：**

```bash
# 1. リポジトリのクローン
git clone https://github.com/example/customer-system.git
cd customer-system

# 2. Docker Composeで必要なサービスを起動
docker-compose up -d

# 3. バックエンドのビルド
cd backend
mvn clean install

# 4. フロントエンドのビルド
cd ../frontend
npm install
npm run dev

# 5. データベース初期化
cd ../backend
mvn flyway:migrate

# 6. アプリケーション起動
mvn spring-boot:run
```

**docker-compose.yml の例：**

```yaml
version: '3.8'

services:
  # PostgreSQL
  postgres:
    image: postgres:15.5
    container_name: customer-db
    environment:
      POSTGRES_DB: customer_db
      POSTGRES_USER: dbuser
      POSTGRES_PASSWORD: dbpass
    ports:
      - "5432:5432"
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - app-network

  # Redis
  redis:
    image: redis:7.2
    container_name: customer-cache
    ports:
      - "6379:6379"
    networks:
      - app-network

  # SonarQube
  sonarqube:
    image: sonarqube:10.3-community
    container_name: customer-sonarqube
    ports:
      - "9000:9000"
    environment:
      SONAR_JDBC_URL: jdbc:postgresql://postgres:5432/sonarqube
      SONAR_JDBC_USERNAME: dbuser
      SONAR_JDBC_PASSWORD: dbpass
    networks:
      - app-network
    depends_on:
      - postgres

volumes:
  postgres-data:

networks:
  app-network:
    driver: bridge
```

#### ②コーディング

**コーディング規約（Java）：**

基本的に **Google Java Style Guide** に準拠します。

**主要なルール：**

```java
// ✅ 良い例：クラス名はUpperCamelCase
public class CustomerService {
    
    // ✅ 良い例：定数はUPPER_SNAKE_CASE
    private static final int MAX_RETRY_COUNT = 3;
    
    // ✅ 良い例：フィールドはlowerCamelCase
    private CustomerRepository customerRepository;
    
    // ✅ 良い例：メソッド名はlowerCamelCase、動詞で始める
    public List<Customer> searchCustomer(String name) {
        // ✅ 良い例：ローカル変数もlowerCamelCase
        List<Customer> customers = new ArrayList<>();
        
        // ✅ 良い例：インデントは4スペース
        if (name != null && !name.isEmpty()) {
            customers = customerRepository.findByName(name);
        }
        
        return customers;
    }
    
    /**
     * 顧客を取得する
     * 
     * ✅ 良い例：Javadocコメント
     * @param customerId 顧客ID
     * @return 顧客情報
     * @throws CustomerNotFoundException 顧客が見つからない場合
     */
    public Customer getCustomer(String customerId) 
        throws CustomerNotFoundException {
        // 実装
    }
}

// ❌ 悪い例：クラス名が小文字
public class customerservice { }

// ❌ 悪い例：定数が小文字
private static final int maxRetryCount = 3;

// ❌ 悪い例：メソッド名が大文字始まり
public void SearchCustomer() { }
```

**Git コミットメッセージ規約：**

```
<type>(<scope>): <subject>

<body>

<footer>
```

**type の種類：**

- `feat`: 新機能
- `fix`: バグ修正
- `docs`: ドキュメントのみの変更
- `style`: コードの意味に影響しない変更（空白、フォーマット等）
- `refactor`: リファクタリング
- `test`: テストの追加・修正
- `chore`: ビルドプロセスやツールの変更

**コミットメッセージの例：**

```
feat(customer): 顧客検索機能を追加

- 顧客名、電話番号、メールアドレスで検索可能に
- 検索結果は50音順でソート
- 結果が100件を超える場合は制限

Closes #123
```

**ブランチ戦略（Git Flow）：**

```mermaid
gitGraph
    commit id: "Initial"
    branch develop
    checkout develop
    commit id: "Setup"
    
    branch feature/customer-search
    checkout feature/customer-search
    commit id: "Add search API"
    commit id: "Add tests"
    checkout develop
    merge feature/customer-search
    
    branch release/v1.0
    checkout release/v1.0
    commit id: "Bump version"
    commit id: "Update docs"
    
    checkout main
    merge release/v1.0 tag: "v1.0.0"
    
    checkout develop
    merge release/v1.0
    
    branch hotfix/critical-bug
    checkout hotfix/critical-bug
    commit id: "Fix critical bug"
    checkout main
    merge hotfix/critical-bug tag: "v1.0.1"
    checkout develop
    merge hotfix/critical-bug
```

**ブランチの役割：**

| ブランチ | 役割 | 命名規則 | マージ先 |
|---------|------|---------|---------|
| main | 本番リリース版 | main | - |
| develop | 開発中の最新版 | develop | main |
| feature/* | 機能開発 | feature/機能名 | develop |
| release/* | リリース準備 | release/v1.0 | main, develop |
| hotfix/* | 緊急バグ修正 | hotfix/バグ名 | main, develop |

#### ③単体テスト

**単体テストの作成ルール：**

```java
/**
 * テストクラスの命名規則: {対象クラス名}Test
 */
@ExtendWith(MockitoExtension.class)
class CustomerServiceTest {
    
    /**
     * テストメソッドの命名規則:
     * test{メソッド名}_{条件}_{期待結果}
     */
    @Test
    @DisplayName("顧客名で検索成功")  // ← 日本語で分かりやすく
    void testSearchCustomer_WithValidName_ReturnsCustomers() {
        // Arrange（準備）: テストデータとモックの設定
        CustomerSearchCriteria criteria = new CustomerSearchCriteria();
        criteria.setCustomerName("山田");
        
        List<Customer> expected = Arrays.asList(
            new Customer("C001", "山田太郎"),
            new Customer("C002", "山田花子")
        );
        
        when(customerRepository.findByCriteria(criteria))
            .thenReturn(expected);
        
        // Act（実行）: テスト対象メソッドの実行
        List<Customer> actual = customerService.searchCustomer(criteria);
        
        // Assert（検証）: 結果の確認
        assertNotNull(actual);
        assertEquals(2, actual.size());
        assertEquals("山田太郎", actual.get(0).getCustomerName());
        
        // モックの呼び出し確認
        verify(customerRepository, times(1)).findByCriteria(criteria);
    }
    
    /**
     * 異常系テスト
     */
    @Test
    @DisplayName("検索条件なしの場合、ValidationExceptionがスローされる")
    void testSearchCustomer_WithEmptyCriteria_ThrowsException() {
        // Arrange
        CustomerSearchCriteria criteria = new CustomerSearchCriteria();
        
        // Act & Assert
        ValidationException exception = assertThrows(
            ValidationException.class,
            () -> customerService.searchCustomer(criteria)
        );
        
        assertEquals("検索条件を指定してください", exception.getMessage());
    }
}
```

**テストカバレッジの確認：**

```bash
# テスト実行とカバレッジ測定
mvn clean test jacoco:report

# カバレッジレポート確認
open target/site/jacoco/index.html
```

**カバレッジ目標：**

- 行カバレッジ：80%以上
- 分岐カバレッジ：70%以上
- メソッドカバレッジ：90%以上

#### ④コードレビュー

**プルリクエスト（PR）の作成：**

```markdown
## 概要
顧客検索機能を実装しました。

## 変更内容
- CustomerController に searchCustomer API を追加
- CustomerService に検索ロジックを実装
- Redis キャッシュを導入（5分間）
- 単体テストを追加（カバレッジ 85%）

## 関連Issue
Closes #123

## テスト
- ✅ 単体テスト合格
- ✅ 統合テスト合格
- ✅ 手動テスト完了

## スクリーンショット
（画面がある場合は添付）

## チェックリスト
- [x] コーディング規約に準拠している
- [x] 単体テストを追加した
- [x] ドキュメントを更新した
- [x] 静的解析をパスした
- [x] セキュリティチェック済み
```

**レビューのポイント：**

| カテゴリ | チェック項目 |
|---------|------------|
| **機能** | ✓ 要件通りに実装されているか<br/>✓ エッジケースが考慮されているか |
| **可読性** | ✓ 変数名・メソッド名が適切か<br/>✓ コメントが適切か |
| **保守性** | ✓ DRY原則に従っているか<br/>✓ 適切に関数分割されているか |
| **性能** | ✓ 不要なループがないか<br/>✓ N+1問題がないか |
| **セキュリティ** | ✓ SQLインジェクション対策済みか<br/>✓ XSS対策済みか |
| **テスト** | ✓ テストケースは十分か<br/>✓ カバレッジは目標を満たすか |

**レビューコメントの例：**

```
✅ LGTM (Looks Good To Me)
コード品質が高く、問題ありません。

💡 提案
customerNameのバリデーションをControllerではなく、
Validatorクラスに移動した方が再利用しやすいと思います。

❓ 質問
なぜここでキャッシュの有効期限を5分にしたのですか？
根拠があれば教えてください。

🐛 バグの可能性
NullPointerExceptionが発生する可能性があります。
null チェックを追加してください。

🔧 要修正
コーディング規約に違反しています。
メソッド名を lowerCamelCase に修正してください。
```

#### ⑤リファクタリング

**リファクタリングのタイミング：**

```mermaid
graph TD
    A[コード実装] --> B{動作確認}
    B -->|NG| A
    B -->|OK| C{コードレビュー}
    C -->|指摘あり| D[修正]
    D --> C
    C -->|LGTM| E{リファクタリング<br/>必要？}
    E -->|Yes| F[リファクタリング]
    F --> G[テスト実行]
    G --> H{全テスト合格？}
    H -->|NG| F
    H -->|OK| I[マージ]
    E -->|No| I
    
    style I fill:#c8e6c9,stroke:#2e7d32
```

**リファクタリングの例：**

**❌ Before（リファクタリング前）:**

```java
public List<Customer> searchCustomer(String name, String phone, String email) {
    List<Customer> result = new ArrayList<>();
    
    if (name != null && !name.isEmpty()) {
        List<Customer> byName = customerRepository.findByName(name);
        result.addAll(byName);
    }
    
    if (phone != null && !phone.isEmpty()) {
        List<Customer> byPhone = customerRepository.findByPhone(phone);
        for (Customer c : byPhone) {
            if (!result.contains(c)) {
                result.add(c);
            }
        }
    }
    
    if (email != null && !email.isEmpty()) {
        List<Customer> byEmail = customerRepository.findByEmail(email);
        for (Customer c : byEmail) {
            if (!result.contains(c)) {
                result.add(c);
            }
        }
    }
    
    // ソート
    result.sort((a, b) -> {
        Collator collator = Collator.getInstance(Locale.JAPANESE);
        return collator.compare(a.getCustomerName(), b.getCustomerName());
    });
    
    return result;
}
```

**✅ After（リファクタリング後）:**

```java
public List<Customer> searchCustomer(CustomerSearchCriteria criteria) {
    // 1. バリデーション
    validateSearchCriteria(criteria);
    
    // 2. キャッシュ確認
    Optional<List<Customer>> cached = getCachedResult(criteria);
    if (cached.isPresent()) {
        return cached.get();
    }
    
    // 3. 検索実行
    List<Customer> customers = customerRepository.findByCriteria(criteria);
    
    // 4. ソート
    sortCustomers(customers);
    
    // 5. キャッシュ保存
    cacheResult(criteria, customers);
    
    return customers;
}

private void validateSearchCriteria(CustomerSearchCriteria criteria) {
    if (criteria.isEmpty()) {
        throw new ValidationException("検索条件を指定してください");
    }
}

private Optional<List<Customer>> getCachedResult(CustomerSearchCriteria criteria) {
    String cacheKey = generateCacheKey(criteria);
    return Optional.ofNullable(redisTemplate.opsForValue().get(cacheKey));
}

private void sortCustomers(List<Customer> customers) {
    Collator collator = Collator.getInstance(Locale.JAPANESE);
    customers.sort((a, b) -> 
        collator.compare(a.getCustomerName(), b.getCustomerName())
    );
}

private void cacheResult(CustomerSearchCriteria criteria, List<Customer> customers) {
    String cacheKey = generateCacheKey(criteria);
    redisTemplate.opsForValue().set(cacheKey, customers, CACHE_TTL, TimeUnit.SECONDS);
}
```

**改善ポイント：**

1. メソッドを適切な大きさに分割（単一責任の原則）
2. 検索条件をオブジェクトにまとめた
3. キャッシュ機能を追加
4. 各ステップが明確になった
5. テストしやすくなった

#### ⑥ドキュメント作成

**ADR（Architecture Decision Record）の作成：**

重要な設計判断は ADR として記録します。

```markdown
# ADR-001: 顧客検索結果のキャッシュにRedisを使用

**ステータス:** 採用

**日付:** 2026-04-15

**決定者:** 高橋（開発リーダー）、田中（PM）

## 背景（Context）

顧客検索APIのレスポンスタイムが要件（3秒以内）を満たさない
ケースがあった。特に、外部システムからの追加情報取得に
時間がかかっている（1件あたり200ms × 複数件）。

## 決定内容（Decision）

検索結果をRedisでキャッシュする。

**キャッシュ仕様：**
- 有効期限：5分
- キャッシュキー：検索条件をハッシュ化
- 更新タイミング：顧客情報更新時にキャッシュクリア

## 理由（Rationale）

**Redisを選んだ理由：**
1. 高速（メモリベース、0.1ms以下のレスポンス）
2. AWS ElastiCache で簡単に導入可能
3. キー・バリュー型で用途に合う
4. TTL（有効期限）機能が標準装備
5. チーム内に運用実績あり

**他の選択肢との比較：**

| 選択肢 | メリット | デメリット | 評価 |
|-------|---------|----------|------|
| Redis | 高速、簡単、実績あり | 追加コスト | ◎ |
| アプリ内キャッシュ | コスト不要 | スケール困難 | △ |
| DB物理化 | 永続化 | 複雑、遅い | × |

## 影響（Consequences）

**ポジティブ：**
- ✅ レスポンスタイム：2秒 → 0.5秒（75%改善）
- ✅ 外部API呼び出し削減：90%削減
- ✅ ユーザー体験の向上

**ネガティブ：**
- ❌ インフラコストの増加：月額5,000円
- ❌ キャッシュの整合性管理が必要
- ❌ Redis障害時の対応が必要

**リスクと対策：**
- リスク：Redisダウン時にサービス停止
- 対策：Redis障害時はキャッシュをスキップして直接DB検索

## 参考資料

- [Redis公式ドキュメント](https://redis.io/docs/)
- [AWS ElastiCache](https://aws.amazon.com/elasticache/)
- 性能テスト結果：`/docs/performance-test-result.md`

## 将来の見直し

以下の場合、この決定を再検討する：
- 月間コストが10万円を超えた場合
- データ整合性の問題が頻発した場合
- より良い代替技術が登場した場合
```

### 📄 作成するドキュメント：実装関連

| ドキュメント | 内容 | 担当 |
|-----------|------|------|
| ソースコード | 実際のプログラム | 開発者 |
| ADR | 設計判断の記録 | 開発リーダー |
| README.md | プロジェクト概要、セットアップ手順 | 開発リーダー |
| API仕様書 | 実装したAPIの詳細 | 開発者 |
| 単体テスト結果 | テスト実行結果、カバレッジ | 開発者 |

### 🎓 このフェーズのまとめ

**✅ やること：**

1. 開発環境構築
2. コーディング規約に従った実装
3. 単体テストの作成と実行
4. コードレビュー
5. リファクタリング
6. ADR等のドキュメント作成

**📄 作るドキュメント：**

- ソースコード
- ADR（設計決定記録）
- README.md
- テスト結果レポート

**⚠️ よくある失敗：**

- コーディング規約を守らない
- テストを後回しにする
- コードレビューをおざなりにする
- ドキュメントを書かない
- 技術的負債を放置する

**💡 成功のコツ：**

- **TDD（テスト駆動開発）を実践**
- **こまめにコミット**（1機能＝1コミット）
- **レビューは丁寧に**（学びの機会）
- **リファクタリングを恐れない**
- **ADRで設計判断を記録**（将来の自分への財産）

---

## 3.6 ⑥テストフェーズ

### 📌 このフェーズの目的

**「作ったシステムが正しく動くか確認する」**

家を建てることで例えると：「家が完成したら、水道・電気・ガスが全て正常に動くか、建築基準を満たしているか検査する段階」

### 🎯 テストの種類とレベル

```mermaid
graph TD
    A[テストレベル] --> B[①単体テスト<br/>Unit Test]
    A --> C[②結合テスト<br/>Integration Test]
    A --> D[③システムテスト<br/>System Test]
    A --> E[④受入テスト<br/>UAT]
    
    B --> B1[最小単位<br/>メソッド・関数]
    C --> C1[複数モジュール<br/>の組み合わせ]
    D --> D1[システム全体<br/>要件通りか]
    E --> E1[お客様による<br/>最終確認]
    
    A --> F[⑤非機能テスト<br/>Non-Functional Test]
    
    F --> F1[性能テスト]
    F --> F2[セキュリティテスト]
    F --> F3[負荷テスト]
    F --> F4[障害テスト]
    
    style A fill:#ede7f6,stroke:#4527a0,stroke-width:3px
    style B fill:#e1f5fe,stroke:#0277bd
    style C fill:#fff9c4,stroke:#f57f17
    style D fill:#c8e6c9,stroke:#2e7d32
    style E fill:#ffcdd2,stroke:#c62828
    style F fill:#f3e5f5,stroke:#7b1fa2
```

### 📝 各テストの詳細

#### ①単体テスト（Unit Test）

**目的：** 個々のメソッド・関数が正しく動作するか確認

**実施者：** 開発者

**実施時期：** 実装フェーズ（コードを書きながら）

**ツール：** JUnit, Mockito（Java）、Jest（JavaScript）

**カバレッジ目標：** 80%以上

既に実装フェーズで説明済み。

#### ②結合テスト（Integration Test）

**目的：** 複数のモジュールを組み合わせた動作を確認

**実施者：** 開発者・テスター

**実施時期：** 実装完了後

**テストケース例：**

```mermaid
sequenceDiagram
    participant Test as テストコード
    participant Controller as CustomerController
    participant Service as CustomerService
    participant Repo as CustomerRepository
    participant DB as テスト用DB
    
    Test->>Controller: GET /api/v1/customers/search?name=山田
    Controller->>Service: searchCustomer(criteria)
    Service->>Repo: findByCriteria(criteria)
    Repo->>DB: SELECT ...
    DB-->>Repo: ResultSet
    Repo-->>Service: List<Customer>
    Service-->>Controller: List<Customer>
    Controller-->>Test: 200 OK + JSON
    
    Test->>Test: レスポンスを検証
```

**テストコード例（Spring Boot統合テスト）：**

```java
@SpringBootTest
@AutoConfigureMockMvc
@Sql(scripts = "/test-data.sql")  // テストデータ投入
class CustomerControllerIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Test
    @DisplayName("顧客検索API - 正常系")
    void testSearchCustomerAPI_Success() throws Exception {
        // Act & Assert
        mockMvc.perform(
            get("/api/v1/customers/search")
                .param("customerName", "山田")
                .contentType(MediaType.APPLICATION_JSON)
        )
        .andExpect(status().isOk())
        .andExpect(jsonPath("$.status").value("success"))
        .andExpect(jsonPath("$.data.customers").isArray())
        .andExpect(jsonPath("$.data.customers[0].customerName").value("山田太郎"))
        .andExpect(jsonPath("$.data.pagination.total").value(2));
    }
    
    @Test
    @DisplayName("顧客検索API - 検索条件なしエラー")
    void testSearchCustomerAPI_EmptyCriteria() throws Exception {
        mockMvc.perform(
            get("/api/v1/customers/search")
                .contentType(MediaType.APPLICATION_JSON)
        )
        .andExpect(status().isBadRequest())
        .andExpect(jsonPath("$.status").value("error"))
        .andExpect(jsonPath("$.error.code").value("E0001"));
    }
}
```

#### ③システムテスト（System Test）

**目的：** システム全体が要件通りに動作するか確認

**実施者：** テストチーム・QA

**実施時期：** 結合テスト完了後

**テスト観点：**

| No. | テスト観点 | 説明 |
|-----|----------|------|
| 1 | 機能テスト | 要件定義書の全機能が実装されているか |
| 2 | 画面遷移テスト | 画面遷移が設計通りか |
| 3 | データフローテスト | データが正しく流れるか |
| 4 | エラーハンドリング | エラーが適切に処理されるか |
| 5 | 操作性テスト | 使いやすさ、分かりやすさ |
| 6 | ブラウザ互換性 | 各ブラウザで正常動作するか |

**システムテストケースの例：**

| TestID | テストシナリオ | 手順 | 期待結果 | 実施日 | 結果 |
|--------|-------------|------|---------|--------|------|
| ST-001 | ログイン→顧客検索→詳細表示 | 1) ログイン<br/>2) 顧客名「山田」で検索<br/>3) 1件目をクリック | 詳細画面が表示される | 2026/05/15 | ✅ Pass |
| ST-002 | 対応履歴登録 | 1) 顧客詳細画面を開く<br/>2) 「対応履歴登録」ボタン<br/>3) 内容を入力して登録 | 登録完了メッセージが表示される | 2026/05/15 | ✅ Pass |
| ST-003 | 100件超の検索結果 | 1) 検索条件「a」で検索 | 100件表示され、警告メッセージが出る | 2026/05/16 | ✅ Pass |
| ST-004 | セッションタイムアウト | 1) ログイン<br/>2) 30分放置<br/>3) 操作する | ログイン画面に遷移する | 2026/05/16 | ❌ Fail |

#### ④受入テスト（UAT: User Acceptance Test）

**目的：** お客様（発注者）が要求通りか最終確認

**実施者：** お客様、業務担当者

**実施時期：** システムテスト合格後

**実施場所：** お客様の環境（または本番相当の環境）

**受入テストシナリオの例：**

```markdown
# 受入テストシナリオ

## シナリオ1: 日常的な顧客対応業務

**目的:** 通常の顧客対応フローが問題なく実施できることを確認

**実施者:** カスタマーサポート担当（鈴木）

**手順:**

1. **ログイン**
   - ID: suzuki@example.com
   - パスワード: (お客様が設定)
   - ワンタイムパスワード入力
   - **確認:** ホーム画面が表示される ✓

2. **顧客検索**
   - 「顧客検索」メニューをクリック
   - 顧客名に「田中」を入力
   - 検索ボタンをクリック
   - **確認:** 3秒以内に検索結果が表示される ✓
   - **確認:** 該当する顧客が50音順で表示される ✓

3. **顧客詳細確認**
   - 1件目の顧客をクリック
   - **確認:** 顧客の基本情報が表示される ✓
   - **確認:** 過去の対応履歴が表示される ✓
   - **確認:** 購買履歴が表示される ✓

4. **対応履歴登録**
   - 「対応履歴登録」ボタンをクリック
   - 問い合わせ内容を入力
   - 対応内容を入力
   - カテゴリを選択
   - 登録ボタンをクリック
   - **確認:** 「登録しました」メッセージが表示される ✓
   - **確認:** 対応履歴一覧に追加される ✓

5. **ログアウト**
   - 右上のログアウトボタンをクリック
   - **確認:** ログイン画面に戻る ✓

**結果:** ✅ 合格

**コメント:** 
スムーズに操作でき、現在の業務フローと同等以上の速さで
対応できることを確認しました。特に、検索結果が1秒未満で
表示されるのは、現行システムの10倍以上速く、非常に満足です。
```

#### ⑤性能テスト（Performance Test）

**目的:** レスポンスタイム、スループットなどが要件を満たすか確認

**ツール:** Apache JMeter, Gatling, k6

**テストシナリオ例：**

```mermaid
graph LR
    A[性能テスト] --> B[レスポンスタイムテスト]
    A --> C[負荷テスト]
    A --> D[ストレステスト]
    A --> E[スパイクテスト]
    A --> F[耐久テスト]
    
    B --> B1[単一リクエストの<br/>応答時間]
    C --> C1[同時100ユーザー<br/>での動作]
    D --> D1[限界まで負荷を<br/>上げる]
    E --> E1[急激な負荷増加<br/>への対応]
    F --> F1[長時間運用での<br/>メモリリーク確認]
    
    style A fill:#fff9c4,stroke:#f57f17,stroke-width:2px
```

**JMeterテスト計画例：**

```
テスト計画: 顧客検索API性能テスト

1. スレッドグループ
   - ユーザー数: 100
   - ランプアップ期間: 10秒
   - ループ回数: 10回

2. HTTPリクエスト
   - サーバー: api.example.com
   - パス: /api/v1/customers/search
   - パラメータ: customerName=山田

3. レスポンスアサーション
   - ステータスコード: 200
   - レスポンスタイム: < 3000ms

4. 結果ツリー
   - 成功率: 99%以上
   - 平均レスポンスタイム: < 1000ms
   - 95パーセンタイル: < 3000ms
```

**性能テスト結果の例：**

| 項目 | 要件 | 実測値 | 判定 |
|-----|------|--------|------|
| 平均レスポンスタイム | - | 856ms | ✅ |
| 95パーセンタイル | 3000ms以下 | 2,134ms | ✅ Pass |
| 99パーセンタイル | - | 2,987ms | ✅ |
| 最大レスポンスタイム | - | 3,521ms | ⚠️ |
| エラー率 | 1%以下 | 0.2% | ✅ Pass |
| スループット | 100req/s | 112req/s | ✅ Pass |

#### ⑥セキュリティテスト

**目的:** セキュリティの脆弱性がないか確認

**実施者:** セキュリティ専門家、外部診断業者

**テスト項目：**

| No. | テスト項目 | 確認内容 | ツール |
|-----|----------|---------|--------|
| 1 | SQLインジェクション | 不正なSQLが実行されないか | OWASP ZAP |
| 2 | XSS | スクリプトが実行されないか | OWASP ZAP |
| 3 | CSRF | 意図しない操作が実行されないか | Burp Suite |
| 4 | 認証・認可 | 不正アクセスが防げるか | 手動テスト |
| 5 | セッション管理 | セッションハイジャック対策 | 手動テスト |
| 6 | 暗号化 | 通信・保存データの暗号化 | SSL Labs |
| 7 | エラー情報漏洩 | 詳細なエラーが表示されないか | 手動テスト |
| 8 | ファイルアップロード | 悪意あるファイルの実行防止 | 手動テスト |
| 9 | レート制限 | DoS攻撃への対策 | Apache Bench |
| 10 | 依存ライブラリ | 既知の脆弱性がないか | OWASP Dependency Check |

**セキュリティテスト結果の例：**

```markdown
# セキュリティ診断結果報告書

**実施日:** 2026年5月20日  
**実施者:** ○○セキュリティ株式会社  
**対象:** 顧客対応統合システム

## エグゼクティブサマリー

- 検出された脆弱性: 5件
  - 高: 0件
  - 中: 2件
  - 低: 3件
- 総合評価: B（良好）

## 検出された脆弱性

### 1. セッションタイムアウト時間が長い（中）

**リスク:** セッションハイジャックのリスク

**現状:** 120分

**推奨:** 30分以内

**対応:** 設定を30分に変更 ✅ 対応済み

### 2. X-Frame-Optionsヘッダー未設定（中）

**リスク:** クリックジャッキング攻撃

**推奨:** `X-Frame-Options: DENY` を設定

**対応:** ヘッダー追加 ✅ 対応済み

### 3. その他の軽微な指摘（低）...

## 総評

OWASP Top 10の主要な脆弱性には対策が施されており、
セキュリティレベルは良好です。指摘事項への対応後、
本番リリース可能と判断します。
```

### 📄 作成するドキュメント：テスト関連

| ドキュメント | 内容 | 担当 |
|-----------|------|------|
| テスト計画書 | テスト方針、スケジュール、体制 | テストリーダー |
| テスト仕様書 | 具体的なテストケース | テスター |
| テスト実施記録 | テスト実施日時、結果 | テスター |
| バグ管理表 | 発見されたバグの一覧と状況 | テスター |
| テスト完了報告書 | 最終的なテスト結果のまとめ | テストリーダー |

### 🎓 このフェーズのまとめ

**✅ やること：**

1. 単体テスト（開発中）
2. 結合テスト（モジュール間の動作確認）
3. システムテスト（全体の動作確認）
4. 受入テスト（お客様による最終確認）
5. 性能テスト（レスポンスタイム、負荷）
6. セキュリティテスト（脆弱性診断）

**📄 作るドキュメント：**

- テスト計画書
- テスト仕様書（ケース一覧）
- テスト実施記録
- バグ管理表
- テスト完了報告書

**⚠️ よくある失敗：**

- テストケースが不十分
- 非機能テストを軽視
- バグ修正の確認テスト漏れ
- 本番環境とテスト環境の差異
- お客様の受入テスト期間が短すぎる

**💡 成功のコツ：**

- **早い段階からテストを開始**
- **自動化できるテストは自動化**
- **バグは優先度を付けて管理**
- **お客様と一緒にテスト**（UAT重要）
- **セキュリティ診断は専門家に依頼**

## 3.7 ⑦リリース・展開フェーズ

### 📌 このフェーズの目的

**「完成したシステムを本番環境に公開する」**

家を建てることで例えると：「完成した家の鍵を引き渡し、実際に住み始める段階」

### 🎯 このフェーズで行うこと

```mermaid
graph TD
    A[リリースフェーズ] --> B[①リリース準備]
    A --> C[②本番環境構築]
    A --> D[③データ移行]
    A --> E[④本番デプロイ]
    A --> F[⑤リリース後確認]
    A --> G[⑥ユーザー教育]
    
    B --> B1[リリースノート作成]
    B --> B2[ロールバック計画]
    B --> B3[影響範囲確認]
    
    C --> C1[本番サーバー設定]
    C --> C2[ネットワーク設定]
    C --> C3[セキュリティ設定]
    
    D --> D1[マスタデータ移行]
    D --> D2[トランザクションデータ移行]
    D --> D3[データ検証]
    
    E --> E1[Blue/Greenデプロイ]
    E --> E2[スモークテスト]
    E --> E3[本番切り替え]
    
    F --> F1[疎通確認]
    F --> F2[性能確認]
    F --> F3[監視設定確認]
    
    G --> G1[ユーザーマニュアル配布]
    G --> G2[操作説明会開催]
    G --> G3[Q&Aセッション]
    
    style A fill:#fce4ec,stroke:#c2185b,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#fff9c4,stroke:#f57f17
    style D fill:#ffcdd2,stroke:#c62828
    style E fill:#c8e6c9,stroke:#2e7d32
    style F fill:#e1f5fe,stroke:#0277bd
    style G fill:#f3e5f5,stroke:#7b1fa2
```

### 📝 具体的な作業内容

#### ①リリース準備

**リリースチェックリスト：**

```markdown
# リリースチェックリスト

## コード品質
- [x] 全テスト合格（単体・統合・システム）
- [x] コードレビュー完了
- [x] 静的解析合格（SonarQube）
- [x] セキュリティ診断合格
- [x] 性能テスト合格

## ドキュメント
- [x] リリースノート作成
- [x] ユーザーマニュアル作成
- [x] 運用手順書作成
- [x] ロールバック手順書作成
- [x] 障害対応手順書作成

## インフラ
- [x] 本番環境構築完了
- [x] データベース準備完了
- [x] バックアップ設定完了
- [x] 監視設定完了
- [x] アラート設定完了

## データ
- [x] マスタデータ移行計画作成
- [x] データ移行リハーサル実施
- [x] データ検証手順確認

## 承認
- [x] PM承認
- [x] お客様承認
- [x] セキュリティ部門承認
- [x] インフラ部門承認

## リスク対策
- [x] ロールバック手順確認
- [x] 緊急連絡先一覧作成
- [x] エスカレーションフロー確認
- [x] 障害対応体制確認
```

**リリースノート（Release Note）の例：**

```markdown
# リリースノート v1.0.0

**リリース日:** 2026年6月30日  
**対象システム:** 顧客対応統合システム

## 📢 概要

顧客対応業務の効率化を目的とした新システムをリリースします。
これまで3つのシステムに分散していた顧客情報を統合し、
一つの画面で全ての情報を確認できるようになります。

## ✨ 新機能

### 顧客検索機能
- 顧客名、電話番号、メールアドレスで検索可能
- 検索結果は3秒以内に表示
- 50音順で自動ソート
- AI による類似顧客の提案機能

### 対応履歴管理
- 対応内容の登録・参照
- 過去の対応履歴を時系列表示
- カテゴリ別の分類・検索
- AI による回答候補の提示

### レポート機能
- 月次レポートの自動生成
- カテゴリ別の統計表示
- 担当者別の対応件数集計
- PDF形式でのエクスポート

## 🔧 改善点

- レスポンスタイムが現行システムの10倍高速化
- 操作手順を30%削減
- モバイル対応（スマートフォン・タブレット）

## 🐛 既知の問題

なし（全てのバグは修正済み）

## 📋 システム要件

### ブラウザ
- Google Chrome 120以降（推奨）
- Microsoft Edge 120以降
- Safari 17以降
- Firefox 121以降

### ネットワーク
- インターネット接続必須
- 推奨帯域: 10Mbps以上

## 🔄 移行スケジュール

| 日時 | 作業内容 |
|------|---------|
| 6/30 01:00-02:00 | データ移行 |
| 6/30 02:00-03:00 | システム切り替え |
| 6/30 03:00-04:00 | 動作確認 |
| 6/30 09:00- | 本番運用開始 |

**注意:** 01:00-04:00は現行システムが利用できません。

## 📚 ドキュメント

- [ユーザーマニュアル](https://docs.example.com/manual)
- [FAQ](https://docs.example.com/faq)
- [操作説明動画](https://video.example.com/tutorial)

## 🆘 サポート

問題が発生した場合は、以下にご連絡ください：

- **サポートデスク:** support@example.com
- **電話:** 03-1234-5678（24時間対応）
- **チャット:** システム内のヘルプボタン

## 📝 変更履歴

| バージョン | 日付 | 変更内容 |
|-----------|------|---------|
| 1.0.0 | 2026/06/30 | 初回リリース |
```

#### ②本番環境構築

**本番環境チェックリスト：**

```markdown
# 本番環境構築チェックリスト

## インフラ
- [x] EC2インスタンス起動（Web/APサーバー × 2台）
- [x] RDSインスタンス起動（PostgreSQL Multi-AZ）
- [x] ElastiCache起動（Redis）
- [x] S3バケット作成
- [x] CloudFront設定
- [x] Route 53 DNS設定

## ネットワーク
- [x] VPC作成
- [x] サブネット作成（Public × 2、Private × 2、DB × 2）
- [x] Internet Gateway設定
- [x] NAT Gateway設定
- [x] Security Group設定
- [x] NACL設定
- [x] VPN接続設定（オンプレミスとの連携）

## セキュリティ
- [x] SSL証明書取得・設定
- [x] IAMロール設定
- [x] Secrets Manager設定
- [x] CloudTrail有効化
- [x] GuardDuty有効化
- [x] WAF設定

## 監視・ログ
- [x] CloudWatch Alarms設定
- [x] CloudWatch Logs設定
- [x] X-Ray設定（APM）
- [x] アラート通知先設定（Slack、メール）

## バックアップ
- [x] RDS自動バックアップ設定（7日保持）
- [x] S3バケットのバージョニング有効化
- [x] スナップショット手順確認
```

#### ③データ移行

**データ移行計画：**

```mermaid
graph LR
    A[既存システムA] -->|抽出| D[移行ツール]
    B[既存システムB] -->|抽出| D
    C[既存システムC] -->|抽出| D
    
    D -->|変換| E[ステージングDB]
    E -->|検証| F{データ検証}
    
    F -->|NG| G[エラー修正]
    G --> E
    
    F -->|OK| H[本番DB]
    
    style D fill:#fff9c4,stroke:#f57f17
    style E fill:#e1f5fe,stroke:#0277bd
    style H fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
    style F fill:#ffcdd2,stroke:#c62828
```

**データ移行手順書の例：**

```markdown
# データ移行手順書

## 1. 事前準備

### 1.1 バックアップ取得
```bash
# 既存システムのバックアップ
pg_dump -h old-db.example.com -U admin -d customer_db > backup_old.sql

# 新システムの事前バックアップ
pg_dump -h new-db.example.com -U admin -d customer_db > backup_new.sql
```

### 1.2 メンテナンスモード設定

```bash
# 既存システムをメンテナンスモードに
ssh admin@old-system.example.com
sudo systemctl stop application
```

## 2. データ抽出

### 2.1 顧客データ抽出（System A）

```sql
-- System Aから顧客データをCSV出力
COPY (
    SELECT 
        customer_id,
        customer_name,
        phone,
        email,
        created_at
    FROM customer
    WHERE deleted_flag = false
) TO '/tmp/customers_a.csv' WITH CSV HEADER;
```

### 2.2 対応履歴抽出（System B）

```sql
-- System Bから対応履歴をCSV出力
COPY (
    SELECT 
        history_id,
        customer_id,
        inquiry_date,
        inquiry_content,
        response_content
    FROM inquiry_history
    WHERE inquiry_date >= '2020-01-01'
) TO '/tmp/inquiry_history_b.csv' WITH CSV HEADER;
```

## 3. データ変換

### 3.1 顧客IDの変換

既存システムの顧客IDを新システムの形式に変換

```python
# 変換スクリプト
import csv

def convert_customer_id(old_id):
    # Old: 数字6桁 → New: C + 数字9桁
    return f"C{old_id:09d}"

with open('customers_a.csv', 'r') as input_file:
    with open('customers_converted.csv', 'w') as output_file:
        reader = csv.DictReader(input_file)
        writer = csv.DictWriter(output_file, fieldnames=reader.fieldnames)
        writer.writeheader()
        
        for row in reader:
            row['customer_id'] = convert_customer_id(int(row['customer_id']))
            writer.writerow(row)
```

## 4. データ投入

### 4.1 ステージング環境で検証

```bash
# ステージング環境にデータ投入
psql -h staging-db.example.com -U admin -d customer_db \
  -c "\COPY customer FROM 'customers_converted.csv' CSV HEADER"
```

### 4.2 データ検証

```sql
-- 件数確認
SELECT COUNT(*) FROM customer;  -- 期待: 100,000件

-- データ整合性確認
SELECT COUNT(*) FROM customer WHERE customer_id IS NULL;  -- 期待: 0件
SELECT COUNT(*) FROM customer WHERE customer_name IS NULL;  -- 期待: 0件

-- 重複確認
SELECT customer_id, COUNT(*) 
FROM customer 
GROUP BY customer_id 
HAVING COUNT(*) > 1;  -- 期待: 0件
```

### 4.3 本番環境へ投入

検証が完了したら、本番環境に同じ手順で投入

```bash
# 本番環境にデータ投入
psql -h prod-db.example.com -U admin -d customer_db \
  -c "\COPY customer FROM 'customers_converted.csv' CSV HEADER"
```

## 5. 事後確認

### 5.1 データ件数確認

| テーブル | 移行前 | 移行後 | 差分 | 判定 |
|---------|--------|--------|------|------|
| customer | 100,000 | 100,000 | 0 | ✅ |
| inquiry_history | 500,000 | 500,000 | 0 | ✅ |
| purchase_history | 1,000,000 | 1,000,000 | 0 | ✅ |

### 5.2 サンプルデータ確認

抜き取りで10件程度、実際のデータを確認

## 6. ロールバック手順（問題発生時）

```bash
# バックアップから復元
psql -h prod-db.example.com -U admin -d customer_db < backup_new.sql

# アプリケーションを旧システムに戻す
# (手順は別途「ロールバック手順書」参照)
```

## 7. 移行完了報告

移行完了後、以下を報告：

- 移行件数
- 検証結果
- 所要時間
- 発生した問題と対応

```

#### ④本番デプロイ

**デプロイ手順（Blue/Green デプロイメント）：**

```mermaid
graph TD
    Start([デプロイ開始]) --> Blue[Blue環境<br/>現行システム稼働中]
    
    Blue --> Green1[Green環境構築]
    Green1 --> Green2[アプリケーションデプロイ]
    Green2 --> Green3[設定ファイル配置]
    Green3 --> Green4[データベース接続確認]
    Green4 --> Green5[アプリケーション起動]
    
    Green5 --> Smoke{スモークテスト}
    Smoke -->|NG| Rollback1[ロールバック]
    Rollback1 --> End1([終了])
    
    Smoke -->|OK| Switch[ロードバランサー<br/>切り替え]
    Switch --> Check{本番確認}
    
    Check -->|NG| Rollback2[Blue環境に戻す]
    Rollback2 --> End1
    
    Check -->|OK| Monitor[監視開始]
    Monitor --> Wait[1時間様子見]
    Wait --> Final{問題なし？}
    
    Final -->|Yes| Shutdown[Blue環境停止]
    Shutdown --> End2([デプロイ完了])
    
    Final -->|No| Rollback3[Blue環境に戻す]
    Rollback3 --> End1
    
    style Start fill:#c8e6c9,stroke:#2e7d32
    style End2 fill:#c8e6c9,stroke:#2e7d32
    style End1 fill:#ffcdd2,stroke:#c62828
    style Switch fill:#fff9c4,stroke:#f57f17,stroke-width:2px
    style Check fill:#e1f5fe,stroke:#0277bd
    style Final fill:#e1f5fe,stroke:#0277bd
```

**デプロイスクリプト例：**

```bash
#!/bin/bash

# デプロイスクリプト v1.0

set -e  # エラーが発生したら停止

echo "========================================="
echo "デプロイ開始: $(date)"
echo "========================================="

# 1. 環境変数読み込み
source .env.production

# 2. Green環境のIPアドレス
GREEN_INSTANCE_IP="10.0.1.10"

# 3. アプリケーションをGreen環境にデプロイ
echo "[1/6] アプリケーションをGreen環境にデプロイ中..."
scp -r target/customer-system.jar ec2-user@$GREEN_INSTANCE_IP:/app/
scp application.properties ec2-user@$GREEN_INSTANCE_IP:/app/config/

# 4. Green環境でアプリケーション起動
echo "[2/6] Green環境でアプリケーション起動中..."
ssh ec2-user@$GREEN_INSTANCE_IP << 'EOF'
    cd /app
    sudo systemctl stop customer-system
    sudo systemctl start customer-system
    sleep 30  # 起動待ち

## 3.7 ⑦リリース・展開フェーズ

### 📌 このフェーズの目的

**「完成したシステムを本番環境に公開する」**

家を建てることで例えると：「完成した家の鍵を引き渡し、実際に住み始める段階」

### 🎯 このフェーズで行うこと

```mermaid
graph TD
    A[リリースフェーズ] --> B[①リリース準備]
    A --> C[②本番環境構築]
    A --> D[③データ移行]
    A --> E[④本番デプロイ]
    A --> F[⑤リリース後確認]
    A --> G[⑥ユーザー教育]
    
    B --> B1[リリースノート作成]
    B --> B2[ロールバック計画]
    B --> B3[影響範囲確認]
    
    C --> C1[本番サーバー設定]
    C --> C2[ネットワーク設定]
    C --> C3[セキュリティ設定]
    
    D --> D1[マスタデータ移行]
    D --> D2[トランザクションデータ移行]
    D --> D3[データ検証]
    
    E --> E1[Blue/Greenデプロイ]
    E --> E2[スモークテスト]
    E --> E3[本番切り替え]
    
    F --> F1[疎通確認]
    F --> F2[性能確認]
    F --> F3[監視設定確認]
    
    G --> G1[ユーザーマニュアル配布]
    G --> G2[操作説明会開催]
    G --> G3[Q&Aセッション]
    
    style A fill:#fce4ec,stroke:#c2185b,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#fff9c4,stroke:#f57f17
    style D fill:#ffcdd2,stroke:#c62828
    style E fill:#c8e6c9,stroke:#2e7d32
    style F fill:#e1f5fe,stroke:#0277bd
    style G fill:#f3e5f5,stroke:#7b1fa2
```

### 📝 具体的な作業内容

#### ①リリース準備

**リリースチェックリスト：**

```markdown
# リリースチェックリスト

## コード品質
- [x] 全テスト合格（単体・統合・システム）
- [x] コードレビュー完了
- [x] 静的解析合格（SonarQube）
- [x] セキュリティ診断合格
- [x] 性能テスト合格

## ドキュメント
- [x] リリースノート作成
- [x] ユーザーマニュアル作成
- [x] 運用手順書作成
- [x] ロールバック手順書作成
- [x] 障害対応手順書作成

## インフラ
- [x] 本番環境構築完了
- [x] データベース準備完了
- [x] バックアップ設定完了
- [x] 監視設定完了
- [x] アラート設定完了

## データ
- [x] マスタデータ移行計画作成
- [x] データ移行リハーサル実施
- [x] データ検証手順確認

## 承認
- [x] PM承認
- [x] お客様承認
- [x] セキュリティ部門承認
- [x] インフラ部門承認

## リスク対策
- [x] ロールバック手順確認
- [x] 緊急連絡先一覧作成
- [x] エスカレーションフロー確認
- [x] 障害対応体制確認
```

**リリースノート（Release Note）の例：**

```markdown
# リリースノート v1.0.0

**リリース日:** 2026年6月30日  
**対象システム:** 顧客対応統合システム

## 📢 概要

顧客対応業務の効率化を目的とした新システムをリリースします。
これまで3つのシステムに分散していた顧客情報を統合し、
一つの画面で全ての情報を確認できるようになります。

## ✨ 新機能

### 顧客検索機能
- 顧客名、電話番号、メールアドレスで検索可能
- 検索結果は3秒以内に表示
- 50音順で自動ソート
- AI による類似顧客の提案機能

### 対応履歴管理
- 対応内容の登録・参照
- 過去の対応履歴を時系列表示
- カテゴリ別の分類・検索
- AI による回答候補の提示

### レポート機能
- 月次レポートの自動生成
- カテゴリ別の統計表示
- 担当者別の対応件数集計
- PDF形式でのエクスポート

## 🔧 改善点

- レスポンスタイムが現行システムの10倍高速化
- 操作手順を30%削減
- モバイル対応（スマートフォン・タブレット）

## 🐛 既知の問題

なし（全てのバグは修正済み）

## 📋 システム要件

### ブラウザ
- Google Chrome 120以降（推奨）
- Microsoft Edge 120以降
- Safari 17以降
- Firefox 121以降

### ネットワーク
- インターネット接続必須
- 推奨帯域: 10Mbps以上

## 🔄 移行スケジュール

| 日時 | 作業内容 |
|------|---------|
| 6/30 01:00-02:00 | データ移行 |
| 6/30 02:00-03:00 | システム切り替え |
| 6/30 03:00-04:00 | 動作確認 |
| 6/30 09:00- | 本番運用開始 |

**注意:** 01:00-04:00は現行システムが利用できません。

## 📚 ドキュメント

- [ユーザーマニュアル](https://docs.example.com/manual)
- [FAQ](https://docs.example.com/faq)
- [操作説明動画](https://video.example.com/tutorial)

## 🆘 サポート

問題が発生した場合は、以下にご連絡ください：

- **サポートデスク:** support@example.com
- **電話:** 03-1234-5678（24時間対応）
- **チャット:** システム内のヘルプボタン

## 📝 変更履歴

| バージョン | 日付 | 変更内容 |
|-----------|------|---------|
| 1.0.0 | 2026/06/30 | 初回リリース |
```

#### ②本番環境構築

**本番環境チェックリスト：**

```markdown
# 本番環境構築チェックリスト

## インフラ
- [x] EC2インスタンス起動（Web/APサーバー × 2台）
- [x] RDSインスタンス起動（PostgreSQL Multi-AZ）
- [x] ElastiCache起動（Redis）
- [x] S3バケット作成
- [x] CloudFront設定
- [x] Route 53 DNS設定

## ネットワーク
- [x] VPC作成
- [x] サブネット作成（Public × 2、Private × 2、DB × 2）
- [x] Internet Gateway設定
- [x] NAT Gateway設定
- [x] Security Group設定
- [x] NACL設定
- [x] VPN接続設定（オンプレミスとの連携）

## セキュリティ
- [x] SSL証明書取得・設定
- [x] IAMロール設定
- [x] Secrets Manager設定
- [x] CloudTrail有効化
- [x] GuardDuty有効化
- [x] WAF設定

## 監視・ログ
- [x] CloudWatch Alarms設定
- [x] CloudWatch Logs設定
- [x] X-Ray設定（APM）
- [x] アラート通知先設定（Slack、メール）

## バックアップ
- [x] RDS自動バックアップ設定（7日保持）
- [x] S3バケットのバージョニング有効化
- [x] スナップショット手順確認
```

#### ③データ移行

**データ移行計画：**

```mermaid
graph LR
    A[既存システムA] -->|抽出| D[移行ツール]
    B[既存システムB] -->|抽出| D
    C[既存システムC] -->|抽出| D
    
    D -->|変換| E[ステージングDB]
    E -->|検証| F{データ検証}
    
    F -->|NG| G[エラー修正]
    G --> E
    
    F -->|OK| H[本番DB]
    
    style D fill:#fff9c4,stroke:#f57f17
    style E fill:#e1f5fe,stroke:#0277bd
    style H fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
    style F fill:#ffcdd2,stroke:#c62828
```

**データ移行手順書の例：**

```markdown
# データ移行手順書

## 1. 事前準備

### 1.1 バックアップ取得
```bash
# 既存システムのバックアップ
pg_dump -h old-db.example.com -U admin -d customer_db > backup_old.sql

# 新システムの事前バックアップ
pg_dump -h new-db.example.com -U admin -d customer_db > backup_new.sql
```

### 1.2 メンテナンスモード設定

```bash
# 既存システムをメンテナンスモードに
ssh admin@old-system.example.com
sudo systemctl stop application
```

## 2. データ抽出

### 2.1 顧客データ抽出（System A）

```sql
-- System Aから顧客データをCSV出力
COPY (
    SELECT 
        customer_id,
        customer_name,
        phone,
        email,
        created_at
    FROM customer
    WHERE deleted_flag = false
) TO '/tmp/customers_a.csv' WITH CSV HEADER;
```

### 2.2 対応履歴抽出（System B）

```sql
-- System Bから対応履歴をCSV出力
COPY (
    SELECT 
        history_id,
        customer_id,
        inquiry_date,
        inquiry_content,
        response_content
    FROM inquiry_history
    WHERE inquiry_date >= '2020-01-01'
) TO '/tmp/inquiry_history_b.csv' WITH CSV HEADER;
```

## 3. データ変換

### 3.1 顧客IDの変換

既存システムの顧客IDを新システムの形式に変換

```python
# 変換スクリプト
import csv

def convert_customer_id(old_id):
    # Old: 数字6桁 → New: C + 数字9桁
    return f"C{old_id:09d}"

with open('customers_a.csv', 'r') as input_file:
    with open('customers_converted.csv', 'w') as output_file:
        reader = csv.DictReader(input_file)
        writer = csv.DictWriter(output_file, fieldnames=reader.fieldnames)
        writer.writeheader()
        
        for row in reader:
            row['customer_id'] = convert_customer_id(int(row['customer_id']))
            writer.writerow(row)
```

## 4. データ投入

### 4.1 ステージング環境で検証

```bash
# ステージング環境にデータ投入
psql -h staging-db.example.com -U admin -d customer_db \
  -c "\COPY customer FROM 'customers_converted.csv' CSV HEADER"
```

### 4.2 データ検証

```sql
-- 件数確認
SELECT COUNT(*) FROM customer;  -- 期待: 100,000件

-- データ整合性確認
SELECT COUNT(*) FROM customer WHERE customer_id IS NULL;  -- 期待: 0件
SELECT COUNT(*) FROM customer WHERE customer_name IS NULL;  -- 期待: 0件

-- 重複確認
SELECT customer_id, COUNT(*) 
FROM customer 
GROUP BY customer_id 
HAVING COUNT(*) > 1;  -- 期待: 0件
```

### 4.3 本番環境へ投入

検証が完了したら、本番環境に同じ手順で投入

```bash
# 本番環境にデータ投入
psql -h prod-db.example.com -U admin -d customer_db \
  -c "\COPY customer FROM 'customers_converted.csv' CSV HEADER"
```

## 5. 事後確認

### 5.1 データ件数確認

| テーブル | 移行前 | 移行後 | 差分 | 判定 |
|---------|--------|--------|------|------|
| customer | 100,000 | 100,000 | 0 | ✅ |
| inquiry_history | 500,000 | 500,000 | 0 | ✅ |
| purchase_history | 1,000,000 | 1,000,000 | 0 | ✅ |

### 5.2 サンプルデータ確認

抜き取りで10件程度、実際のデータを確認

## 6. ロールバック手順（問題発生時）

```bash
# バックアップから復元
psql -h prod-db.example.com -U admin -d customer_db < backup_new.sql

# アプリケーションを旧システムに戻す
# (手順は別途「ロールバック手順書」参照)
```

## 7. 移行完了報告

移行完了後、以下を報告：

- 移行件数
- 検証結果
- 所要時間
- 発生した問題と対応

```

#### ④本番デプロイ

**デプロイ手順（Blue/Green デプロイメント）：**

```mermaid
graph TD
    Start([デプロイ開始]) --> Blue[Blue環境<br/>現行システム稼働中]
    
    Blue --> Green1[Green環境構築]
    Green1 --> Green2[アプリケーションデプロイ]
    Green2 --> Green3[設定ファイル配置]
    Green3 --> Green4[データベース接続確認]
    Green4 --> Green5[アプリケーション起動]
    
    Green5 --> Smoke{スモークテスト}
    Smoke -->|NG| Rollback1[ロールバック]
    Rollback1 --> End1([終了])
    
    Smoke -->|OK| Switch[ロードバランサー<br/>切り替え]
    Switch --> Check{本番確認}
    
    Check -->|NG| Rollback2[Blue環境に戻す]
    Rollback2 --> End1
    
    Check -->|OK| Monitor[監視開始]
    Monitor --> Wait[1時間様子見]
    Wait --> Final{問題なし？}
    
    Final -->|Yes| Shutdown[Blue環境停止]
    Shutdown --> End2([デプロイ完了])
    
    Final -->|No| Rollback3[Blue環境に戻す]
    Rollback3 --> End1
    
    style Start fill:#c8e6c9,stroke:#2e7d32
    style End2 fill:#c8e6c9,stroke:#2e7d32
    style End1 fill:#ffcdd2,stroke:#c62828
    style Switch fill:#fff9c4,stroke:#f57f17,stroke-width:2px
    style Check fill:#e1f5fe,stroke:#0277bd
    style Final fill:#e1f5fe,stroke:#0277bd
```

**デプロイスクリプト例：**

```bash
#!/bin/bash

# デプロイスクリプト v1.0

set -e  # エラーが発生したら停止

echo "========================================="
echo "デプロイ開始: $(date)"
echo "========================================="

# 1. 環境変数読み込み
source .env.production

# 2. Green環境のIPアドレス
GREEN_INSTANCE_IP="10.0.1.10"

# 3. アプリケーションをGreen環境にデプロイ
echo "[1/6] アプリケーションをGreen環境にデプロイ中..."
scp -r target/customer-system.jar ec2-user@$GREEN_INSTANCE_IP:/app/
scp application.properties ec2-user@$GREEN_INSTANCE_IP:/app/config/

# 4. Green環境でアプリケーション起動
echo "[2/6] Green環境でアプリケーション起動中..."
ssh ec2-user@$GREEN_INSTANCE_IP << 'EOF'
    cd /app
    sudo systemctl stop customer-system
    sudo systemctl start customer-system
    sleep 30  # 起動待ち

## 3.7 ⑦リリース・展開フェーズ

### 📌 このフェーズの目的

**「完成したシステムを本番環境に公開する」**

家を建てることで例えると：「完成した家の鍵を引き渡し、実際に住み始める段階」

### 🎯 このフェーズで行うこと

```mermaid
graph TD
    A[リリースフェーズ] --> B[①リリース準備]
    A --> C[②本番環境構築]
    A --> D[③データ移行]
    A --> E[④本番デプロイ]
    A --> F[⑤リリース後確認]
    A --> G[⑥ユーザー教育]
    
    B --> B1[リリースノート作成]
    B --> B2[ロールバック計画]
    B --> B3[影響範囲確認]
    
    C --> C1[本番サーバー設定]
    C --> C2[ネットワーク設定]
    C --> C3[セキュリティ設定]
    
    D --> D1[マスタデータ移行]
    D --> D2[トランザクションデータ移行]
    D --> D3[データ検証]
    
    E --> E1[Blue/Greenデプロイ]
    E --> E2[スモークテスト]
    E --> E3[本番切り替え]
    
    F --> F1[疎通確認]
    F --> F2[性能確認]
    F --> F3[監視設定確認]
    
    G --> G1[ユーザーマニュアル配布]
    G --> G2[操作説明会開催]
    G --> G3[Q&Aセッション]
    
    style A fill:#fce4ec,stroke:#c2185b,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#fff9c4,stroke:#f57f17
    style D fill:#ffcdd2,stroke:#c62828
    style E fill:#c8e6c9,stroke:#2e7d32
    style F fill:#e1f5fe,stroke:#0277bd
    style G fill:#f3e5f5,stroke:#7b1fa2
```

### 📝 具体的な作業内容

#### ①リリース準備

**リリースチェックリスト：**

```markdown
# リリースチェックリスト

## コード品質
- [x] 全テスト合格（単体・統合・システム）
- [x] コードレビュー完了
- [x] 静的解析合格（SonarQube）
- [x] セキュリティ診断合格
- [x] 性能テスト合格

## ドキュメント
- [x] リリースノート作成
- [x] ユーザーマニュアル作成
- [x] 運用手順書作成
- [x] ロールバック手順書作成
- [x] 障害対応手順書作成

## インフラ
- [x] 本番環境構築完了
- [x] データベース準備完了
- [x] バックアップ設定完了
- [x] 監視設定完了
- [x] アラート設定完了

## データ
- [x] マスタデータ移行計画作成
- [x] データ移行リハーサル実施
- [x] データ検証手順確認

## 承認
- [x] PM承認
- [x] お客様承認
- [x] セキュリティ部門承認
- [x] インフラ部門承認

## リスク対策
- [x] ロールバック手順確認
- [x] 緊急連絡先一覧作成
- [x] エスカレーションフロー確認
- [x] 障害対応体制確認
```

**リリースノート（Release Note）の例：**

```markdown
# リリースノート v1.0.0

**リリース日:** 2026年6月30日  
**対象システム:** 顧客対応統合システム

## 📢 概要

顧客対応業務の効率化を目的とした新システムをリリースします。
これまで3つのシステムに分散していた顧客情報を統合し、
一つの画面で全ての情報を確認できるようになります。

## ✨ 新機能

### 顧客検索機能
- 顧客名、電話番号、メールアドレスで検索可能
- 検索結果は3秒以内に表示
- 50音順で自動ソート
- AI による類似顧客の提案機能

### 対応履歴管理
- 対応内容の登録・参照
- 過去の対応履歴を時系列表示
- カテゴリ別の分類・検索
- AI による回答候補の提示

### レポート機能
- 月次レポートの自動生成
- カテゴリ別の統計表示
- 担当者別の対応件数集計
- PDF形式でのエクスポート

## 🔧 改善点

- レスポンスタイムが現行システムの10倍高速化
- 操作手順を30%削減
- モバイル対応（スマートフォン・タブレット）

## 🐛 既知の問題

なし（全てのバグは修正済み）

## 📋 システム要件

### ブラウザ
- Google Chrome 120以降（推奨）
- Microsoft Edge 120以降
- Safari 17以降
- Firefox 121以降

### ネットワーク
- インターネット接続必須
- 推奨帯域: 10Mbps以上

## 🔄 移行スケジュール

| 日時 | 作業内容 |
|------|---------|
| 6/30 01:00-02:00 | データ移行 |
| 6/30 02:00-03:00 | システム切り替え |
| 6/30 03:00-04:00 | 動作確認 |
| 6/30 09:00- | 本番運用開始 |

**注意:** 01:00-04:00は現行システムが利用できません。

## 📚 ドキュメント

- [ユーザーマニュアル](https://docs.example.com/manual)
- [FAQ](https://docs.example.com/faq)
- [操作説明動画](https://video.example.com/tutorial)

## 🆘 サポート

問題が発生した場合は、以下にご連絡ください：

- **サポートデスク:** support@example.com
- **電話:** 03-1234-5678（24時間対応）
- **チャット:** システム内のヘルプボタン

## 📝 変更履歴

| バージョン | 日付 | 変更内容 |
|-----------|------|---------|
| 1.0.0 | 2026/06/30 | 初回リリース |
```

#### ②本番環境構築

**本番環境チェックリスト：**

```markdown
# 本番環境構築チェックリスト

## インフラ
- [x] EC2インスタンス起動（Web/APサーバー × 2台）
- [x] RDSインスタンス起動（PostgreSQL Multi-AZ）
- [x] ElastiCache起動（Redis）
- [x] S3バケット作成
- [x] CloudFront設定
- [x] Route 53 DNS設定

## ネットワーク
- [x] VPC作成
- [x] サブネット作成（Public × 2、Private × 2、DB × 2）
- [x] Internet Gateway設定
- [x] NAT Gateway設定
- [x] Security Group設定
- [x] NACL設定
- [x] VPN接続設定（オンプレミスとの連携）

## セキュリティ
- [x] SSL証明書取得・設定
- [x] IAMロール設定
- [x] Secrets Manager設定
- [x] CloudTrail有効化
- [x] GuardDuty有効化
- [x] WAF設定

## 監視・ログ
- [x] CloudWatch Alarms設定
- [x] CloudWatch Logs設定
- [x] X-Ray設定（APM）
- [x] アラート通知先設定（Slack、メール）

## バックアップ
- [x] RDS自動バックアップ設定（7日保持）
- [x] S3バケットのバージョニング有効化
- [x] スナップショット手順確認
```

#### ③データ移行

**データ移行計画：**

```mermaid
graph LR
    A[既存システムA] -->|抽出| D[移行ツール]
    B[既存システムB] -->|抽出| D
    C[既存システムC] -->|抽出| D
    
    D -->|変換| E[ステージングDB]
    E -->|検証| F{データ検証}
    
    F -->|NG| G[エラー修正]
    G --> E
    
    F -->|OK| H[本番DB]
    
    style D fill:#fff9c4,stroke:#f57f17
    style E fill:#e1f5fe,stroke:#0277bd
    style H fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
    style F fill:#ffcdd2,stroke:#c62828
```

**データ移行手順書の例：**

```markdown
# データ移行手順書

## 1. 事前準備

### 1.1 バックアップ取得
```bash
# 既存システムのバックアップ
pg_dump -h old-db.example.com -U admin -d customer_db > backup_old.sql

# 新システムの事前バックアップ
pg_dump -h new-db.example.com -U admin -d customer_db > backup_new.sql
```

### 1.2 メンテナンスモード設定

```bash
# 既存システムをメンテナンスモードに
ssh admin@old-system.example.com
sudo systemctl stop application
```

## 2. データ抽出

### 2.1 顧客データ抽出（System A）

```sql
-- System Aから顧客データをCSV出力
COPY (
    SELECT 
        customer_id,
        customer_name,
        phone,
        email,
        created_at
    FROM customer
    WHERE deleted_flag = false
) TO '/tmp/customers_a.csv' WITH CSV HEADER;
```

### 2.2 対応履歴抽出（System B）

```sql
-- System Bから対応履歴をCSV出力
COPY (
    SELECT 
        history_id,
        customer_id,
        inquiry_date,
        inquiry_content,
        response_content
    FROM inquiry_history
    WHERE inquiry_date >= '2020-01-01'
) TO '/tmp/inquiry_history_b.csv' WITH CSV HEADER;
```

## 3. データ変換

### 3.1 顧客IDの変換

既存システムの顧客IDを新システムの形式に変換

```python
# 変換スクリプト
import csv

def convert_customer_id(old_id):
    # Old: 数字6桁 → New: C + 数字9桁
    return f"C{old_id:09d}"

with open('customers_a.csv', 'r') as input_file:
    with open('customers_converted.csv', 'w') as output_file:
        reader = csv.DictReader(input_file)
        writer = csv.DictWriter(output_file, fieldnames=reader.fieldnames)
        writer.writeheader()
        
        for row in reader:
            row['customer_id'] = convert_customer_id(int(row['customer_id']))
            writer.writerow(row)
```

## 4. データ投入

### 4.1 ステージング環境で検証

```bash
# ステージング環境にデータ投入
psql -h staging-db.example.com -U admin -d customer_db \
  -c "\COPY customer FROM 'customers_converted.csv' CSV HEADER"
```

### 4.2 データ検証

```sql
-- 件数確認
SELECT COUNT(*) FROM customer;  -- 期待: 100,000件

-- データ整合性確認
SELECT COUNT(*) FROM customer WHERE customer_id IS NULL;  -- 期待: 0件
SELECT COUNT(*) FROM customer WHERE customer_name IS NULL;  -- 期待: 0件

-- 重複確認
SELECT customer_id, COUNT(*) 
FROM customer 
GROUP BY customer_id 
HAVING COUNT(*) > 1;  -- 期待: 0件
```

### 4.3 本番環境へ投入

検証が完了したら、本番環境に同じ手順で投入

```bash
# 本番環境にデータ投入
psql -h prod-db.example.com -U admin -d customer_db \
  -c "\COPY customer FROM 'customers_converted.csv' CSV HEADER"
```

## 5. 事後確認

### 5.1 データ件数確認

| テーブル | 移行前 | 移行後 | 差分 | 判定 |
|---------|--------|--------|------|------|
| customer | 100,000 | 100,000 | 0 | ✅ |
| inquiry_history | 500,000 | 500,000 | 0 | ✅ |
| purchase_history | 1,000,000 | 1,000,000 | 0 | ✅ |

### 5.2 サンプルデータ確認

抜き取りで10件程度、実際のデータを確認

## 6. ロールバック手順（問題発生時）

```bash
# バックアップから復元
psql -h prod-db.example.com -U admin -d customer_db < backup_new.sql

# アプリケーションを旧システムに戻す
# (手順は別途「ロールバック手順書」参照)
```

## 7. 移行完了報告

移行完了後、以下を報告：

- 移行件数
- 検証結果
- 所要時間
- 発生した問題と対応

```

#### ④本番デプロイ

**デプロイ手順（Blue/Green デプロイメント）：**

```mermaid
graph TD
    Start([デプロイ開始]) --> Blue[Blue環境<br/>現行システム稼働中]
    
    Blue --> Green1[Green環境構築]
    Green1 --> Green2[アプリケーションデプロイ]
    Green2 --> Green3[設定ファイル配置]
    Green3 --> Green4[データベース接続確認]
    Green4 --> Green5[アプリケーション起動]
    
    Green5 --> Smoke{スモークテスト}
    Smoke -->|NG| Rollback1[ロールバック]
    Rollback1 --> End1([終了])
    
    Smoke -->|OK| Switch[ロードバランサー<br/>切り替え]
    Switch --> Check{本番確認}
    
    Check -->|NG| Rollback2[Blue環境に戻す]
    Rollback2 --> End1
    
    Check -->|OK| Monitor[監視開始]
    Monitor --> Wait[1時間様子見]
    Wait --> Final{問題なし？}
    
    Final -->|Yes| Shutdown[Blue環境停止]
    Shutdown --> End2([デプロイ完了])
    
    Final -->|No| Rollback3[Blue環境に戻す]
    Rollback3 --> End1
    
    style Start fill:#c8e6c9,stroke:#2e7d32
    style End2 fill:#c8e6c9,stroke:#2e7d32
    style End1 fill:#ffcdd2,stroke:#c62828
    style Switch fill:#fff9c4,stroke:#f57f17,stroke-width:2px
    style Check fill:#e1f5fe,stroke:#0277bd
    style Final fill:#e1f5fe,stroke:#0277bd
```

**デプロイスクリプト例：**

```bash
#!/bin/bash

# デプロイスクリプト v1.0

set -e  # エラーが発生したら停止

echo "========================================="
echo "デプロイ開始: $(date)"
echo "========================================="

# 1. 環境変数読み込み
source .env.production

# 2. Green環境のIPアドレス
GREEN_INSTANCE_IP="10.0.1.10"

# 3. アプリケーションをGreen環境にデプロイ
echo "[1/6] アプリケーションをGreen環境にデプロイ中..."
scp -r target/customer-system.jar ec2-user@$GREEN_INSTANCE_IP:/app/
scp application.properties ec2-user@$GREEN_INSTANCE_IP:/app/config/

# 4. Green環境でアプリケーション起動
echo "[2/6] Green環境でアプリケーション起動中..."
ssh ec2-user@$GREEN_INSTANCE_IP << 'EOF'
    cd /app
    sudo systemctl stop customer-system
    sudo systemctl start customer-system
    sleep 30  # 起動待ち

## 3.7 ⑦リリース・展開フェーズ

### 📌 このフェーズの目的

**「完成したシステムを本番環境に公開する」**

家を建てることで例えると：「完成した家の鍵を引き渡し、実際に住み始める段階」

### 🎯 このフェーズで行うこと

```mermaid
graph TD
    A[リリースフェーズ] --> B[①リリース準備]
    A --> C[②本番環境構築]
    A --> D[③データ移行]
    A --> E[④本番デプロイ]
    A --> F[⑤リリース後確認]
    A --> G[⑥ユーザー教育]
    
    B --> B1[リリースノート作成]
    B --> B2[ロールバック計画]
    B --> B3[影響範囲確認]
    
    C --> C1[本番サーバー設定]
    C --> C2[ネットワーク設定]
    C --> C3[セキュリティ設定]
    
    D --> D1[マスタデータ移行]
    D --> D2[トランザクションデータ移行]
    D --> D3[データ検証]
    
    E --> E1[Blue/Greenデプロイ]
    E --> E2[スモークテスト]
    E --> E3[本番切り替え]
    
    F --> F1[疎通確認]
    F --> F2[性能確認]
    F --> F3[監視設定確認]
    
    G --> G1[ユーザーマニュアル配布]
    G --> G2[操作説明会開催]
    G --> G3[Q&Aセッション]
    
    style A fill:#fce4ec,stroke:#c2185b,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#fff9c4,stroke:#f57f17
    style D fill:#ffcdd2,stroke:#c62828
    style E fill:#c8e6c9,stroke:#2e7d32
    style F fill:#e1f5fe,stroke:#0277bd
    style G fill:#f3e5f5,stroke:#7b1fa2
```

### 📝 具体的な作業内容

#### ①リリース準備

**リリースチェックリスト：**

```markdown
# リリースチェックリスト

## コード品質
- [x] 全テスト合格（単体・統合・システム）
- [x] コードレビュー完了
- [x] 静的解析合格（SonarQube）
- [x] セキュリティ診断合格
- [x] 性能テスト合格

## ドキュメント
- [x] リリースノート作成
- [x] ユーザーマニュアル作成
- [x] 運用手順書作成
- [x] ロールバック手順書作成
- [x] 障害対応手順書作成

## インフラ
- [x] 本番環境構築完了
- [x] データベース準備完了
- [x] バックアップ設定完了
- [x] 監視設定完了
- [x] アラート設定完了

## データ
- [x] マスタデータ移行計画作成
- [x] データ移行リハーサル実施
- [x] データ検証手順確認

## 承認
- [x] PM承認
- [x] お客様承認
- [x] セキュリティ部門承認
- [x] インフラ部門承認

## リスク対策
- [x] ロールバック手順確認
- [x] 緊急連絡先一覧作成
- [x] エスカレーションフロー確認
- [x] 障害対応体制確認
```

**リリースノート（Release Note）の例：**

```markdown
# リリースノート v1.0.0

**リリース日:** 2026年6月30日  
**対象システム:** 顧客対応統合システム

## 📢 概要

顧客対応業務の効率化を目的とした新システムをリリースします。
これまで3つのシステムに分散していた顧客情報を統合し、
一つの画面で全ての情報を確認できるようになります。

## ✨ 新機能

### 顧客検索機能
- 顧客名、電話番号、メールアドレスで検索可能
- 検索結果は3秒以内に表示
- 50音順で自動ソート
- AI による類似顧客の提案機能

### 対応履歴管理
- 対応内容の登録・参照
- 過去の対応履歴を時系列表示
- カテゴリ別の分類・検索
- AI による回答候補の提示

### レポート機能
- 月次レポートの自動生成
- カテゴリ別の統計表示
- 担当者別の対応件数集計
- PDF形式でのエクスポート

## 🔧 改善点

- レスポンスタイムが現行システムの10倍高速化
- 操作手順を30%削減
- モバイル対応（スマートフォン・タブレット）

## 🐛 既知の問題

なし（全てのバグは修正済み）

## 📋 システム要件

### ブラウザ
- Google Chrome 120以降（推奨）
- Microsoft Edge 120以降
- Safari 17以降
- Firefox 121以降

### ネットワーク
- インターネット接続必須
- 推奨帯域: 10Mbps以上

## 🔄 移行スケジュール

| 日時 | 作業内容 |
|------|---------|
| 6/30 01:00-02:00 | データ移行 |
| 6/30 02:00-03:00 | システム切り替え |
| 6/30 03:00-04:00 | 動作確認 |
| 6/30 09:00- | 本番運用開始 |

**注意:** 01:00-04:00は現行システムが利用できません。

## 📚 ドキュメント

- [ユーザーマニュアル](https://docs.example.com/manual)
- [FAQ](https://docs.example.com/faq)
- [操作説明動画](https://video.example.com/tutorial)

## 🆘 サポート

問題が発生した場合は、以下にご連絡ください：

- **サポートデスク:** support@example.com
- **電話:** 03-1234-5678（24時間対応）
- **チャット:** システム内のヘルプボタン

## 📝 変更履歴

| バージョン | 日付 | 変更内容 |
|-----------|------|---------|
| 1.0.0 | 2026/06/30 | 初回リリース |
```

#### ②本番環境構築

**本番環境チェックリスト：**

```markdown
# 本番環境構築チェックリスト

## インフラ
- [x] EC2インスタンス起動（Web/APサーバー × 2台）
- [x] RDSインスタンス起動（PostgreSQL Multi-AZ）
- [x] ElastiCache起動（Redis）
- [x] S3バケット作成
- [x] CloudFront設定
- [x] Route 53 DNS設定

## ネットワーク
- [x] VPC作成
- [x] サブネット作成（Public × 2、Private × 2、DB × 2）
- [x] Internet Gateway設定
- [x] NAT Gateway設定
- [x] Security Group設定
- [x] NACL設定
- [x] VPN接続設定（オンプレミスとの連携）

## セキュリティ
- [x] SSL証明書取得・設定
- [x] IAMロール設定
- [x] Secrets Manager設定
- [x] CloudTrail有効化
- [x] GuardDuty有効化
- [x] WAF設定

## 監視・ログ
- [x] CloudWatch Alarms設定
- [x] CloudWatch Logs設定
- [x] X-Ray設定（APM）
- [x] アラート通知先設定（Slack、メール）

## バックアップ
- [x] RDS自動バックアップ設定（7日保持）
- [x] S3バケットのバージョニング有効化
- [x] スナップショット手順確認
```

#### ③データ移行

**データ移行計画：**

```mermaid
graph LR
    A[既存システムA] -->|抽出| D[移行ツール]
    B[既存システムB] -->|抽出| D
    C[既存システムC] -->|抽出| D
    
    D -->|変換| E[ステージングDB]
    E -->|検証| F{データ検証}
    
    F -->|NG| G[エラー修正]
    G --> E
    
    F -->|OK| H[本番DB]
    
    style D fill:#fff9c4,stroke:#f57f17
    style E fill:#e1f5fe,stroke:#0277bd
    style H fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
    style F fill:#ffcdd2,stroke:#c62828
```

**データ移行手順書の例：**

```markdown
# データ移行手順書

## 1. 事前準備

### 1.1 バックアップ取得
```bash
# 既存システムのバックアップ
pg_dump -h old-db.example.com -U admin -d customer_db > backup_old.sql

# 新システムの事前バックアップ
pg_dump -h new-db.example.com -U admin -d customer_db > backup_new.sql
```

### 1.2 メンテナンスモード設定

```bash
# 既存システムをメンテナンスモードに
ssh admin@old-system.example.com
sudo systemctl stop application
```

## 2. データ抽出

### 2.1 顧客データ抽出（System A）

```sql
-- System Aから顧客データをCSV出力
COPY (
    SELECT 
        customer_id,
        customer_name,
        phone,
        email,
        created_at
    FROM customer
    WHERE deleted_flag = false
) TO '/tmp/customers_a.csv' WITH CSV HEADER;
```

### 2.2 対応履歴抽出（System B）

```sql
-- System Bから対応履歴をCSV出力
COPY (
    SELECT 
        history_id,
        customer_id,
        inquiry_date,
        inquiry_content,
        response_content
    FROM inquiry_history
    WHERE inquiry_date >= '2020-01-01'
) TO '/tmp/inquiry_history_b.csv' WITH CSV HEADER;
```

## 3. データ変換

### 3.1 顧客IDの変換

既存システムの顧客IDを新システムの形式に変換

```python
# 変換スクリプト
import csv

def convert_customer_id(old_id):
    # Old: 数字6桁 → New: C + 数字9桁
    return f"C{old_id:09d}"

with open('customers_a.csv', 'r') as input_file:
    with open('customers_converted.csv', 'w') as output_file:
        reader = csv.DictReader(input_file)
        writer = csv.DictWriter(output_file, fieldnames=reader.fieldnames)
        writer.writeheader()
        
        for row in reader:
            row['customer_id'] = convert_customer_id(int(row['customer_id']))
            writer.writerow(row)
```

## 4. データ投入

### 4.1 ステージング環境で検証

```bash
# ステージング環境にデータ投入
psql -h staging-db.example.com -U admin -d customer_db \
  -c "\COPY customer FROM 'customers_converted.csv' CSV HEADER"
```

### 4.2 データ検証

```sql
-- 件数確認
SELECT COUNT(*) FROM customer;  -- 期待: 100,000件

-- データ整合性確認
SELECT COUNT(*) FROM customer WHERE customer_id IS NULL;  -- 期待: 0件
SELECT COUNT(*) FROM customer WHERE customer_name IS NULL;  -- 期待: 0件

-- 重複確認
SELECT customer_id, COUNT(*) 
FROM customer 
GROUP BY customer_id 
HAVING COUNT(*) > 1;  -- 期待: 0件
```

### 4.3 本番環境へ投入

検証が完了したら、本番環境に同じ手順で投入

```bash
# 本番環境にデータ投入
psql -h prod-db.example.com -U admin -d customer_db \
  -c "\COPY customer FROM 'customers_converted.csv' CSV HEADER"
```

## 5. 事後確認

### 5.1 データ件数確認

| テーブル | 移行前 | 移行後 | 差分 | 判定 |
|---------|--------|--------|------|------|
| customer | 100,000 | 100,000 | 0 | ✅ |
| inquiry_history | 500,000 | 500,000 | 0 | ✅ |
| purchase_history | 1,000,000 | 1,000,000 | 0 | ✅ |

### 5.2 サンプルデータ確認

抜き取りで10件程度、実際のデータを確認

## 6. ロールバック手順（問題発生時）

```bash
# バックアップから復元
psql -h prod-db.example.com -U admin -d customer_db < backup_new.sql

# アプリケーションを旧システムに戻す
# (手順は別途「ロールバック手順書」参照)
```

## 7. 移行完了報告

移行完了後、以下を報告：

- 移行件数
- 検証結果
- 所要時間
- 発生した問題と対応

```

#### ④本番デプロイ

**デプロイ手順（Blue/Green デプロイメント）：**

```mermaid
graph TD
    Start([デプロイ開始]) --> Blue[Blue環境<br/>現行システム稼働中]
    
    Blue --> Green1[Green環境構築]
    Green1 --> Green2[アプリケーションデプロイ]
    Green2 --> Green3[設定ファイル配置]
    Green3 --> Green4[データベース接続確認]
    Green4 --> Green5[アプリケーション起動]
    
    Green5 --> Smoke{スモークテスト}
    Smoke -->|NG| Rollback1[ロールバック]
    Rollback1 --> End1([終了])
    
    Smoke -->|OK| Switch[ロードバランサー<br/>切り替え]
    Switch --> Check{本番確認}
    
    Check -->|NG| Rollback2[Blue環境に戻す]
    Rollback2 --> End1
    
    Check -->|OK| Monitor[監視開始]
    Monitor --> Wait[1時間様子見]
    Wait --> Final{問題なし？}
    
    Final -->|Yes| Shutdown[Blue環境停止]
    Shutdown --> End2([デプロイ完了])
    
    Final -->|No| Rollback3[Blue環境に戻す]
    Rollback3 --> End1
    
    style Start fill:#c8e6c9,stroke:#2e7d32
    style End2 fill:#c8e6c9,stroke:#2e7d32
    style End1 fill:#ffcdd2,stroke:#c62828
    style Switch fill:#fff9c4,stroke:#f57f17,stroke-width:2px
    style Check fill:#e1f5fe,stroke:#0277bd
    style Final fill:#e1f5fe,stroke:#0277bd
```

**デプロイスクリプト例：**

```bash
#!/bin/bash

# デプロイスクリプト v1.0

set -e  # エラーが発生したら停止

echo "========================================="
echo "デプロイ開始: $(date)"
echo "========================================="

# 1. 環境変数読み込み
source .env.production

# 2. Green環境のIPアドレス
GREEN_INSTANCE_IP="10.0.1.10"

# 3. アプリケーションをGreen環境にデプロイ
echo "[1/6] アプリケーションをGreen環境にデプロイ中..."
scp -r target/customer-system.jar ec2-user@$GREEN_INSTANCE_IP:/app/
scp application.properties ec2-user@$GREEN_INSTANCE_IP:/app/config/

# 4. Green環境でアプリケーション起動
echo "[2/6] Green環境でアプリケーション起動中..."
ssh ec2-user@$GREEN_INSTANCE_IP << 'EOF'
    cd /app
    sudo systemctl stop customer-system
    sudo systemctl start customer-system
    sleep 30  # 起動待ち

## 3.4 ④詳細設計フェーズ

### 📌 このフェーズの目的

**「実装できるレベルまで詳細化する」**

家を建てることで例えると：「コンセントの位置、配線の経路、使う部品の型番まで決める段階」

### 🎯 このフェーズで行うこと

```mermaid
graph TD
    A[詳細設計フェーズ] --> B[①クラス設計]
    A --> C[②メソッド設計]
    A --> D[③処理フロー設計]
    A --> E[④データベース物理設計]
    A --> F[⑤画面詳細設計]
    A --> G[⑥バッチ処理設計]
    A --> H[⑦エラーハンドリング設計]
    
    B --> B1[クラス図]
    B --> B2[クラス定義書]
    B --> B3[責務の明確化]
    
    C --> C1[メソッドシグネチャ]
    C --> C2[パラメータ定義]
    C --> C3[戻り値定義]
    
    D --> D1[シーケンス図]
    D --> D2[フローチャート]
    D --> D3[擬似コード]
    
    E --> E1[テーブル物理設計]
    E --> E2[インデックス設計]
    E --> E3[SQL設計]
    
    F --> F1[画面項目定義]
    F --> F2[入力チェック仕様]
    F --> F3[イベント処理]
    
    G --> G1[バッチフロー]
    G --> G2[リカバリ設計]
    G --> G3[実行スケジュール]
    
    H --> H1[例外クラス設計]
    H --> H2[エラーメッセージ]
    H --> H3[ログ出力]
    
    style A fill:#f1f8e9,stroke:#558b2f,stroke-width:3px
    style B fill:#e1f5fe,stroke:#0277bd
    style C fill:#f3e5f5,stroke:#7b1fa2
    style D fill:#fff9c4,stroke:#f57f17
    style E fill:#ffcdd2,stroke:#c62828
    style F fill:#fff3e0,stroke:#ef6c00
    style G fill:#c8e6c9,stroke:#2e7d32
    style H fill:#fce4ec,stroke:#c2185b
```

### 📝 具体的な作業内容

#### ①クラス設計

**クラス図（UML）：**

```mermaid
classDiagram
    class CustomerController {
        -CustomerService customerService
        +searchCustomer(request: SearchRequest) ResponseEntity
        +getCustomerDetail(customerId: String) ResponseEntity
        +exportCustomerList(request: ExportRequest) ResponseEntity
        -validateSearchRequest(request: SearchRequest) void
    }
    
    class CustomerService {
        -CustomerRepository customerRepository
        -SystemAIntegration systemAIntegration
        -SystemBIntegration systemBIntegration
        -CacheManager cacheManager
        +searchCustomer(criteria: SearchCriteria) List~Customer~
        +getCustomerById(customerId: String) CustomerDetail
        +getCustomerStatistics(customerId: String) Statistics
        -mergeCustomerData(data1, data2, data3) Customer
        -validateCriteria(criteria: SearchCriteria) void
    }
    
    class CustomerRepository {
        -JdbcTemplate jdbcTemplate
        +findByCriteria(criteria: SearchCriteria) List~Customer~
        +findById(customerId: String) Optional~Customer~
        +count(criteria: SearchCriteria) long
        -buildQuery(criteria: SearchCriteria) String
        -mapRow(resultSet: ResultSet) Customer
    }
    
    class Customer {
        -String customerId
        -String customerName
        -String phone
        -String email
        -String address
        -LocalDateTime createdAt
        -LocalDateTime updatedAt
        +getCustomerId() String
        +setCustomerId(id: String) void
        +isValid() boolean
        +toJson() String
    }
    
    class SearchCriteria {
        -String customerName
        -String phone
        -String email
        -int limit
        -int offset
        +validate() void
        +hasAnyCondition() boolean
    }
    
    class CustomerDetail {
        -Customer customer
        -List~InquiryHistory~ inquiryHistories
        -List~PurchaseHistory~ purchaseHistories
        -Statistics statistics
        +getCustomer() Customer
        +getInquiryHistories() List~InquiryHistory~
    }
    
    CustomerController --> CustomerService : uses
    CustomerService --> CustomerRepository : uses
    CustomerService --> Customer : creates
    CustomerService --> CustomerDetail : creates
    CustomerRepository --> Customer : creates
    CustomerService ..> SearchCriteria : uses
```

**クラス定義書の例：**

#### CustomerService クラス

**パッケージ：** `com.example.customer.service`

**責務：**
顧客情報に関するビジネスロジックを実装する。複数のデータソースから情報を取得・統合し、キャッシュを活用して性能を最適化する。

**依存関係：**

- CustomerRepository（データアクセス）
- SystemAIntegration（外部連携）
- SystemBIntegration（外部連携）
- CacheManager（キャッシュ管理）

**クラス定義：**

```java
package com.example.customer.service;

import com.example.customer.model.*;
import com.example.customer.repository.CustomerRepository;
import com.example.integration.*;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;
import java.util.Optional;

/**
 * 顧客情報サービスクラス
 * 
 * 顧客情報の検索、取得、統合処理を行う。
 * 外部システムとの連携、キャッシュ管理も担当する。
 * 
 * @author システム開発チーム
 * @version 1.0
 * @since 2026-03-15
 */
@Service
@Transactional(readOnly = true)
public class CustomerService {
    
    private final CustomerRepository customerRepository;
    private final SystemAIntegration systemAIntegration;
    private final SystemBIntegration systemBIntegration;
    private final CacheManager cacheManager;
    
    /**
     * コンストラクタ（DIによる注入）
     * 
     * @param customerRepository 顧客リポジトリ
     * @param systemAIntegration System A連携クラス
     * @param systemBIntegration System B連携クラス
     * @param cacheManager キャッシュマネージャー
     */
    public CustomerService(
            CustomerRepository customerRepository,
            SystemAIntegration systemAIntegration,
            SystemBIntegration systemBIntegration,
            CacheManager cacheManager) {
        this.customerRepository = customerRepository;
        this.systemAIntegration = systemAIntegration;
        this.systemBIntegration = systemBIntegration;
        this.cacheManager = cacheManager;
    }
    
    /**
     * 顧客検索
     * 
     * 検索条件に一致する顧客を検索する。
     * 結果はキャッシュされ、次回以降の検索が高速化される。
     * 
     * @param criteria 検索条件
     * @return 検索結果のリスト（最大100件）
     * @throws ValidationException 検索条件が不正な場合
     * @throws SystemException システムエラーが発生した場合
     * 
     * 処理フロー：
     * 1. 検索条件のバリデーション
     * 2. キャッシュの確認
     * 3. キャッシュにない場合、DBから検索
     * 4. 結果を統合DBとSystem Aから取得したデータでマージ
     * 5. 結果をキャッシュに保存（5分間）
     * 6. 結果を返却
     */
    public List<Customer> searchCustomer(SearchCriteria criteria) {
        // 処理の詳細は「処理フロー」セクションを参照
        // メソッドID: M-001
    }
    
    /**
     * 顧客詳細取得
     * 
     * 指定された顧客IDの詳細情報を取得する。
     * 統合DB、System A、System Bから情報を取得し統合する。
     * 
     * @param customerId 顧客ID
     * @return 顧客詳細情報
     * @throws NotFoundException 顧客が存在しない場合
     * @throws SystemException システムエラーが発生した場合
     * 
     * 処理フロー：
     * 1. 顧客IDのバリデーション（形式チェック）
     * 2. 統合DBから基本情報取得
     * 3. 並行して以下を実行：
     *    - System Aから詳細情報取得
     *    - System Bから対応履歴取得
     *    - System Cから購買履歴取得
     * 4. 取得データを統合
     * 5. 統計情報を計算
     * 6. CustomerDetailオブジェクトを生成して返却
     */
    public CustomerDetail getCustomerById(String customerId) {
        // 処理の詳細は「処理フロー」セクションを参照
        // メソッドID: M-002
    }
    
    /**
     * 顧客統計情報取得（private）
     * 
     * 顧客の統計情報を計算する。
     * 
     * @param customerId 顧客ID
     * @return 統計情報
     */
    private Statistics getCustomerStatistics(String customerId) {
        // 実装の詳細は省略
    }
    
    /**
     * データマージ（private）
     * 
     * 複数のデータソースから取得した情報を統合する。
     * 
     * @param dbData 統合DBのデータ
     * @param systemAData System Aのデータ
     * @param systemBData System Bのデータ
     * @return 統合された顧客情報
     */
    private Customer mergeCustomerData(
            Customer dbData, 
            SystemACustomer systemAData, 
            SystemBCustomer systemBData) {
        // 実装の詳細は省略
    }
    
    /**
     * 検索条件バリデーション（private）
     * 
     * @param criteria 検索条件
     * @throws ValidationException バリデーションエラー
     */
    private void validateCriteria(SearchCriteria criteria) {
        if (!criteria.hasAnyCondition()) {
            throw new ValidationException("検索条件を指定してください");
        }
        
        if (criteria.getCustomerName() != null) {
            if (criteria.getCustomerName().length() > 100) {
                throw new ValidationException("顧客名は100文字以内で指定してください");
            }
        }
        
        if (criteria.getPhone() != null) {
            if (!criteria.getPhone().matches("^\\d{2,4}-\\d{2,4}-\\d{4}$")) {
                throw new ValidationException("電話番号の形式が正しくありません");
            }
        }
    }
}
```

#### ②処理フロー設計

**シーケンス図：顧客検索処理**

```mermaid
sequenceDiagram
    participant C as Controller
    participant S as Service
    participant R as Repository
    participant Cache as Redis
    participant DB as PostgreSQL
    participant SysA as System A
    
    C->>S: searchCustomer(criteria)
    activate S
    
    S->>S: validateCriteria(criteria)
    alt バリデーションNG
        S-->>C: ValidationException
    end
    
    S->>Cache: get(cacheKey)
    activate Cache
    alt キャッシュHit
        Cache-->>S: cachedData
        S-->>C: cachedData
    else キャッシュMiss
        Cache-->>S: null
        deactivate Cache
        
        S->>R: findByCriteria(criteria)
        activate R
        R->>DB: SELECT * FROM customer WHERE ...
        activate DB
        DB-->>R: ResultSet
        deactivate DB
        R->>R: mapRow(ResultSet)
        R-->>S: List<Customer>
        deactivate R
        
        par 並行処理
            S->>SysA: getCustomerDetails(customerIds)
            activate SysA
            SysA-->>S: customerDetails
            deactivate SysA
        end
        
        S->>S: mergeData(dbData, systemAData)
        S->>Cache: put(cacheKey, result, 5min)
        S-->>C: List<Customer>
    end
    deactivate S
```

**フローチャート：顧客検索処理**

```mermaid
flowchart TD
    Start([開始]) --> Input[検索条件を受け取る]
    Input --> Validate{検索条件は<br/>妥当か？}
    
    Validate -->|NG| Error1[ValidationException<br/>をスロー]
    Validate -->|OK| Cache{キャッシュに<br/>存在する？}
    
    Cache -->|Yes| Return1[キャッシュから<br/>結果を返す]
    Cache -->|No| Query[データベース検索]
    
    Query --> Check{結果が<br/>存在する？}
    Check -->|No| Return2[空のリストを返す]
    Check -->|Yes| Count{件数は<br/>100件以下？}
    
    Count -->|No| Limit[100件に制限]
    Count -->|Yes| Merge[System Aと<br/>データをマージ]
    Limit --> Merge
    
    Merge --> Sort[顧客名でソート]
    Sort --> SaveCache[キャッシュに保存<br/>5分間有効]
    SaveCache --> Return3[結果を返す]
    
    Return1 --> End([終了])
    Return2 --> End
    Return3 --> End
    Error1 --> End
    
    style Start fill:#c8e6c9,stroke:#2e7d32
    style End fill:#c8e6c9,stroke:#2e7d32
    style Error1 fill:#ffcdd2,stroke:#c62828
    style Validate fill:#fff9c4,stroke:#f57f17
    style Cache fill:#e1f5fe,stroke:#0277bd
    style Check fill:#fff9c4,stroke:#f57f17
    style Count fill:#fff9c4,stroke:#f57f17
```

**擬似コード：**

```
メソッド searchCustomer(criteria):
    // 1. バリデーション
    もし criteria が null なら
        ValidationException をスロー
    終了
    
    もし criteria.hasAnyCondition() が false なら
        ValidationException("検索条件を指定してください") をスロー
    終了
    
    // 2. キャッシュチェック
    cacheKey = "customer:search:" + criteria.toHash()
    cachedResult = cacheManager.get(cacheKey)
    
    もし cachedResult が null でない なら
        logger.info("キャッシュHit", cacheKey)
        cachedResult を返す
    終了
    
    // 3. データベース検索
    開始時刻 = 現在時刻
    customers = customerRepository.findByCriteria(criteria)
    
    もし customers が 空 なら
        logger.info("検索結果なし", criteria)
        空のリスト を返す
    終了
    
    // 4. 件数チェックと制限
    もし customers.size() > 100 なら
        logger.warn("検索結果が100件を超えました", customers.size())
        customers = customers の先頭100件
    終了
    
    // 5. System Aからデータ取得（並行処理）
    customerIds = customers から customerId を抽出
    systemAData = systemAIntegration.getCustomerDetails(customerIds)
    
    // 6. データマージ
    結果リスト = 空のリスト
    各 customer に対して:
        matchingData = systemAData から customer.customerId に一致するものを取得
        mergedCustomer = mergeCustomerData(customer, matchingData)
        結果リスト に mergedCustomer を追加
    終了
    
    // 7. ソート
    結果リスト を customername で昇順ソート
    
    // 8. キャッシュに保存
    cacheManager.put(cacheKey, 結果リスト, 5分)
    
    // 9. パフォーマンスログ
    処理時間 = 現在時刻 - 開始時刻
    logger.info("検索完了", 件数=結果リスト.size(), 処理時間=処理時間)
    
    // 10. 結果を返す
    結果リスト を返す
終了
```

#### ③データベース物理設計

**CREATE TABLE文：**

```sql
-- 顧客テーブル
CREATE TABLE customer (
    -- 主キー
    customer_id VARCHAR(10) NOT NULL COMMENT '顧客ID（C + 9桁数字）',
    
    -- 基本情報
    customer_name VARCHAR(100) NOT NULL COMMENT '顧客名',
    phone VARCHAR(15) NULL COMMENT '電話番号（xxx-xxxx-xxxx形式）',
    email VARCHAR(255) NULL COMMENT 'メールアドレス',
    address VARCHAR(500) NULL COMMENT '住所',
    postal_code VARCHAR(8) NULL COMMENT '郵便番号（xxx-xxxx形式）',
    
    -- 属性情報
    birth_date DATE NULL COMMENT '生年月日',
    gender VARCHAR(10) NULL COMMENT '性別（男性/女性/その他）',
    customer_rank VARCHAR(20) NULL DEFAULT 'ブロンズ' COMMENT 'ランク',
    
    -- システム項目
    deleted_flag TINYINT NOT NULL DEFAULT 0 COMMENT '削除フラグ（0:有効 1:削除済み）',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '登録日時',
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新日時',
    created_by VARCHAR(50) NOT NULL COMMENT '登録者ID',
    updated_by VARCHAR(50) NOT NULL COMMENT '更新者ID',
    version INT NOT NULL DEFAULT 1 COMMENT '楽観的ロック用バージョン',
    
    -- 制約
    PRIMARY KEY (customer_id),
    
    -- インデックス
    INDEX idx_customer_name (customer_name),
    INDEX idx_phone (phone),
    INDEX idx_email (email),
    INDEX idx_created_at (created_at),
    INDEX idx_deleted_flag (deleted_flag),
    
    -- 複合インデックス（検索パターンに基づく）
    INDEX idx_name_phone (customer_name, phone),
    INDEX idx_deleted_created (deleted_flag, created_at)
    
) ENGINE=InnoDB 
  DEFAULT CHARSET=utf8mb4 
  COLLATE=utf8mb4_unicode_ci
  COMMENT='顧客マスタ';

-- 対応履歴テーブル
CREATE TABLE inquiry_history (
    -- 主キー
    history_id BIGINT NOT NULL AUTO_INCREMENT COMMENT '履歴ID（自動採番）',
    
    -- 外部キー
    customer_id VARCHAR(10) NOT NULL COMMENT '顧客ID',
    staff_id VARCHAR(20) NOT NULL COMMENT '担当者ID',
    category_id VARCHAR(20) NOT NULL COMMENT 'カテゴリID',
    
    -- 問い合わせ情報
    inquiry_date TIMESTAMP NOT NULL COMMENT '問い合わせ日時',
    inquiry_content TEXT NOT NULL COMMENT '問い合わせ内容（最大2000文字）',
    response_content TEXT NOT NULL COMMENT '対応内容（最大2000文字）',
    
    -- 状態管理
    priority VARCHAR(10) NOT NULL DEFAULT '中' COMMENT '優先度（高/中/低）',
    status VARCHAR(20) NOT NULL DEFAULT '対応中' COMMENT 'ステータス',
    
    -- 付加情報
    follow_up_date DATE NULL COMMENT 'フォローアップ日',
    satisfaction_score INT NULL COMMENT '満足度（1-5）',
    response_time_minutes INT NULL COMMENT '対応時間（分）',
    
    -- システム項目
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '登録日時',
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新日時',
    created_by VARCHAR(50) NOT NULL COMMENT '登録者ID',
    updated_by VARCHAR(50) NOT NULL COMMENT '更新者ID',
    version INT NOT NULL DEFAULT 1 COMMENT '楽観的ロック用バージョン',
    
    -- 制約
    PRIMARY KEY (history_id),
    
    -- 外部キー制約
    CONSTRAINT fk_inquiry_customer 
        FOREIGN KEY (customer_id) 
        REFERENCES customer(customer_id)
        ON DELETE RESTRICT
        ON UPDATE CASCADE,
    
    CONSTRAINT fk_inquiry_staff 
        FOREIGN KEY (staff_id) 
        REFERENCES staff(staff_id)
        ON DELETE RESTRICT
        ON UPDATE CASCADE,
    
    CONSTRAINT fk_inquiry_category 
        FOREIGN KEY (category_id) 
        REFERENCES category(category_id)
        ON DELETE RESTRICT
        ON UPDATE CASCADE,
    
    -- インデックス
    INDEX idx_customer_id (customer_id),
    INDEX idx_inquiry_date (inquiry_date),
    INDEX idx_staff_id (staff_id),
    INDEX idx_category_id (category_id),
    INDEX idx_status (status),
    INDEX idx_priority (priority),
    
    -- 複合インデックス
    INDEX idx_customer_date (customer_id, inquiry_date DESC),
    INDEX idx_status_date (status, inquiry_date DESC),
    
    -- チェック制約
    CONSTRAINT chk_priority CHECK (priority IN ('高', '中', '低')),
    CONSTRAINT chk_status CHECK (status IN ('対応中', '完了', '保留', 'エスカレーション')),
    CONSTRAINT chk_satisfaction CHECK (satisfaction_score IS NULL OR (satisfaction_score BETWEEN 1 AND 5))
    
) ENGINE=InnoDB 
  DEFAULT CHARSET=utf8mb4 
  COLLATE=utf8mb4_unicode_ci
  COMMENT='対応履歴';

-- パーティショニング（大量データ対策）
-- 過去1年分を月単位でパーティション
ALTER TABLE inquiry_history
PARTITION BY RANGE (TO_DAYS(inquiry_date)) (
    PARTITION p202601 VALUES LESS THAN (TO_DAYS('2026-02-01')),
    PARTITION p202602 VALUES LESS THAN (TO_DAYS('2026-03-01')),
    PARTITION p202603 VALUES LESS THAN (TO_DAYS('2026-04-01')),
    -- 以降、毎月追加
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

**インデックス設計の考え方：**

| インデックス名 | カラム | 理由 | 想定クエリ |
|-------------|--------|------|-----------|
| idx_customer_name | customer_name | 顧客名検索が頻繁 | WHERE customer_name LIKE '%山田%' |
| idx_phone | phone | 電話番号検索 | WHERE phone = '090-1234-5678' |
| idx_email | email | メール検索 | WHERE email = '<xxx@example.com>' |
| idx_name_phone | (customer_name, phone) | 複合検索 | WHERE customer_name LIKE '%山田%' AND phone LIKE '090%' |
| idx_deleted_created | (deleted_flag, created_at) | 有効な顧客の一覧 | WHERE deleted_flag = 0 ORDER BY created_at DESC |

**性能考慮点：**

```sql
-- 良いクエリ例（インデックスを活用）
SELECT * FROM customer 
WHERE deleted_flag = 0 
  AND customer_name LIKE '山田%'  -- 前方一致
ORDER BY created_at DESC
LIMIT 100;

-- 悪いクエリ例（インデックスが効かない）
SELECT * FROM customer 
WHERE LOWER(customer_name) LIKE '%yamada%'  -- 関数使用
   OR phone LIKE '%1234%';  -- 中間一致のOR条件
```

#### ④画面詳細設計

**画面項目定義書：顧客検索画面**

| No. | 項目ID | 項目名 | 種別 | 入力形式 | 桁数 | 必須 | 初期値 | 入力チェック |
|-----|--------|--------|------|---------|------|------|--------|------------|
| 1 | txt_customer_name | 顧客名 | テキスト | 全角・半角 | 100 | | | 100文字以内 |
| 2 | txt_phone | 電話番号 | テキスト | 半角数字とハイフン | 15 | | | 電話番号形式 |
| 3 | txt_email | メールアドレス | テキスト | 半角英数 | 255 | | | メール形式 |
| 4 | btn_search | 検索ボタン | ボタン | - | - | - | - | - |
| 5 | btn_clear | クリアボタン | ボタン | - | - | - | - | - |

**検索結果一覧：**

| No. | 項目ID | 項目名 | 表示形式 | ソート | 備考 |
|-----|--------|--------|---------|--------|------|
| 1 | customer_id | 顧客ID | C + 9桁 | 不可 | リンク |
| 2 | customer_name | 顧客名 | 文字列 | 可 | |
| 3 | phone | 電話番号 | xxx-xxxx-xxxx | 不可 | |
| 4 | email | メール | 文字列 | 不可 | |
| 5 | last_inquiry_date | 最終対応日 | yyyy/MM/dd | 可 | |

**入力チェック仕様：**

| チェックID | 項目 | チェック内容 | エラーメッセージ | タイミング |
|-----------|------|------------|----------------|-----------|
| CHK-001 | 全体 | いずれか1つ以上入力 | 検索条件を入力してください | 検索ボタン押下時 |
| CHK-002 | 顧客名 | 100文字以内 | 顧客名は100文字以内で入力してください | onBlur |
| CHK-003 | 電話番号 | 形式チェック（数字とハイフンのみ） | 電話番号の形式が正しくありません | onBlur |
| CHK-004 | メール | メール形式チェック | メールアドレスの形式が正しくありません | onBlur |

**イベント処理仕様：**

| イベント | トリガー | 処理内容 |
|---------|---------|---------|
| onLoad | 画面表示時 | フォーカスを顧客名にセット |
| onClick(検索) | 検索ボタン押下 | 1. 入力チェック<br/>2. API呼び出し<br/>3. 結果を一覧に表示<br/>4. ローディング表示 |
| onClick(クリア) | クリアボタン押下 | 全入力項目をクリア |
| onClick(顧客ID) | 顧客IDリンク押下 | 顧客詳細画面に遷移 |
| onKeyPress(Enter) | Enterキー押下 | 検索ボタン押下と同じ |

**エラーハンドリング：**

| エラーケース | 表示内容 | 表示方法 |
|------------|---------|---------|
| 入力チェックエラー | 項目ごとのエラーメッセージ | 項目の下に赤字で表示 |
| 検索結果0件 | 「該当する顧客が見つかりませんでした」 | 画面上部にInfoトースト |
| 検索結果100件超 | 「検索結果が100件を超えました。条件を絞り込んでください」 | 画面上部にWarningトースト |
| APIエラー | 「エラーが発生しました。しばらくしてから再度お試しください」 | 画面上部にErrorトースト |
| タイムアウト | 「処理がタイムアウトしました。条件を絞り込んで再度検索してください」 | 画面上部にErrorトースト |

#### ⑤バッチ処理設計

**日次データ同期バッチ**

```mermaid
flowchart TD
    Start([バッチ開始<br/>毎日AM1:00]) --> Init[初期化処理]
    
    Init --> GetTarget[同期対象データ取得<br/>System Cから前日分]
    
    GetTarget --> Check{データ<br/>存在？}
    Check -->|No| Skip[スキップ<br/>正常終了]
    Check -->|Yes| Process[データ処理ループ]
    
    Process --> Validate{データ<br/>妥当性}
    Validate -->|NG| Log1[エラーログ出力]
    Validate -->|OK| Transform[データ変換]
    
    Log1 --> Continue{継続可能？}
    Continue -->|Yes| Process
    Continue -->|No| Error[異常終了]
    
    Transform --> Upsert[DB更新<br/>UPSERT処理]
    Upsert --> Counter{全件<br/>処理済み？}
    
    Counter -->|No| Process
    Counter -->|Yes| Summary[サマリー作成]
    
    Summary --> Notify[メール通知<br/>処理結果]
    Notify --> Success[正常終了]
    
    Skip --> End([バッチ終了])
    Success --> End
    Error --> End
    
    style Start fill:#c8e6c9,stroke:#2e7d32
    style End fill:#c8e6c9,stroke:#2e7d32
    style Error fill:#ffcdd2,stroke:#c62828
    style Success fill:#c8e6c9,stroke:#2e7d32
```

**バッチ仕様書：**

| 項目 | 内容 |
|-----|------|
| バッチ名 | DailyDataSyncBatch |
| 実行タイミング | 毎日 AM 1:00 |
| 想定実行時間 | 30分以内 |
| タイムアウト | 1時間 |
| 処理対象 | System Cの前日分購買履歴データ |
| 処理件数見積 | 約10,000件/日 |
| トランザクション | 1,000件単位でコミット |
| リトライ | エラー時3回まで自動リトライ |

**エラー時の対応：**

```mermaid
flowchart LR
    A[エラー発生] --> B{エラー種別}
    
    B -->|一時的エラー| C[30秒待機]
    C --> D[リトライ<br/>最大3回]
    D --> E{成功？}
    E -->|Yes| F[処理継続]
    E -->|No| G[管理者に通知<br/>手動対応]
    
    B -->|データエラー| H[エラーログ記録]
    H --> I[該当データスキップ]
    I --> F
    
    B -->|致命的エラー| J[全体ロールバック]
    J --> K[緊急アラート]
    K --> L[バッチ停止]
    
    style A fill:#ffcdd2,stroke:#c62828
    style F fill:#c8e6c9,stroke:#2e7d32
    style G fill:#fff3e0,stroke:#ef6c00
    style L fill:#ffcdd2,stroke:#c62828
```

### 📄 作成するドキュメント：詳細設計書

```markdown
# 詳細設計書

**プロジェクト名：** 顧客対応統合システム  
**バージョン：** 1.0  
**作成日：** 2026年4月1日  
**承認日：** 2026年4月30日

## 1. 目的

本書は、基本設計書で定義されたシステム構成に基づき、
実装レベルの詳細な設計を定義する。

## 2. クラス設計

### 2.1 クラス図
[前述のクラス図を参照]

### 2.2 クラス一覧

| パッケージ | クラス名 | 責務 | 行数見積 |
|-----------|---------|------|---------|
| controller | CustomerController | HTTP制御 | 150 |
| service | CustomerService | ビジネスロジック | 300 |
| repository | CustomerRepository | データアクセス | 200 |
| model | Customer | エンティティ | 100 |
| integration | SystemAIntegration | 外部連携 | 150 |

### 2.3 クラス詳細定義

#### CustomerService
[前述のクラス定義を参照]

## 3. メソッド設計

### 3.1 メソッド一覧

| クラス | メソッド名 | 処理概要 | 引数 | 戻り値 | 例外 |
|-------|----------|---------|------|--------|------|
| CustomerService | searchCustomer | 顧客検索 | SearchCriteria | List<Customer> | ValidationException, SystemException |
| CustomerService | getCustomerById | 顧客詳細取得 | String | CustomerDetail | NotFoundException, SystemException |

### 3.2 メソッド詳細

#### searchCustomer メソッド

**シグネチャ：**
```java
public List<Customer> searchCustomer(SearchCriteria criteria)
    throws ValidationException, SystemException
```

**パラメータ：**

- criteria: SearchCriteria - 検索条件

**戻り値：**

- List<Customer> - 検索結果（最大100件）

**例外：**

- ValidationException - 検索条件が不正
- SystemException - システムエラー

**処理フロー：**
[前述のフローチャートと擬似コードを参照]

**使用例：**

```java
SearchCriteria criteria = new SearchCriteria();
criteria.setCustomerName("山田");
criteria.setLimit(100);

List<Customer> results = customerService.searchCustomer(criteria);
```

## 4. データベース物理設計

### 4.1 テーブル定義

[前述のCREATE TABLE文を参照]

### 4.2 SQL定義

#### 顧客検索SQL

```sql
-- 顧客名による部分一致検索
SELECT 
    c.customer_id,
    c.customer_name,
    c.phone,
    c.email,
    c.address,
    MAX(ih.inquiry_date) as last_inquiry_date,
    COUNT(ih.history_id) as inquiry_count
FROM 
    customer c
    LEFT JOIN inquiry_history ih ON c.customer_id = ih.customer_id
WHERE 
    c.deleted_flag = 0
    AND c.customer_name LIKE CONCAT('%', :customerName, '%')
GROUP BY
    c.customer_id,
    c.customer_name,
    c.phone,
    c.email,
    c.address
ORDER BY 
    c.customer_name
LIMIT :limit OFFSET :offset;
```

**実行計画：**

- 使用インデックス: idx_deleted_flag, idx_customer_name
- 想定実行時間: 0.5秒以内（10万件のデータで）

**パラメータバインディング：**

- :customerName - ユーザー入力の顧客名
- :limit - 取得件数上限（通常100）
- :offset - ページングオフセット

## 5. 画面詳細設計

### 5.1 画面項目定義

[前述の画面項目定義書を参照]

### 5.2 JavaScriptイベント処理

```javascript
/**
 * 顧客検索画面
 */
class CustomerSearchScreen {
    
    /**
     * コンストラクタ
     */
    constructor() {
        this.customerService = new CustomerService();
        this.initializeEvents();
    }
    
    /**
     * イベント初期化
     */
    initializeEvents() {
        // 検索ボタン
        document.getElementById('btn_search').addEventListener('click', 
            () => this.handleSearch());
        
        // クリアボタン
        document.getElementById('btn_clear').addEventListener('click', 
            () => this.handleClear());
        
        // Enterキー
        document.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.handleSearch();
            }
        });
    }
    
    /**
     * 検索処理
     */
    async handleSearch() {
        try {
            // 入力値取得
            const criteria = {
                customerName: document.getElementById('txt_customer_name').value,
                phone: document.getElementById('txt_phone').value,
                email: document.getElementById('txt_email').value
            };
            
            // バリデーション
            if (!this.validate(criteria)) {
                return;
            }
            
            // ローディング表示
            this.showLoading(true);
            
            // API呼び出し
            const results = await this.customerService.search(criteria);
            
            // 結果表示
            this.displayResults(results);
            
        } catch (error) {
            this.handleError(error);
        } finally {
            this.showLoading(false);
        }
    }
    
    /**
     * バリデーション
     */
    validate(criteria) {
        // 詳細は省略
    }
}
```

## 6. エラーハンドリング設計

### 6.1 例外クラス階層

```mermaid
classDiagram
    Exception <|-- BaseException
    BaseException <|-- ValidationException
    BaseException <|-- BusinessException
    BaseException <|-- SystemException
    
    BusinessException <|-- NotFoundException
    BusinessException <|-- DuplicateException
    BusinessException <|-- AuthorizationException
    
    SystemException <|-- DatabaseException
    SystemException <|-- IntegrationException
    SystemException <|-- TimeoutException
    
    class BaseException {
        -String code
        -String message
        -Map details
        +getCode()
        +getMessage()
        +getDetails()
    }
```

### 6.2 エラーコード体系

| コード範囲 | カテゴリ | HTTPステータス | 例 |
|----------|---------|---------------|---|
| E0001-E0999 | バリデーションエラー | 400 Bad Request | E0001: 必須入力 |
| E1001-E1999 | ビジネスエラー | 400 Bad Request | E1001: 重複登録 |
| E2001-E2999 | 認証・認可エラー | 401/403 | E2001: 権限不足 |
| E3001-E3999 | データ不整合 | 409 Conflict | E3001: 楽観的ロック |
| E4001-E4999 | リソース不足 | 404 Not Found | E4001: データなし |
| E9001-E9999 | システムエラー | 500 Internal Error | E9001: DB接続エラー |

### 6.3 エラーレスポンス例

```json
{
  "status": "error",
  "error": {
    "code": "E0001",
    "message": "入力値が不正です",
    "details": [
      {
        "field": "customerName",
        "message": "顧客名は100文字以内で入力してください",
        "rejectedValue": "あああああ...（101文字）"
      }
    ],
    "timestamp": "2026-04-15T10:30:45Z",
    "path": "/api/v1/customers/search"
  }
}
```

## 7. バッチ処理設計

### 7.1 バッチ一覧

| バッチ名 | 実行タイミング | 処理概要 | 想定時間 |
|---------|--------------|---------|---------|
| DailyDataSyncBatch | 毎日 AM 1:00 | System C連携 | 30分 |
| MonthlyReportBatch | 毎月1日 AM 2:00 | 月次レポート生成 | 1時間 |
| DataCleanupBatch | 毎週日曜 AM 3:00 | 古いログ削除 | 15分 |

### 7.2 バッチ詳細設計

[前述のバッチ設計を参照]

## 8. 性能設計

### 8.1 パフォーマンス目標

| 処理 | 目標値 | 測定方法 |
|-----|--------|---------|
| 顧客検索 | 3秒以内（95%ile） | APM |
| 顧客詳細表示 | 2秒以内 | APM |
| 対応履歴登録 | 1秒以内 | APM |

### 8.2 性能最適化施策

[前述の性能最適化設計を参照]

## 9. セキュリティ実装

### 9.1 SQLインジェクション対策

**NG例（脆弱）：**

```java
// 絶対にやってはいけない
String sql = "SELECT * FROM customer WHERE name = '" + inputName + "'";
```

**OK例（安全）：**

```java
String sql = "SELECT * FROM customer WHERE name = ?";
PreparedStatement ps = connection.prepareStatement(sql);
ps.setString(1, inputName);
```

### 9.2 XSS対策

**React（自動エスケープ）：**

```jsx
// Reactは自動的にエスケープする
<div>{customerName}</div>  // 安全

// dangerouslySetInnerHTMLは使わない
<div dangerouslySetInnerHTML={{__html: userInput}} />  // 危険
```

### 9.3 CSRF対策

**トークン生成：**

```java
String csrfToken = UUID.randomUUID().toString();
session.setAttribute("CSRF_TOKEN", csrfToken);
```

**トークン検証：**

```java
String sessionToken = (String) session.getAttribute("CSRF_TOKEN");
String requestToken = request.getParameter("csrf_token");

if (!sessionToken.equals(requestToken)) {
    throw new SecurityException("CSRF token mismatch");
}
```

## 10. 単体テスト設計

### 10.1 テストケース

| テストID | テスト内容 | 入力 | 期待結果 |
|---------|----------|------|---------|
| UT-001 | 正常系：顧客名検索 | name="山田" | 該当データが返される |
| UT-002 | 異常系：条件なし | 空のオブジェクト | ValidationException |
| UT-003 | 境界値：100件ちょうど | 100件該当 | 100件が返される |
| UT-004 | 境界値：101件 | 101件該当 | 100件に制限される |

### 10.2 テストコード例

```java
@Test
public void testSearchCustomer_正常系_顧客名検索() {
    // 準備（Arrange）
    SearchCriteria criteria = new SearchCriteria();
    criteria.setCustomerName("山田");
    
    // 実行（Act）
    List<Customer> result = customerService.searchCustomer(criteria);
    
    // 検証（Assert）
    assertNotNull(result);
    assertTrue(result.size() > 0);
    assertTrue(result.get(0).getCustomerName().contains("山田"));
}

@Test(expected = ValidationException.class)
public void testSearchCustomer_異常系_検索条件なし() {
    // 準備
    SearchCriteria criteria = new SearchCriteria();
    
    // 実行（例外が発生することを期待）
    customerService.searchCustomer(criteria);
}
```

## 11. 変更履歴

| バージョン | 日付 | 変更者 | 変更内容 | 承認者 |
|-----------|------|--------|---------|--------|
| 0.1 | 2026/03/20 | 高橋 | 初稿作成 | - |
| 1.0 | 2026/04/30 | 高橋 | 承認版 | 田中PM |

---
以上

```

### 🎓 このフェーズのまとめ

**✅ やること：**
1. クラス設計（クラス図、定義書）
2. メソッド設計（シグネチャ、処理フロー）
3. 処理フロー設計（シーケンス図、フローチャート）
4. DB物理設計（CREATE文、SQL）
5. 画面詳細設計（項目定義、イベント処理）
6. バッチ処理設計
7. エラーハンドリング設計
8. 単体テスト設計

**📄 作るドキュメント：**
- 詳細設計書
- クラス定義書
- テーブル定義書
- 画面項目定義書
- SQL仕様書

**⚠️ よくある失敗：**
- 実装者に任せすぎる（設計が粗い）
- エラーハンドリングを後回し
- 性能を考慮していないSQL
- テストケースが不足

**💡 成功のコツ：**
- **実装者が迷わないレベルまで詳細化**
- **擬似コードやフローチャートを活用**
- **エラーケースを徹底的に洗い出す**
- **SQLの実行計画を事前に確認**
- **単体テストケースを設計時に作成**

**📏 詳細度の目安：**
- 新人でも実装できるレベル
- コードレビューで指摘される前に設計で解決
- 「どう実装するか」ではなく「何を実装するか」が明確


## 3.5 ⑤実装・開発フェーズ

### 📌 このフェーズの目的

**「設計をコードに落とし込む」**

家を建てることで例えると：「大工さんが実際に材料を組み立てて家を作る段階」

### 🎯 このフェーズで行うこと

```mermaid
graph TD
    A[実装・開発フェーズ] --> B[①コーディング]
    A --> C[②単体テスト]
    A --> D[③コードレビュー]
    A --> E[④リファクタリング]
    A --> F[⑤ドキュメント更新]
    
    B --> B1[設計書に従って実装]
    B --> B2[コーディング規約遵守]
    B --> B3[コメント記述]
    
    C --> C1[テストコード作成]
    C --> C2[カバレッジ測定]
    C --> C3[バグ修正]
    
    D --> D1[ピアレビュー]
    D --> D2[静的解析]
    D --> D3[指摘事項対応]
    
    E --> E1[コードの整理]
    E --> E2[重複削除]
    E --> E3[可読性向上]
    
    F --> F1[コメント更新]
    F --> F2[README作成]
    F --> F3[ADR記録]
    
    style A fill:#e1f5fe,stroke:#0277bd,stroke-width:3px
    style B fill:#c8e6c9,stroke:#2e7d32
    style C fill:#fff9c4,stroke:#f57f17
    style D fill:#f3e5f5,stroke:#7b1fa2
    style E fill:#fff3e0,stroke:#ef6c00
    style F fill:#fce4ec,stroke:#c2185b
```

### 📝 具体的な作業内容

#### ①コーディング

**コーディング規約の例（Java）：**

```java
/**
 * 顧客情報サービスクラス
 * 
 * <p>顧客情報の検索、取得、更新を行う。
 * 外部システムとの連携、キャッシュ管理も担当する。
 * 
 * <p>使用例：
 * <pre>{@code
 * CustomerService service = new CustomerService(...);
 * List<Customer> results = service.searchCustomer(criteria);
 * }</pre>
 * 
 * @author 開発チーム
 * @version 1.0
 * @since 2026-04-01
 * @see CustomerRepository
 * @see Customer
 */
@Service
@Transactional(readOnly = true)
@Slf4j  // Lombokでログ機能を自動生成
public class CustomerService {
    
    // 定数は大文字スネークケース
    private static final int MAX_SEARCH_RESULTS = 100;
    private static final int CACHE_TTL_MINUTES = 5;
    
    // フィールドはキャメルケース、finalで宣言
    private final CustomerRepository customerRepository;
    private final SystemAIntegration systemAIntegration;
    private final CacheManager cacheManager;
    
    /**
     * コンストラクタ（DIによる注入）
     * 
     * @param customerRepository 顧客リポジトリ（必須）
     * @param systemAIntegration System A連携（必須）
     * @param cacheManager キャッシュマネージャー（必須）
     * @throws IllegalArgumentException 引数がnullの場合
     */
    public CustomerService(
            CustomerRepository customerRepository,
            SystemAIntegration systemAIntegration,
            CacheManager cacheManager) {
        // ガード節でnullチェック
        Objects.requireNonNull(customerRepository, "customerRepository must not be null");
        Objects.requireNonNull(systemAIntegration, "systemAIntegration must not be null");
        Objects.requireNonNull(cacheManager, "cacheManager must not be null");
        
        this.customerRepository = customerRepository;
        this.systemAIntegration = systemAIntegration;
        this.cacheManager = cacheManager;
    }
    
    /**
     * 顧客検索
     * 
     * <p>検索条件に一致する顧客を検索する。
     * 結果は最大100件に制限され、キャッシュに保存される。
     * 
     * @param criteria 検索条件（必須）
     * @return 検索結果のリスト（空の場合もあり、nullは返さない）
     * @throws ValidationException 検索条件が不正な場合
     * @throws SystemException システムエラーが発生した場合
     */
    public List<Customer> searchCustomer(SearchCriteria criteria) {
        // ログ出力（メソッド開始）
        log.info("顧客検索開始 criteria={}", criteria);
        long startTime = System.currentTimeMillis();
        
        try {
            // 1. バリデーション
            validateCriteria(criteria);
            
            // 2. キャッシュチェック
            String cacheKey = generateCacheKey(criteria);
            List<Customer> cachedResult = cacheManager.get(cacheKey);
            
            if (cachedResult != null) {
                log.info("キャッシュヒット cacheKey={}", cacheKey);
                return cachedResult;
            }
            
            // 3. データベース検索
            List<Customer> customers = customerRepository.findByCriteria(criteria);
            
            // 4. 結果が空の場合は早期リターン
            if (customers.isEmpty()) {
                log.info("検索結果なし criteria={}", criteria);
                return Collections.emptyList();
            }
            
            // 5. 件数制限
            if (customers.size() > MAX_SEARCH_RESULTS) {
                log.warn("検索結果が上限を超過 count={}, limit={}", 
                    customers.size(), MAX_SEARCH_RESULTS);
                customers = customers.subList(0, MAX_SEARCH_RESULTS);
            }
            
            // 6. 外部システムからデータ取得（並行処理）
            List<String> customerIds = customers.stream()
                .map(Customer::getCustomerId)
                .collect(Collectors.toList());
            
            Map<String, SystemACustomer> systemAData = 
                systemAIntegration.getCustomerDetails(customerIds);
            
            // 7. データマージ
            List<Customer> results = customers.stream()
                .map(customer -> mergeWithSystemA(customer, systemAData))
                .collect(Collectors.toList());
            
            // 8. キャッシュに保存
            cacheManager.put(cacheKey, results, CACHE_TTL_MINUTES);
            
            // 9. ログ出力（メソッド終了）
            long duration = System.currentTimeMillis() - startTime;
            log.info("顧客検索完了 count={}, duration={}ms", results.size(), duration);
            
            return results;
            
        } catch (ValidationException e) {
            // バリデーションエラーはそのまま再スロー
            log.warn("バリデーションエラー", e);
            throw e;
            
        } catch (Exception e) {
            // その他のエラーはSystemExceptionでラップ
            log.error("顧客検索中にエラーが発生", e);
            throw new SystemException("顧客検索に失敗しました", e);
        }
    }
    
    /**
     * 検索条件のバリデーション
     * 
     * @param criteria 検索条件
     * @throws ValidationException バリデーションエラー
     */
    private void validateCriteria(SearchCriteria criteria) {
        // 引数nullチェック
        if (criteria == null) {
            throw new ValidationException("検索条件が指定されていません");
        }
        
        // 検索条件が1つも指定されていない
        if (!criteria.hasAnyCondition()) {
            throw new ValidationException("検索条件を1つ以上指定してください");
        }
        
        // 顧客名の長さチェック
        if (criteria.getCustomerName() != null) {
            String name = criteria.getCustomerName();
            if (name.length() > 100) {
                throw new ValidationException(
                    "顧客名は100文字以内で指定してください。現在=" + name.length() + "文字");
            }
            
            // 特殊文字チェック
            if (containsSqlInjectionPattern(name)) {
                throw new ValidationException("顧客名に使用できない文字が含まれています");
            }
        }
        
        // 電話番号の形式チェック
        if (criteria.getPhone() != null) {
            String phone = criteria.getPhone();
            if (!phone.matches("^\\d{2,4}-\\d{2,4}-\\d{4}$")) {
                throw new ValidationException(
                    "電話番号の形式が正しくありません。形式: xxx-xxxx-xxxx");
            }
        }
    }
    
    /**
     * キャッシュキー生成
     * 
     * @param criteria 検索条件
     * @return キャッシュキー
     */
    private String generateCacheKey(SearchCriteria criteria) {
        // 検索条件をハッシュ化してキーを生成
        return "customer:search:" + criteria.hashCode();
    }
    
    /**
     * SQLインジェクションパターンのチェック
     * 
     * @param input 入力文字列
     * @return SQLインジェクションパターンを含む場合true
     */
    private boolean containsSqlInjectionPattern(String input) {
        // 簡易的なチェック（実際はもっと厳密に）
        String[] patterns = {"--", ";", "/*", "*/", "xp_", "sp_", "DROP", "DELETE"};
        String upperInput = input.toUpperCase();
        
        for (String pattern : patterns) {
            if (upperInput.contains(pattern)) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * System Aのデータとマージ
     * 
     * @param customer 統合DBの顧客データ
     * @param systemAData System Aのデータマップ
     * @return マージされた顧客データ
     */
    private Customer mergeWithSystemA(
            Customer customer, 
            Map<String, SystemACustomer> systemAData) {
        
        SystemACustomer systemA = systemAData.get(customer.getCustomerId());
        
        if (systemA != null) {
            // System Aのデータで補完
            customer.setAddress(systemA.getAddress());
            customer.setCustomerRank(systemA.getRank());
        }
        
        return customer;
    }
}
```

**コーディング規約のポイント：**

| 項目 | ルール | 理由 |
|-----|--------|------|
| クラス名 | PascalCase | Javaの標準 |
| メソッド名 | camelCase | Javaの標準 |
| 定数 | UPPER_SNAKE_CASE | 視認性 |
| インデント | 4スペース | 可読性 |
| 1行の長さ | 120文字以内 | 可読性 |
| Javadoc | public/protectedメソッドは必須 | 保守性 |
| nullチェック | メソッド先頭で実施 | 安全性 |
| ログ出力 | 開始・終了・エラー時 | 運用性 |

#### ②単体テスト

**JUnitテストコードの例：**

```java
/**
 * CustomerServiceの単体テストクラス
 */
@ExtendWith(MockitoExtension.class)  // Mockitoを使用
class CustomerServiceTest {
    
    // テスト対象
    @InjectMocks
    private CustomerService customerService;
    
    // モック
    @Mock
    private CustomerRepository customerRepository;
    
    @Mock
    private SystemAIntegration systemAIntegration;
    
    @Mock
    private CacheManager cacheManager;
    
    /**
     * テストケース: 正常系 - 顧客名で検索
     */
    @Test
    @DisplayName("正常系：顧客名で検索すると該当顧客が返される")
    void testSearchCustomer_正常系_顧客名検索() {
        // 準備（Arrange）
        SearchCriteria criteria = new SearchCriteria();
        criteria.setCustomerName("山田");
        
        List<Customer> mockCustomers = Arrays.asList(
            createCustomer("C001", "山田太郎"),
            createCustomer("C002", "山田花子")
        );
        
        // モックの振る舞い定義
        when(cacheManager.get(anyString())).thenReturn(null);  // キャッシュなし
        when(customerRepository.findByCriteria(criteria)).thenReturn(mockCustomers);
        when(systemAIntegration.getCustomerDetails(anyList())).thenReturn(Collections.emptyMap());
        
        // 実行（Act）
        List<Customer> results = customerService.searchCustomer(criteria);
        
        // 検証（Assert）
        assertNotNull(results, "結果がnullであってはならない");
        assertEquals(2, results.size(), "検索結果は2件であるべき");
        assertTrue(results.get(0).getCustomerName().contains("山田"), 
            "顧客名に「山田」が含まれるべき");
        
        // モックが呼ばれたことを検証
        verify(customerRepository, times(1)).findByCriteria(criteria);
        verify(cacheManager, times(1)).put(anyString(), eq(results), eq(5));
    }
    
    /**
     * テストケース: 異常系 - 検索条件なし
     */
    @Test
    @DisplayName("異常系：検索条件なしの場合はValidationExceptionがスローされる")
    void testSearchCustomer_異常系_検索条件なし() {
        // 準備
        SearchCriteria criteria = new SearchCriteria();  // 何も設定しない
        
        // 実行と検証（例外が発生することを期待）
        ValidationException exception = assertThrows(
            ValidationException.class,
            () -> customerService.searchCustomer(criteria),
            "ValidationExceptionがスローされるべき"
        );
        
        // エラーメッセージの検証
        assertTrue(exception.getMessage().contains("検索条件"),
            "エラーメッセージに「検索条件」という文言が含まれるべき");
        
        // リポジトリが呼ばれていないことを検証
        verify(customerRepository, never()).findByCriteria(any());
    }
    
    /**
     * テストケース: 境界値 - 100件ちょうど
     */
    @Test
    @DisplayName("境界値：検索結果が100件の場合は全件返される")
    void testSearchCustomer_境界値_100件() {
        // 準備
        SearchCriteria criteria = new SearchCriteria();
        criteria.setCustomerName("a");
        
        // 100件のダミーデータ生成
        List<Customer> mockCustomers = IntStream.range(0, 100)
            .mapToObj(i -> createCustomer("C" + String.format("%03d", i), "Customer" + i))
            .collect(Collectors.toList());
        
        when(cacheManager.get(anyString())).thenReturn(null);
        when(customerRepository.findByCriteria(criteria)).thenReturn(mockCustomers);
        when(systemAIntegration.getCustomerDetails(anyList())).thenReturn(Collections.emptyMap());
        
        // 実行
        List<Customer> results = customerService.searchCustomer(criteria);
        
        // 検証
        assertEquals(100, results.size(), "100件全て返されるべき");
    }
    
    /**
     * テストケース: 境界値 - 101件
     */
    @Test
    @DisplayName("境界値：検索結果が101件の場合は100件に制限される")
    void testSearchCustomer_境界値_101件() {
        // 準備
        SearchCriteria criteria = new SearchCriteria();
        criteria.setCustomerName("a");
        
        // 101件のダミーデータ生成
        List<Customer> mockCustomers = IntStream.range(0, 101)
            .mapToObj(i -> createCustomer("C" + String.format("%03d", i), "Customer" + i))
            .collect(Collectors.toList());
        
        when(cacheManager.get(anyString())).thenReturn(null);
        when(customerRepository.findByCriteria(criteria)).thenReturn(mockCustomers);
        when(systemAIntegration.getCustomerDetails(anyList())).thenReturn(Collections.emptyMap());
        
        // 実行
        List<Customer> results = customerService.searchCustomer(criteria);
        
        // 検証
        assertEquals(100, results.size(), "100件に制限されるべき");
    }
    
    /**
     * テストケース: キャッシュヒット
     */
    @Test
    @DisplayName("キャッシュ：キャッシュにデータがある場合はDBにアクセスしない")
    void testSearchCustomer_キャッシュヒット() {
        // 準備
        SearchCriteria criteria = new SearchCriteria();
        criteria.setCustomerName("山田");
        
        List<Customer> cachedData = Arrays.asList(
            createCustomer("C001", "山田太郎")
        );
        
        // キャッシュにデータがある
        when(cacheManager.get(anyString())).thenReturn(cachedData);
        
        // 実行
        List<Customer> results = customerService.searchCustomer(criteria);
        
        // 検証
        assertEquals(cachedData, results, "キャッシュのデータが返されるべき");
        
        // DBアクセスしていないことを確認
        verify(customerRepository, never()).findByCriteria(any());
    }
    
    /**
     * テストケース: SQLインジェクション対策
     */
    @Test
    @DisplayName("セキュリティ：SQLインジェクションパターンはエラーになる")
    void testSearchCustomer_SQLインジェクション対策() {
        // 準備
        SearchCriteria criteria = new SearchCriteria();
        criteria.setCustomerName("'; DROP TABLE customer; --");
        
        // 実行と検証
        assertThrows(
            ValidationException.class,
            () -> customerService.searchCustomer(criteria),
            "SQLインジェクションパターンでValidationExceptionがスローされるべき"
        );
    }
    
    /**
     * テストケース: システムエラー
     */
    @Test
    @DisplayName("異常系：DBエラー時はSystemExceptionがスローされる")
    void testSearchCustomer_DBエラー() {
        // 準備
        SearchCriteria criteria = new SearchCriteria();
        criteria.setCustomerName("山田");
        
        when(cacheManager.get(anyString())).thenReturn(null);
        when(customerRepository.findByCriteria(criteria))
            .thenThrow(new RuntimeException("DB接続エラー"));
        
        // 実行と検証
        SystemException exception = assertThrows(
            SystemException.class,
            () -> customerService.searchCustomer(criteria),
            "SystemExceptionがスローされるべき"
        );
        
        assertTrue(exception.getMessage().contains("顧客検索に失敗"),
            "適切なエラーメッセージが含まれるべき");
    }
    
    // ヘルパーメソッド
    private Customer createCustomer(String id, String name) {
        Customer customer = new Customer();
        customer.setCustomerId(id);
        customer.setCustomerName(name);
        return customer;
    }
}
```

**カバレッジ目標：**

| カバレッジ種類 | 目標値 | 測定ツール |
|-------------|--------|----------|
| 行カバレッジ | 80%以上 | JaCoCo |
| 分岐カバレッジ | 75%以上 | JaCoCo |
| メソッドカバレッジ | 90%以上 | JaCoCo |

#### ③コードレビュー

**レビューチェックリスト：**

```markdown
# コードレビューチェックリスト

## 📋 基本事項
- [ ] コーディング規約に従っているか
- [ ] 命名が適切か（意図が明確か）
- [ ] マジックナンバーを使っていないか
- [ ] 不要なコメントアウトがないか
- [ ] TODOコメントが残っていないか

## 🔒 セキュリティ
- [ ] SQLインジェクション対策されているか
- [ ] XSS対策されているか
- [ ] CSRF対策されているか
- [ ] 認証・認可チェックがあるか
- [ ] ログに機密情報を出力していないか
- [ ] パスワードを平文で扱っていないか

## ⚡ 性能
- [ ] N+1問題が発生していないか
- [ ] 不要なループ処理がないか
- [ ] 重い処理は非同期化されているか
- [ ] キャッシュを活用しているか
- [ ] データベースインデックスが適切か

## 🐛 品質
- [ ] null安全に実装されているか
- [ ] 例外処理が適切か
- [ ] リソースリーク（メモリ、コネクション）がないか
- [ ] スレッドセーフか（並行処理）
- [ ] エッジケースを考慮しているか

## 📝 保守性
- [ ] 1メソッドが長すぎないか（50行以内推奨）
- [ ] 1クラスが大きすぎないか（500行以内推奨）
- [ ] 重複コードがないか（DRY原則）
- [ ] テストコードがあるか
- [ ] ログ出力が適切か

## 📚 ドキュメント
- [ ] Javadocが記載されているか
- [ ] 複雑なロジックにコメントがあるか
- [ ] READMEが更新されているか
- [ ] 設計意図（ADR）が記録されているか
```

**レビューツール：**

- **GitHub Pull Request**：コードレビューの標準
- **SonarQube**：静的解析（コード品質、バグ、脆弱性）
- **Checkstyle**：コーディング規約チェック
- **SpotBugs**：バグパターン検出

#### ④Git運用（ブランチ戦略）

```mermaid
gitGraph
    commit id: "初期コミット"
    branch develop
    checkout develop
    commit id: "開発開始"
    
    branch feature/customer-search
    checkout feature/customer-search
    commit id: "検索機能実装"
    commit id: "テスト追加"
    commit id: "レビュー指摘対応"
    
    checkout develop
    merge feature/customer-search id: "検索機能マージ"
    
    branch feature/customer-detail
    checkout feature/customer-detail
    commit id: "詳細画面実装"
    
    checkout develop
    commit id: "バグ修正"
    
    checkout feature/customer-detail
    merge develop id: "最新を取り込み"
    commit id: "詳細機能完成"
    
    checkout develop
    merge feature/customer-detail id: "詳細機能マージ"
    
    checkout main
    merge develop id: "v1.0.0リリース" tag: "v1.0.0"
```

**ブランチ命名規則：**

| ブランチ種類 | 命名 | 用途 | 例 |
|-----------|------|------|---|
| main | main | 本番環境 | main |
| develop | develop | 開発の主軸 | develop |
| feature | feature/機能名 | 新機能開発 | feature/customer-search |
| bugfix | bugfix/バグ内容 | バグ修正 | bugfix/search-timeout |
| hotfix | hotfix/内容 | 緊急修正 | hotfix/security-fix |
| release | release/バージョン | リリース準備 | release/v1.0.0 |

**コミットメッセージ規約：**

```
種類: 概要（50文字以内）

詳細説明（必要に応じて）
- 変更理由
- 影響範囲
- 関連チケット

Refs: #123
```

**種類の例：**

- `feat`: 新機能
- `fix`: バグ修正
- `docs`: ドキュメント
- `style`: フォーマット
- `refactor`: リファクタリング
- `test`: テスト追加
- `chore`: その他

**良いコミットメッセージ例：**

```
feat: 顧客検索機能を実装

- 顧客名、電話番号、メールアドレスで検索可能
- 検索結果は100件まで制限
- キャッシュを5分間保持

Refs: #123
```

#### ⑤ADR（設計決定記録）

**ADR（Architecture Decision Record）**は、重要な設計判断を記録するドキュメントです。

**ADRテンプレート：**

```markdown
# ADR-001: キャッシュにRedisを採用

## ステータス
承認済み（2026-04-15）

## コンテキスト
顧客検索のレスポンス時間を改善する必要がある。
現状、毎回データベースと外部APIを呼び出しており、平均5秒かかっている。
目標は3秒以内（95%パーセンタイル）。

## 決定内容
キャッシュソリューションとしてRedisを採用する。

検索結果を5分間キャッシュすることで、
2回目以降のアクセスを0.5秒以内に短縮する。

## 検討した選択肢

### 選択肢1: Ehcache（メモリキャッシュ）
**メリット：**
- 設定が簡単
- 追加インフラ不要
- レスポンスが最速

**デメリット：**
- サーバー間で共有できない
- アプリ再起動で消える
- メモリ容量に制限

### 選択肢2: Redis
**メリット：**
- 複数サーバーで共有可能
- 永続化オプションあり
- 豊富な機能（TTL、Pub/Sub等）

**デメリット：**
- 追加インフラが必要
- 運用コストがかかる
- ネットワークレイテンシあり

### 選択肢3: Memcached
**メリット：**
- シンプルで高速
- 実績豊富

**デメリット：**
- 機能がRedisより少ない
- 永続化機能なし

## 決定理由
以下の理由からRedisを選択：

1. **スケーラビリティ**：将来Webサーバーを増やす予定があり、
   サーバー間でキャッシュを共有する必要がある

2. **運用性**：ElastiCacheを使えばAWSが管理してくれるため、
   運用負荷が低い

3. **機能性**：TTL（有効期限）が標準機能で、
   キャッシュ戦略を柔軟に実装できる

4. **コスト**：ElastiCache（t3.micro）で月額約$15と許容範囲

## 影響
**ポジティブ：**
- レスポンスタイムが5秒→0.5秒に短縮（キャッシュHit時）
- データベース負荷が70%削減

**ネガティブ：**
- 月額約$15のインフラコスト増
- キャッシュ無効化の複雑性
- データ整合性の考慮が必要

## 参考資料
- [Redis vs Memcached比較記事](https://example.com/...)
- [AWS ElastiCache料金](https://aws.amazon.com/elasticache/pricing/)
- [社内キャッシュ戦略ガイド](internal-doc-url)

## レビュー
- 承認者: 田中PM
- レビュー日: 2026-04-15
```

### 📄 作成するドキュメント

#### ①README.md

```markdown
# 顧客対応統合システム

## 概要
本システムは、複数のシステムに分散した顧客情報を統合し、
カスタマーサポート業務を効率化するためのシステムです。

## 技術スタック
- **フロントエンド**: React 18, TypeScript, Material-UI
- **バックエンド**: Java 17, Spring Boot 3.2
- **データベース**: PostgreSQL 15
- **キャッシュ**: Redis 7
- **インフラ**: AWS (EC2, RDS, ElastiCache, S3)

## 開発環境のセットアップ

### 前提条件
- Java 17以降
- Node.js 18以降
- Docker & Docker Compose
- Git

### セットアップ手順

1. リポジトリのクローン
```bash
git clone https://github.com/example/customer-support-system.git
cd customer-support-system
```

2. 依存関係のインストール

```bash
# バックエンド
./mvnw clean install

# フロントエンド
cd frontend
npm install
```

3. 環境変数の設定

```bash
cp .env.example .env
# .envファイルを編集
```

4. Dockerコンテナの起動

```bash
docker-compose up -d
```

5. データベースマイグレーション

```bash
./mvnw flyway:migrate
```

6. アプリケーションの起動

```bash
# バックエンド
./mvnw spring-boot:run

# フロントエンド
cd frontend
npm start
```

7. ブラウザでアクセス

```
http://localhost:3000
```

## プロジェクト構成

```
customer-support-system/
├── backend/                    # バックエンド
│   ├── src/
│   │   ├── main/
│   │   │   ├── java/          # Javaソースコード
│   │   │   └── resources/     # 設定ファイル
│   │   └── test/              # テストコード
│   ├── pom.xml                # Maven設定
│   └── README.md
├── frontend/                   # フロントエンド
│   ├── src/
│   │   ├── components/        # Reactコンポーネント
│   │   ├── services/          # API通信
│   │   └── utils/             # ユーティリティ
│   ├── package.json
│   └── README.md
├── docs/                       # ドキュメント
│   ├── architecture/          # アーキテクチャ設計書
│   ├── api/                   # API仕様書
│   └── adr/                   # 設計決定記録
├── docker-compose.yml          # Docker設定
└── README.md                   # このファイル
```

## テストの実行

### 単体テスト

```bash
# バックエンド
./mvnw test

# フロントエンド
cd frontend
npm test
```

### カバレッジ

```bash
# バックエンド
./mvnw test jacoco:report
# target/site/jacoco/index.html で確認

# フロントエンド
npm run test:coverage
```

### E2Eテスト

```bash
cd frontend
npm run test:e2e
```

## デプロイ

### ステージング環境

```bash
./scripts/deploy-staging.sh
```

### 本番環境

```bash
./scripts/deploy-production.sh
```

## トラブルシューティング

### よくある問題

**Q: データベース接続エラーが発生する**
A: Dockerコンテナが起動しているか確認してください

```bash
docker-compose ps
```

**Q: ポート3000が既に使用されている**
A: .envファイルでポート番号を変更してください

## 貢献ガイド

Pull Requestを送る前に以下を確認してください：

- [ ] コーディング規約に従っている
- [ ] テストが通る
- [ ] カバレッジが80%以上
- [ ] コードレビューを受けた

## ライセンス

Proprietary - Copyright (c) 2026 株式会社○○

## 連絡先

- プロジェクトマネージャー: <tanaka@example.com>
- 技術リード: <sato@example.com>

```

### 🎓 このフェーズのまとめ

**✅ やること：**
1. 詳細設計に従ってコーディング
2. 単体テスト作成（カバレッジ80%以上）
3. コードレビュー実施
4. リファクタリング
5. ADR記録（重要な設計判断）
6. ドキュメント作成（README等）

**📄 作るドキュメント：**
- ソースコード
- 単体テストコード
- README.md
- ADR（設計決定記録）
- コードレビュー記録

**⚠️ よくある失敗：**
- テストを後回しにする
- コードレビューが形骸化
- ドキュメントを書かない
- 技術的負債を放置

**💡 成功のコツ：**
- **TDD（テスト駆動開発）の実践**
- **小さくコミット、頻繁にプッシュ**
- **レビューは丁寧に、素早く**
- **リファクタリングを恐れない**
- **ADRで設計判断を記録**


## 3.6 ⑥テストフェーズ

### 📌 このフェーズの目的

**「システムが要件通りに動作することを確認する」**

家を建てることで例えると：「電気が通るか、水が出るか、ドアが開閉するか等を確認する段階」

### 🎯 テストの種類とレベル

```mermaid
graph TD
    A[テストピラミッド] --> B[E2Eテスト<br/>少ない]
    B --> C[統合テスト<br/>中程度]
    C --> D[単体テスト<br/>多い]
    
    B --> B1[ユーザー視点で<br/>全体動作確認]
    C --> C1[コンポーネント間の<br/>連携確認]
    D --> D1[個々のメソッド・<br/>関数の動作確認]
    
    E[実施時期] --> E1[単体: 実装中]
    E --> E2[統合: 実装完了後]
    E --> E3[E2E: 統合完了後]
    
    style A fill:#e1f5fe,stroke:#0277bd,stroke-width:3px
    style B fill:#ffcdd2,stroke:#c62828
    style C fill:#fff9c4,stroke:#f57f17
    style D fill:#c8e6c9,stroke:#2e7d32
```

### 📝 各テストレベルの詳細

#### ①単体テスト（Unit Test）

**目的：** 個々のメソッドや関数が正しく動くか確認

**特徴：**

- 最も数が多い（テスト全体の70%）
- 実行が速い（ミリ秒単位）
- 開発者が実装する
- 自動化必須

**実施タイミング：** 実装と同時

**前述の実装フェーズで説明済み**

#### ②統合テスト（Integration Test）

**目的：** コンポーネント間の連携が正しく動くか確認

```mermaid
graph LR
    A[Controller] --> B[Service]
    B --> C[Repository]
    C --> D[(Database)]
    B --> E[External API]
    
    T1[統合テスト1<br/>Controller+Service] -.テスト.- A
    T1 -.テスト.- B
    
    T2[統合テスト2<br/>Service+Repository] -.テスト.- B
    T2 -.テスト.- C
    
    T3[統合テスト3<br/>Repository+DB] -.テスト.- C
    T3 -.テスト.- D
    
    style T1 fill:#fff9c4,stroke:#f57f17
    style T2 fill:#fff9c4,stroke:#f57f17
    style T3 fill:#fff9c4,stroke:#f57f17
```

**統合テストの例：**

```java
/**
 * 統合テスト：Controller + Service + Repository
 * 実際のDBを使用（Testcontainersでコンテナ起動）
 */
@SpringBootTest
@Testcontainers
@AutoConfigureMockMvc
class CustomerIntegrationTest {
    
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15")
        .withDatabaseName("testdb")
        .withUsername("test")
        .withPassword("test");
    
    @Autowired
    private MockMvc mockMvc;
    
    @Autowired
    private CustomerRepository customerRepository;
    
    @BeforeEach
    void setUp() {
        // テストデータの準備
        Customer customer = new Customer();
        customer.setCustomerId("C001");
        customer.setCustomerName("山田太郎");
        customer.setPhone("090-1234-5678");
        customerRepository.save(customer);
    }
    
    @Test
    @DisplayName("統合テスト：顧客検索APIが正しく動作する")
    void testCustomerSearchIntegration() throws Exception {
        // API呼び出し
        mockMvc.perform(get("/api/v1/customers/search")
                .param("customerName", "山田")
                .contentType(MediaType.APPLICATION_JSON))
            // ステータスコード確認
            .andExpect(status().isOk())
            // レスポンス内容確認
            .andExpect(jsonPath("$.status").value("success"))
            .andExpect(jsonPath("$.data.customers").isArray())
            .andExpect(jsonPath("$.data.customers[0].customerName").value("山田太郎"))
            // レスポンスヘッダー確認
            .andExpect(header().string("Content-Type", "application/json"))
            // ログ出力
            .andDo(print());
    }
    
    @Test
    @DisplayName("統合テスト：データベーストランザクションが正しく動作する")
    void testTransactionRollback() {
        // トランザクション内でエラーが発生した場合、ロールバックされることを確認
        assertThrows(Exception.class, () -> {
            customerService.createCustomerWithError(new Customer());
        });
        
        // データが保存されていないことを確認
        assertEquals(1, customerRepository.count(), 
            "エラー時はロールバックされるべき");
    }
}
```

#### ③システムテスト（System Test）

**目的：** システム全体が要件通りに動作するか確認

```mermaid
graph TD
    A[システムテスト] --> B[機能テスト]
    A --> C[非機能テスト]
    
    B --> B1[要件定義書の<br/>各機能を確認]
    B --> B2[画面操作]
    B --> B3[API呼び出し]
    
    C --> C1[性能テスト]
    C --> C2[セキュリティテスト]
    C --> C3[可用性テスト]
    C --> C4[ユーザビリティテスト]
    
    C1 --> C1A[負荷テスト]
    C1 --> C1B[ストレステスト]
    
    C2 --> C2A[脆弱性診断]
    C2 --> C2B[侵入テスト]
    
    style A fill:#ede7f6,stroke:#4527a0,stroke-width:3px
    style B fill:#e1f5fe,stroke:#0277bd
    style C fill:#fff3e0,stroke:#ef6c00
```

**システムテスト計画書の例：**

```markdown
# システムテスト計画書

## 1. テスト目的
要求仕様書（SRS）に定義された全要件が満たされていることを確認する。

## 2. テスト範囲

### 2.1 機能テスト
- FR-001 〜 FR-030（全機能要件）
- 各要件の受入基準を満たすことを確認

### 2.2 非機能テスト
- NFR-001 〜 NFR-050（全非機能要件）
- 性能、セキュリティ、可用性、使用性を確認

## 3. テスト環境

| 項目 | 内容 |
|-----|------|
| インフラ | AWS（ステージング環境） |
| データ | 本番相当の匿名化データ（10万件） |
| ユーザー数 | 同時100ユーザー想定 |
| ネットワーク | 社内ネットワーク経由 |
| ツール | Selenium, JMeter, OWASP ZAP |

## 4. テストスケジュール

| フェーズ | 期間 | 内容 |
|---------|------|------|
| 準備 | 2週間 | 環境構築、データ準備 |
| 機能テスト | 2週間 | 全機能の動作確認 |
| 非機能テスト | 1週間 | 性能、セキュリティ確認 |
| リグレッションテスト | 3日 | バグ修正後の再テスト |
| 最終確認 | 2日 | 総合確認 |

## 5. 完了基準

| 項目 | 基準 |
|-----|------|
| 機能テスト | Must要件100%合格、Should要件80%以上合格 |
| 重大バグ | 0件 |
| 中程度バグ | 5件以下 |
| 性能 | 全NFR達成 |
| セキュリティ | 脆弱性0件 |

## 6. 体制

| 役割 | 担当者 | 責務 |
|-----|--------|------|
| テストマネージャー | 伊藤 | 全体管理 |
| 機能テストリーダー | 佐藤 | 機能テスト |
| 性能テスター | 高橋 | 性能テスト |
| セキュリティテスター | 外部委託 | 脆弱性診断 |
```

**システムテスト仕様書の例：**

| TestID | 要件ID | テスト内容 | 手順 | 期待結果 | 優先度 | 実施者 | 結果 |
|--------|--------|----------|------|---------|--------|--------|------|
| ST-001 | FR-001 | 顧客名検索（正常系） | 1) ログイン<br/>2) 検索画面へ<br/>3) 顧客名「山田」入力<br/>4) 検索ボタン押下 | ・検索結果に山田を含む顧客が表示<br/>・3秒以内に表示 | High | 佐藤 | ✓合格 |
| ST-002 | FR-001 | 顧客名検索（異常系） | 1) ログイン<br/>2) 検索画面へ<br/>3) 何も入力せず検索 | エラーメッセージ「検索条件を入力してください」が表示 | High | 佐藤 | ✓合格 |
| ST-003 | NFR-001 | 性能（レスポンスタイム） | 1) JMeterで100ユーザー同時検索<br/>2) レスポンスタイム測定 | 95%パーセンタイルで3秒以内 | High | 高橋 | ✓合格 |

#### ④E2Eテスト（End-to-End Test）

**目的：** ユーザーの実際の操作フローを再現して確認

```javascript
// Cypress（E2Eテストツール）の例
describe('顧客検索フロー', () => {
  
  beforeEach(() => {
    // テストデータの準備
    cy.task('seedDatabase');
    
    // ログイン
    cy.visit('/login');
    cy.get('#username').type('test@example.com');
    cy.get('#password').type('password123');
    cy.get('#otp').type('123456');
    cy.get('button[type="submit"]').click();
    
    // ホーム画面に遷移していることを確認
    cy.url().should('include', '/home');
  });
  
  it('顧客を検索して詳細画面に遷移できる', () => {
    // 検索画面へ移動
    cy.get('nav').contains('検索').click();
    
    // 顧客名を入力
    cy.get('#txt_customer_name').type('山田');
    
    // 検索ボタンをクリック
    cy.get('#btn_search').click();
    
    // ローディングが表示される
    cy.get('.loading').should('be.visible');
    
    // 検索結果が表示される（3秒以内）
    cy.get('.search-results', { timeout: 3000 }).should('be.visible');
    
    // 結果に「山田」が含まれることを確認
    cy.get('.search-results').should('contain', '山田');
    
    // 最初の結果をクリック
    cy.get('.search-results tr:first').click();
    
    // 詳細画面に遷移
    cy.url().should('include', '/customers/');
    
    // 顧客情報が表示される
    cy.get('.customer-detail').should('be.visible');
    cy.get('.customer-name').should('contain', '山田');
  });
  
  it('検索条件なしの場合はエラーメッセージが表示される', () => {
    cy.get('nav').contains('検索').click();
    
    // 何も入力せずに検索
    cy.get('#btn_search').click();
    
    // エラーメッセージが表示される
    cy.get('.error-toast')
      .should('be.visible')
      .and('contain', '検索条件を入力してください');
  });
});
```

#### ⑤性能テスト（Performance Test）

**負荷テスト（Load Test）：**

```yaml
# JMeter シナリオ例
scenarios:
  - name: 顧客検索シナリオ
    users: 100              # 同時ユーザー数
    duration: 10m           # 継続時間
    ramp-up: 2m            # 立ち上げ時間
    
    steps:
      - name: ログイン
        url: /api/v1/auth/login
        method: POST
        body:
          username: user${RANDOM}
          password: password
        
      - name: 検索実行
        url: /api/v1/customers/search
        method: GET
        params:
          customerName: 山田
        
        assertions:
          - response_time < 3000  # 3秒以内
          - status_code == 200
          
      - name: 詳細表示
        url: /api/v1/customers/${customer_id}
        method: GET
        
        assertions:
          - response_time < 2000  # 2秒以内

    think_time: 3s          # 操作間の待機時間
```

**性能テスト結果レポート例：**

```markdown
# 性能テスト結果レポート

## テスト概要
- 実施日：2026年5月15日
- 実施者：高橋
- ツール：JMeter 5.6
- シナリオ：顧客検索シナリオ

## テスト条件
- 同時ユーザー数：100
- 実行時間：10分
- データ量：顧客10万件

## 測定結果

| API | 平均 | 50%ile | 95%ile | 99%ile | Max | 目標 | 判定 |
|-----|------|--------|--------|--------|-----|------|------|
| 顧客検索 | 1.2秒 | 1.0秒 | 2.8秒 | 4.5秒 | 6.2秒 | 3秒 | ✓合格 |
| 顧客詳細 | 0.8秒 | 0.7秒 | 1.5秒 | 2.1秒 | 3.0秒 | 2秒 | ✓合格 |

## リソース使用状況

| リソース | 平均 | 最大 | 閾値 | 判定 |
|---------|------|------|------|------|
| CPU使用率 | 45% | 68% | 80% | ✓合格 |
| メモリ使用率 | 52% | 71% | 90% | ✓合格 |
| DB接続数 | 42 | 78 | 100 | ✓合格 |

## ボトルネック分析
1. System A APIの呼び出しが遅い（平均800ms）
   → キャッシュ活用で改善の余地あり

2. 検索結果が多い場合にレスポンスが遅延
   → ページング実装済みだが、初回取得件数を調整検討

## 結論
全ての性能要件を満たしており、合格と判定する。
```

#### ⑥セキュリティテスト

**脆弱性診断レポートの例：**

```markdown
# セキュリティ診断レポート

## 診断概要
- 実施日：2026年5月20日
- 実施者：セキュリティ診断会社（外部委託）
- 診断範囲：Webアプリケーション全体
- 診断基準：OWASP Top 10 2021

## 診断項目と結果

| No. | 診断項目 | 重要度 | 結果 | 検出数 |
|-----|---------|--------|------|--------|
| 1 | SQLインジェクション | Critical | ✓合格 | 0件 |
| 2 | XSS | High | ✓合格 | 0件 |
| 3 | CSRF | High | ✓合格 | 0件 |
| 4 | 認証の脆弱性 | Critical | ✓合格 | 0件 |
| 5 | アクセス制御の不備 | High | ⚠️要注意 | 1件 |
| 6 | セキュリティ設定ミス | Medium | ✓合格 | 0件 |
| 7 | 機密データの露出 | Critical | ✓合格 | 0件 |
| 8 | 安全でないデシリアライゼーション | High | ✓合格 | 0件 |
| 9 | 脆弱なコンポーネント | High | ✓合格 | 0件 |
| 10 | ログ・監視不足 | Medium | ✓合格 | 0件 |

## 検出事項

### [Medium] アクセス制御の不備
**概要：**  
一般ユーザーが管理者専用APIにアクセスできる可能性

**詳細：**  
`/api/v1/admin/users`エンドポイントで、
JWTのロールチェックが不完全

**再現手順：**
1. 一般ユーザーでログイン
2. JWTトークンを取得
3. 管理者用APIにアクセス

**影響：**  
一般ユーザーが他のユーザー情報を参照できる

**推奨対応：**
```java
// Before（脆弱）
@GetMapping("/api/v1/admin/users")
public List<User> getUsers() {
    return userService.findAll();
}

// After（修正）
@GetMapping("/api/v1/admin/users")
@PreAuthorize("hasRole('ADMIN')")  // 追加
public List<User> getUsers() {
    return userService.findAll();
}
```

**対応期限：** 2週間以内

## 総合評価

重大な脆弱性（Critical）は検出されず、
概ねセキュアなシステムと評価する。

検出された1件の要注意事項は、
リリース前に必ず修正すること。

```

### 📄 作成するドキュメント：テスト関連

```markdown
# テスト報告書（総合）

## 1. テスト概要

| 項目 | 内容 |
|-----|------|
| プロジェクト名 | 顧客対応統合システム |
| テスト期間 | 2026年5月1日〜5月31日 |
| テスト責任者 | 伊藤 |
| 実施環境 | AWSステージング環境 |

## 2. テスト実施状況

### 2.1 機能テスト

| テストレベル | 計画数 | 実施数 | 合格数 | 不合格数 | 合格率 |
|------------|--------|--------|--------|---------|--------|
| 単体テスト | 450 | 450 | 448 | 2 | 99.6% |
| 統合テスト | 120 | 120 | 118 | 2 | 98.3% |
| システムテスト | 80 | 80 | 78 | 2 | 97.5% |
| E2Eテスト | 30 | 30 | 30 | 0 | 100% |
| **合計** | **680** | **680** | **674** | **6** | **99.1%** |

### 2.2 非機能テスト

| テスト種別 | 実施項目数 | 合格数 | 判定 |
|-----------|----------|--------|------|
| 性能テスト | 15 | 15 | ✓合格 |
| セキュリティテスト | 10 | 10 | ✓合格 |
| 可用性テスト | 5 | 5 | ✓合格 |
| ユーザビリティテスト | 8 | 7 | ⚠️要改善 |
| **合計** | **38** | **37** | **97.4%** |

## 3. バグ分析

### 3.1 バグ検出数（重要度別）

| 重要度 | 検出数 | 修正済み | 未修正 | 備考 |
|--------|--------|---------|--------|------|
| Critical | 0 | 0 | 0 | - |
| High | 2 | 2 | 0 | 全て修正済み |
| Medium | 8 | 6 | 2 | リリース後対応 |
| Low | 15 | 10 | 5 | 次期対応 |
| **合計** | **25** | **18** | **7** | |

### 3.2 主なバグ事例

| BugID | 重要度 | 内容 | 原因 | 対応 |
|-------|--------|------|------|------|
| BUG-001 | High | 検索結果が0件の場合にエラー | nullチェック漏れ | 修正完了 |
| BUG-002 | High | 特殊文字を含む顧客名でエラー | エスケープ処理不足 | 修正完了 |
| BUG-003 | Medium | レポート出力が遅い | 不要なJOIN | 次期対応 |

## 4. 性能テスト結果

| 項目 | 目標 | 実績 | 判定 |
|-----|------|------|------|
| 検索レスポンス（95%ile） | 3秒以内 | 2.8秒 | ✓合格 |
| 詳細表示レスポンス | 2秒以内 | 1.5秒 | ✓合格 |
| 同時アクセス | 100ユーザー | 100ユーザー対応確認 | ✓合格 |
| CPU使用率 | 80%以下 | 68% | ✓合格 |
| メモリ使用率 | 90%以下 | 71% | ✓合格 |

## 5. セキュリティテスト結果

| 項目 | 判定 |
|-----|------|
| OWASP Top 10 対策 | ✓合格（1件要改善あり、対応済み） |
| 脆弱性診断 | ✓合格 |
| 侵入テスト | ✓合格 |

## 6. リリース判定

### 6.1 判定基準

| 基準 | 目標 | 実績 | 判定 |
|-----|------|------|------|
| 機能テスト合格率 | 95%以上 | 99.1% | ✓ |
| Criticalバグ | 0件 | 0件 | ✓ |
| Highバグ | 未修正0件 | 未修正0件 | ✓ |
| 性能要件 | 全項目達成 | 全項目達成 | ✓ |
| セキュリティ | 脆弱性0件 | 0件 | ✓ |

### 6.2 総合判定

**✅ リリース可（Go）**

全ての判定基準を満たしており、
予定通り2026年6月1日にリリース可能と判断する。

## 7. 残課題

| 課題ID | 内容 | 優先度 | 対応時期 |
|-------|------|--------|---------|
| ISSUE-001 | ユーザビリティ改善（検索結果の表示順） | Low | 次期バージョン |
| ISSUE-002 | レポート出力の性能改善 | Medium | リリース後1ヶ月以内 |
| ISSUE-003 | エラーメッセージの分かりやすさ向上 | Low | 次期バージョン |

## 8. 承認

| 役職 | 氏名 | 承認日 | サイン |
|-----|------|--------|--------|
| テストマネージャー | 伊藤 | 2026/05/31 | [署名] |
| プロジェクトマネージャー | 田中 | 2026/05/31 | [署名] |
| 品質保証責任者 | 山田 | 2026/05/31 | [署名] |
```

### 🎓 このフェーズのまとめ

**✅ やること：**

1. 単体テスト（開発者）
2. 統合テスト（開発チーム）
3. システムテスト（QAチーム）
4. E2Eテスト（QAチーム）
5. 性能テスト（性能担当）
6. セキュリティテスト（外部委託）
7. バグ修正とリグレッションテスト
8. テスト報告書作成

**📄 作るドキュメント：**

- テスト計画書
- テスト仕様書
- テスト結果報告書
- バグ管理表
- 性能テストレポート
- セキュリティ診断レポート

**⚠️ よくある失敗：**

- テストを形式的にこなす
- バグを放置してリリース
- 性能テストを省略
- セキュリティテストを軽視

**💡 成功のコツ：**

- **テスト自動化**（回帰テストが楽になる）
- **早期にバグを発見**（修正コストが安い）
- **性能は最初から考慮**（後から改善は困難）
- **セキュリティは妥協しない**

## 3.7 ⑦リリース・展開フェーズ

### 📌 このフェーズの目的

**「システムを本番環境に安全に展開し、ユーザーに提供する」**

家を建てることで例えると：「完成した家の鍵を渡して、引き渡しを行う段階」

### 🎯 リリースの流れ

```mermaid
graph TD
    A[リリース準備] --> B[リリース判定会議]
    B -->|Go| C[本番展開]
    B -->|No-Go| Z[延期]
    
    C --> D[Blue/Green切り替え]
    D --> E[動作確認]
    E --> F{問題なし？}
    
    F -->|Yes| G[監視開始]
    F -->|No| H[ロールバック]
    
    G --> I[リリース完了]
    H --> J[原因調査]
    J --> A
    
    Z --> K[課題対応]
    K --> A
    
    style A fill:#fff9c4,stroke:#f57f17
    style B fill:#ffcdd2,stroke:#c62828,stroke-width:2px
    style C fill:#e1f5fe,stroke:#0277bd
    style F fill:#fff9c4,stroke:#f57f17
    style G fill:#c8e6c9,stroke:#2e7d32
    style H fill:#ffcdd2,stroke:#c62828
    style I fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
```

### 📝 具体的な作業内容

#### ①リリース準備

**チェックリスト：**

```markdown
# リリース前チェックリスト

## 📋 テスト完了確認
- [ ] 全テストケースが実行済み
- [ ] 合格率が基準（95%）以上
- [ ] Criticalバグがゼロ
- [ ] Highバグがすべて修正済み
- [ ] 性能要件をすべて満たしている
- [ ] セキュリティ診断で脆弱性ゼロ

## 📄 ドキュメント準備
- [ ] リリースノート作成済み
- [ ] ユーザーマニュアル完成
- [ ] 運用手順書（Runbook）完成
- [ ] ロールバック手順書作成済み
- [ ] 障害対応フロー確認済み

## 🖥️ 本番環境準備
- [ ] 本番環境の構築完了
- [ ] データベースマイグレーション確認
- [ ] バックアップ取得完了
- [ ] DNS設定確認
- [ ] SSL証明書有効期限確認
- [ ] ファイアウォール設定確認

## 👥 体制・連絡
- [ ] リリース当日の体制表作成
- [ ] 関係者への事前通知完了
- [ ] ユーザーへの告知完了
- [ ] サポート窓口の準備完了
- [ ] エスカレーションフロー確認

## 🔄 リリース手順
- [ ] リリース手順書作成
- [ ] リハーサル実施済み
- [ ] ロールバック手順確認済み
- [ ] 切り戻し判断基準明確化

## 📊 監視・アラート
- [ ] 監視設定完了
- [ ] アラート設定完了
- [ ] ダッシュボード準備完了
- [ ] ログ収集設定確認

## ✅ 承認
- [ ] プロジェクトマネージャー承認
- [ ] 品質保証責任者承認
- [ ] 運用責任者承認
- [ ] 事業部長承認
```

#### ②リリースノート

```markdown
# リリースノート - v1.0.0

## 📅 リリース情報

| 項目 | 内容 |
|-----|------|
| バージョン | 1.0.0 |
| リリース日 | 2026年6月1日（月） 9:00 |
| リリース方式 | Blue/Green デプロイメント |
| メンテナンス時間 | 2026年6月1日 1:00-5:00（4時間） |

## 🎯 このバージョンについて

顧客対応統合システムの初回リリースです。
これまで3つのシステムに分散していた顧客情報を統合し、
カスタマーサポート業務を効率化します。

## ✨ 新機能

### 顧客管理
- **統合検索** - 顧客名、電話番号、メールアドレスで横断検索
- **顧客詳細表示** - 基本情報、購買履歴、対応履歴を一画面で表示
- **高速検索** - キャッシュ活用により、2回目以降の検索が0.5秒で完了

### 対応履歴管理
- **履歴登録** - 問い合わせ内容と対応内容を記録
- **AI回答提示** - 過去の対応履歴から回答候補を自動提示
- **検索・フィルタ** - 日付、カテゴリ、担当者で絞り込み検索

### レポート
- **月次レポート** - 月間の対応実績をPDFで出力
- **ダッシュボード** - リアルタイムの対応状況を可視化

### セキュリティ
- **2要素認証** - ワンタイムパスワードによる強固な認証
- **ロールベースアクセス制御** - 役割に応じた権限管理
- **監査ログ** - 全操作を記録し、5年間保存

## 📈 改善効果（期待値）

| 指標 | 改善前 | 改善後 | 改善率 |
|-----|--------|--------|--------|
| 平均対応時間 | 2時間 | 1時間 | -50% |
| 顧客満足度 | 60% | 85%（目標） | +25pt |
| システム検索時間 | 30分 | 5分 | -83% |

## 🔧 システム要件

### 推奨環境
- **OS**: Windows 10以降、macOS 10.15以降
- **ブラウザ**: Chrome 最新版、Edge 最新版、Firefox 最新版、Safari 最新版
- **画面解像度**: 1920×1080推奨（最低1366×768）
- **ネットワーク**: 高速インターネット接続

### 非対応環境
- Internet Explorer 11以前
- スマートフォン（次期バージョンで対応予定）

## 📝 ユーザーへの影響

### メンテナンス時間
2026年6月1日 1:00-5:00の間、以下のシステムが利用できません：
- 既存の顧客管理システム（System A）
- 既存の問い合わせ管理システム（System B）

**重要：** この間の問い合わせ対応は、電話のみとなります。

### 操作方法の変更
新システムの操作方法については、以下をご参照ください：
- [ユーザーマニュアル（PDF）](link-to-manual.pdf)
- [操作ガイド動画](link-to-video)
- [よくある質問（FAQ）](link-to-faq)

### データ移行
既存システムのデータは全て新システムに移行済みです。
- 顧客情報：10万件
- 対応履歴：50万件
- 購買履歴：100万件

## 🆘 サポート

### 問い合わせ先
- **技術サポート**: support@example.com
- **電話**: 03-1234-5678（平日9:00-18:00）
- **社内チャット**: #customer-system-support

### よくある質問

**Q: ログインできません**
A: 以下を確認してください：
1. ユーザーIDとパスワードが正しいか
2. ワンタイムパスワードの有効期限が切れていないか
3. アカウントがロックされていないか（3回失敗でロック）

**Q: 検索が遅いです**
A: 検索条件を絞り込んでください。
   初回検索は最大3秒、2回目以降は0.5秒程度です。

**Q: 既存システムのデータはどうなりますか？**
A: 新システムに全て移行されています。
   既存システムは2026年6月30日まで参照可能です。

## 🔄 既知の問題

### 制限事項
1. **検索結果の上限**
   - 1回の検索で最大100件まで表示
   - それ以上の場合は条件を絞り込んでください

2. **レポート生成時間**
   - 月次レポートの生成に最大30秒かかる場合があります

3. **ブラウザ互換性**
   - Internet Explorer 11以前は非対応
   - 古いバラウザでは一部機能が動作しない可能性があります

### 今後の対応予定
- スマートフォン対応（v1.1.0で対応予定）
- 多言語対応（v1.2.0で対応予定）
- チャットボット機能（v2.0.0で対応予定）

## 📊 技術情報（開発者向け）

### 変更内容
- 新規開発（初回リリース）
- フレームワーク：Spring Boot 3.2, React 18
- データベース：PostgreSQL 15
- インフラ：AWS（EC2, RDS, ElastiCache, S3)

### API変更
新規APIエンドポイント：
- `POST /api/v1/auth/login` - ログイン
- `GET /api/v1/customers/search` - 顧客検索
- `GET /api/v1/customers/{id}` - 顧客詳細
- `POST /api/v1/inquiries` - 対応履歴登録

詳細は[API仕様書](link-to-api-doc)を参照。

### セキュリティ
- TLS 1.3による通信暗号化
- AES-256によるデータ暗号化
- OWASP Top 10対策実施済み
- 脆弱性診断クリア

## 👥 クレジット

このリリースに貢献いただいた全ての方々に感謝します：
- プロジェクトマネージャー：田中
- 開発リーダー：高橋
- QAリーダー：伊藤
- その他開発メンバー：10名

## 📞 お問い合わせ

ご不明な点がございましたら、サポート窓口までお問い合わせください。

---
© 2026 株式会社○○ All Rights Reserved.
```

#### ③リリース手順書

```markdown
# リリース手順書 v1.0.0

## 1. 事前準備（リリース前日）

### 1.1 バックアップ取得
```bash
# データベースバックアップ
pg_dump -h localhost -U postgres -d production > backup_20260531.sql

# アプリケーションファイルバックアップ
aws s3 sync /var/www/app s3://backup-bucket/app-20260531/
```

### 1.2 本番環境確認

- [ ] CPU使用率が50%以下
- [ ] メモリ使用率が70%以下
- [ ] ディスク使用率が80%以下
- [ ] エラーログにCriticalなしエラーなし

## 2. リリース作業（2026/6/1 1:00-5:00）

### 2.1 メンテナンスモード設定（1:00）

```bash
# メンテナンスページ表示
aws s3 cp maintenance.html s3://web-bucket/index.html
```

### 2.2 新環境（Green）構築（1:10-2:30）

#### a) EC2インスタンス起動

```bash
# Terraformで構築
cd terraform/production
terraform init
terraform plan -out=plan.out
terraform apply plan.out
```

#### b) アプリケーションデプロイ

```bash
# Dockerイメージのデプロイ
docker pull xxx.dkr.ecr.ap-northeast-1.amazonaws.com/customer-app:v1.0.0
docker run -d --name customer-app -p 8080:8080 customer-app:v1.0.0
```

#### c) データベースマイグレーション

```bash
# Flywayでマイグレーション
./mvnw flyway:migrate -Dflyway.url=jdbc:postgresql://prod-db/customer
```

### 2.3 動作確認（2:30-3:30）

#### a) ヘルスチェック

```bash
curl -f http://green-env/actuator/health
# 期待値: {"status":"UP"}
```

#### b) 疎通確認

```bash
# ログインテスト
curl -X POST http://green-env/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"test@example.com","password":"xxx"}'
```

#### c) データ確認

```bash
# 顧客数確認
psql -h prod-db -U postgres -d customer -c "SELECT COUNT(*) FROM customer;"
# 期待値: 100000件
```

### 2.4 Blue/Green切り替え（3:30）

#### a) ALBのターゲットグループ変更

```bash
# Green環境をALBに登録
aws elbv2 register-targets \
  --target-group-arn arn:aws:elasticloadbalancing:... \
  --targets Id=i-green-instance
  
# 30秒待機（ヘルスチェック）
sleep 30

# Blue環境を解除
aws elbv2 deregister-targets \
  --target-group-arn arn:aws:elasticloadbalancing:... \
  --targets Id=i-blue-instance
```

#### b) DNS確認

```bash
# 新環境にルーティングされることを確認
nslookup customer-system.example.com
```

### 2.5 本番動作確認（3:40-4:30）

#### a) 実際のユーザー操作

- [ ] ログインできる
- [ ] 顧客検索ができる
- [ ] 顧客詳細が表示される
- [ ] 対応履歴が登録できる

#### b) 性能確認

```bash
# レスポンスタイム測定
curl -w "@curl-format.txt" -o /dev/null -s http://prod/api/v1/customers/search?name=山田
# 期待値: 3秒以内
```

#### c) ログ確認

```bash
# エラーログ確認
tail -f /var/log/app/error.log
# Criticalエラーがないこと
```

### 2.6 メンテナンスモード解除（4:30）

```bash
# 本番ページ公開
aws s3 rm s3://web-bucket/maintenance.html
aws s3 sync /var/www/prod s3://web-bucket/
```

### 2.7 監視開始（4:40）

- CloudWatch Dashboardで監視開始
- アラートが正常に動作することを確認

## 3. リリース後作業（5:00-9:00）

### 3.1 動作監視

- [ ] CPU使用率監視
- [ ] メモリ使用率監視
- [ ] エラーログ監視
- [ ] ユーザーからの問い合わせ監視

### 3.2 ユーザーサポート準備

- サポート窓口オープン（9:00）
- よくある質問の準備
- エスカレーションフロー確認

## 4. ロールバック手順（問題発生時）

### 4.1 切り戻し判断基準

以下の場合は即座にロールバック：

- Criticalバグの発生
- エラー率が5%を超える
- レスポンスタイムが10秒を超える
- システムダウン

### 4.2 ロールバック手順

```bash
# 1. Blue環境に切り戻し（5分）
aws elbv2 register-targets \
  --target-group-arn arn:aws:elasticloadbalancing:... \
  --targets Id=i-blue-instance

sleep 30

aws elbv2 deregister-targets \
  --target-group-arn arn:aws:elasticloadbalancing:... \
  --targets Id=i-green-instance

# 2. データベースロールバック（必要な場合）
psql -h prod-db -U postgres -d customer < backup_20260531.sql

# 3. 動作確認
curl -f http://prod/actuator/health

# 4. ユーザーへ通知
# 「システム障害のため、一時的に旧システムに切り戻しました」
```

## 5. 連絡先

| 役割 | 担当者 | 電話 | メール |
|-----|--------|------|--------|
| リリース責任者 | 田中 | 090-xxxx-xxxx | <tanaka@example.com> |
| 技術リーダー | 高橋 | 090-yyyy-yyyy | <takahashi@example.com> |
| インフラ担当 | 渡辺 | 090-zzzz-zzzz | <watanabe@example.com> |
| 緊急連絡先 | 山田部長 | 090-aaaa-aaaa | <yamada@example.com> |

```

### 🎓 このフェーズのまとめ

**✅ やること：**
1. リリース準備（チェックリスト確認）
2. リリース判定会議
3. 本番環境へのデプロイ
4. 動作確認
5. メンテナンスモード解除
6. 監視開始
7. ユーザーサポート

**📄 作るドキュメント：**
- リリースノート
- リリース手順書
- ロールバック手順書
- ユーザーマニュアル
- 運用手順書（Runbook）

**⚠️ よくある失敗：**
- リハーサルなしでリリース
- ロールバック手順の未準備
- ユーザーへの事前通知不足
- 監視体制の不備

**💡 成功のコツ：**
- **リハーサル必須**（本番と同じ手順で）
- **Blue/Greenデプロイ**（切り戻しが容易）
- **段階的リリース**（カナリアリリース）
- **密な監視**（リリース直後が最も重要）

---

## 3.8 ⑧運用・保守フェーズ

### 📌 このフェーズの目的

**「システムを安定稼働させ、継続的に改善する」**

家を建てることで例えると：「住み始めた後の日常的なメンテナンスと修理」

### 🎯 運用の全体像

```mermaid
graph TD
    A[運用・保守] --> B[日常運用]
    A --> C[監視]
    A --> D[障害対応]
    A --> E[改善活動]
    
    B --> B1[バックアップ確認]
    B --> B2[ログ確認]
    B --> B3[リソース確認]
    B --> B4[パッチ適用]
    
    C --> C1[リアルタイム監視]
    C --> C2[アラート対応]
    C --> C3[SLO測定]
    
    D --> D1[障害検知]
    D --> D2[一次対処]
    D --> D3[根本原因分析]
    D --> D4[恒久対策]
    
    E --> E1[パフォーマンス改善]
    E --> E2[機能追加]
    E --> E3[技術的負債解消]
    
    style A fill:#e0f2f1,stroke:#00695c,stroke-width:3px
    style B fill:#e1f5fe,stroke:#0277bd
    style C fill:#fff9c4,stroke:#f57f17
    style D fill:#ffcdd2,stroke:#c62828
    style E fill:#c8e6c9,stroke:#2e7d32
```

### 📝 具体的な運用業務

#### ①日常運用業務

**運用カレンダー（月次）：**

| 日 | 業務内容 | 担当 | 所要時間 |
|----|---------|------|---------|
| 毎日 | バックアップ確認 | 運用担当 | 10分 |
| 毎日 | エラーログ確認 | 運用担当 | 20分 |
| 毎日 | リソース使用状況確認 | 運用担当 | 10分 |
| 毎週月曜 | 週次レポート作成 | 運用リーダー | 30分 |
| 毎週日曜 | 定期メンテナンス | 運用担当 | 2時間 |
| 毎月1日 | 月次レポート作成 | 運用リーダー | 2時間 |
| 毎月第2日曜 | セキュリティパッチ適用 | インフラ担当 | 3時間 |
| 四半期ごと | キャパシティプランニング | インフラ担当 | 4時間 |

#### ②監視体制

**監視項目とアラート設定：**

| カテゴリ | 監視項目 | 警告閾値 | 緊急閾値 | 対応 |
|---------|---------|---------|---------|------|
| **リソース** | CPU使用率 | 70% | 85% | スケールアウト検討 |
| | メモリ使用率 | 80% | 95% | メモリリーク調査 |
| | ディスク使用率 | 70% | 85% | 不要ファイル削除 |
| **性能** | レスポンスタイム | 5秒 | 10秒 | パフォーマンス調査 |
| | エラー率 | 1% | 5% | 原因調査 |
| **可用性** | サーバーダウン | - | - | 即座に復旧 |
| | DBコネクション枯渇 | 80% | 95% | コネクション調査 |
| **業務** | 日次バッチ失敗 | - | - | 再実行・調査 |

**監視ダッシュボード：**

```
┌─────────────────────────────────────────────────────────┐
│  顧客対応統合システム - 監視ダッシュボード                    │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  システム稼働状況     [●正常]                              │
│  最終更新: 2026-06-15 10:30:45                          │
│                                                          │
│  ┌────────────────┬────────────────┬────────────────┐    │
│  │ CPU使用率      │ メモリ使用率    │ ディスク使用率  │    │
│  │    45%        │    62%        │    55%        │    │
│  │   [========]  │ [===========] │ [==========]  │    │
│  └────────────────┴────────────────┴────────────────┘    │
│                                                          │
│  ┌────────────────────────────────────────────────────┐  │
│  │ 📊 リアルタイム指標                                 │  │
│  ├────────────────────────────────────────────────────┤  │
│  │ アクティブユーザー数:      45名                     │  │
│  │ 今日の検索回数:           1,234回                  │  │
│  │ 平均レスポンスタイム:      1.2秒                    │  │
│  │ エラー発生回数（24h）:     3件                      │  │
│  └────────────────────────────────────────────────────┘  │
│                                                          │
│  ┌────────────────────────────────────────────────────┐  │
│  │ ⚠️ アラート（直近24時間）                           │  │
│  ├────────────────────────────────────────────────────┤  │
│  │ 10:15 [警告] CPU使用率が70%を超過（対応済み）       │  │
│  │ 09:30 [情報] 日次バッチが正常完了                   │  │
│  └────────────────────────────────────────────────────┘  │
│                                                          │
│  ┌────────────────────────────────────────────────────┐  │
│  │ 📈 SLO達成状況（当月）                              │  │
│  ├────────────────────────────────────────────────────┤  │
│  │ 可用性:        99.95%  (目標: 99.9%) ✓            │  │
│  │ レスポンス:     2.1秒   (目標: 3秒)   ✓            │  │
│  │ エラー率:      0.08%   (目標: 1%以下) ✓            │  │
│  │                                                     │  │
│  │ エラーバジェット残り: 98.5%                         │  │
│  └────────────────────────────────────────────────────┘  │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

#### ③障害対応フロー

```mermaid
graph TD
    A[障害検知] --> B{重要度判定}
    
    B -->|Critical| C1[即座に対応開始]
    B -->|High| C2[30分以内に対応]
    B -->|Medium| C3[4時間以内に対応]
    B -->|Low| C4[次回メンテナンスで対応]
    
    C1 --> D[一次対処<br/>サービス復旧]
    C2 --> D
    C3 --> D
    
    D --> E[影響範囲確認]
    E --> F[ユーザーへ通知]
    F --> G[根本原因分析<br/>RCA]
    
    G --> H[恒久対策実施]
    H --> I[ポストモーテム<br/>作成]
    I --> J[再発防止策]
    J --> K[ナレッジ化]
    
    C4 --> L[チケット登録]
    L --> M[計画的に対応]
    
    style A fill:#ffcdd2,stroke:#c62828,stroke-width:2px
    style C1 fill:#ffcdd2,stroke:#c62828
    style D fill:#fff9c4,stroke:#f57f17
    style K fill:#c8e6c9,stroke:#2e7d32
```

**Runbook（運用手順書）の例：**

```markdown
# Runbook: 顧客検索APIのレスポンス遅延

## 症状
- 顧客検索APIのレスポンスが10秒以上かかる
- ユーザーから「検索が遅い」という問い合わせ

## 重要度
**High** - 業務に大きな影響

## 影響範囲
- 全ユーザーの検索機能
- 約100名が影響を受ける可能性

## 一次対処（10分以内）

### 1. 現状確認
```bash
# CloudWatch でレスポンスタイムを確認
aws cloudwatch get-metric-statistics \
  --namespace AWS/ApplicationELB \
  --metric-name TargetResponseTime \
  --start-time 2026-06-15T10:00:00Z \
  --end-time 2026-06-15T11:00:00Z \
  --period 300 \
  --statistics Average
```

### 2. サーバーリソース確認

```bash
# SSHでEC2にログイン
ssh ec2-user@prod-server

# CPU/メモリ確認
top

# ディスク確認
df -h

# プロセス確認
ps aux | grep java
```

### 3. ログ確認

```bash
# エラーログ確認
tail -100 /var/log/app/error.log | grep -i "slow\|timeout"

# アプリケーションログ確認
tail -100 /var/log/app/application.log | grep "search"
```

### 4. データベース確認

```bash
# 実行中のクエリ確認
psql -h db-server -U postgres -c "SELECT * FROM pg_stat_activity WHERE state = 'active';"

# スロークエリ確認
tail -50 /var/log/postgresql/postgresql.log | grep "duration:"
```

### 5. 暫定対処

#### ケースA: CPU/メモリ使用率が高い

```bash
# サーバー追加（オートスケーリング）
aws autoscaling set-desired-capacity \
  --auto-scaling-group-name customer-app-asg \
  --desired-capacity 4
```

#### ケースB: データベースがボトルネック

```bash
# キャッシュをクリアして再構築
redis-cli FLUSHALL
# アプリケーション再起動でキャッシュ再生成
systemctl restart customer-app
```

#### ケースC: 特定ユーザーの大量検索

```bash
# 該当ユーザーのセッションを確認
redis-cli KEYS "session:*" | xargs -I {} redis-cli GET {}
# 必要に応じてレート制限を強化
```

## 根本原因分析（RCA）

### 調査項目

1. いつから遅延が発生したか？
2. 特定の検索パターンで発生するか？
3. データ量の増加が原因か？
4. インデックスは適切か？
5. 外部APIの応答が遅いか？

### よくある原因と対策

| 原因 | 対策 |
|-----|------|
| データ量の増加 | パーティショニング、アーカイブ |
| インデックス不足 | 適切なインデックス追加 |
| N+1問題 | クエリ最適化、Eager Loading |
| キャッシュミス | キャッシュ戦略見直し |
| 外部API遅延 | タイムアウト設定、並列化 |

## 恒久対策

### 短期（1週間以内）

- スロークエリの最適化
- キャッシュ戦略の見直し
- アラート閾値の調整

### 中期（1ヶ月以内）

- データベースチューニング
- インフラスケールアップ
- 監視強化

### 長期（3ヶ月以内）

- アーキテクチャ改善
- 検索エンジン（Elasticsearch）導入検討
- マイクロサービス化検討

## エスカレーション

| 時間 | 連絡先 |
|-----|--------|
| 即座 | 運用リーダー（渡辺） 090-xxxx-xxxx |
| 30分以内 | 技術リーダー（高橋） 090-yyyy-yyyy |
| 1時間以内 | PM（田中） 090-zzzz-zzzz |
| 2時間以内 | 事業部長（山田） 090-aaaa-aaaa |

## 関連ドキュメント

- [アーキテクチャ設計書](link)
- [データベース設計書](link)
- [性能改善ガイド](link)

```

#### ④SLO管理

**SLOレポート（月次）：**

```markdown
# SLO レポート - 2026年6月

## サマリー

| 指標 | SLO目標 | 実績 | エラーバジェット消費 | 判定 |
|-----|---------|------|-------------------|------|
| 可用性 | 99.9% | 99.95% | 5% | ✓達成 |
| レスポンスタイム（95%ile） | 3秒 | 2.1秒 | - | ✓達成 |
| エラー率 | 1%以下 | 0.08% | 8% | ✓達成 |

**総合判定：✅ 全項目達成**

## 詳細

### 可用性: 99.95%（目標: 99.9%）

**月間ダウンタイム：** 21.6分（許容: 43.2分）

**エラーバジェット消費：** 5%（許容: 100%）

**ダウンタイム内訳：**
| 日時 | 時間 | 原因 | 対策 |
|-----|------|------|------|
| 6/10 10:15-10:30 | 15分 | DBフェイルオーバー | 自動復旧 |
| 6/22 02:00-02:07 | 7分 | 定期メンテナンス | 計画的 |

### レスポンスタイム

**95パーセンタイル：** 2.1秒（目標: 3秒以内）

**グラフ：**
```

  3.5秒 ┤           目標ライン
  3.0秒 ┤═══════════════════════════════
  2.5秒 ┤
  2.0秒 ┤  ●●●●●●●●●●●●●●●●●●●●●●●●  実績
  1.5秒 ┤
  1.0秒 ┤
  0.5秒 ┤
  0.0秒 └───────────────────────────────
         6/1    6/10    6/20    6/30

```

### エラー率

**月間エラー率：** 0.08%（目標: 1%以下）

**エラー内訳：**
| エラー種別 | 件数 | 割合 |
|-----------|------|------|
| タイムアウト | 45件 | 45% |
| データ不整合 | 30件 | 30% |
| 権限エラー | 25件 | 25% |
| **合計** | **100件** | **100%** |

## 改善アクション

### 実施済み
- [x] System A APIのタイムアウト設定最適化
- [x] キャッシュTTLの調整

### 実施予定
- [ ] データベースインデックス追加（7月第1週）
- [ ] 監視アラート閾値の見直し（7月第2週）

## 次月の目標

引き続き全項目でSLO達成を目指す。
特に可用性については、99.99%（Four 9）を目指す。
```

### 🎓 このフェーズのまとめ

**✅ やること：**

1. 日常運用（バックアップ、ログ確認）
2. リアルタイム監視
3. 障害対応（検知→復旧→分析→恒久対策）
4. SLO測定とレポート
5. 継続的改善

**📄 作るドキュメント：**

- 運用手順書（Runbook）
- SLO文書
- 月次運用レポート
- 障害報告書
- ポストモーテム

**⚠️ よくある失敗：**

- 監視を軽視する
- 障害対応がその場しのぎ
- SLOを測定していない
- ドキュメントの更新を怠る

**💡 成功のコツ：**

- **プロアクティブな監視**（問題が起きる前に検知）
- **根本原因分析**（RCA）を必ず行う
- **ポストモーテム文化**（責任追及ではなく学び）
- **継続的改善**（小さな改善の積み重ね）

---

# 第3章のまとめ

これで、システム開発の全8フェーズの詳細解説が完了しました！

## 📊 各フェーズの重要度マップ

```mermaid
graph TD
    A[システム開発] --> B[企画<br/>⭐⭐⭐<br/>方向性を決める]
    A --> C[要件定義<br/>⭐⭐⭐⭐⭐<br/>最重要！]
    A --> D[基本設計<br/>⭐⭐⭐⭐<br/>土台を作る]
    A --> E[詳細設計<br/>⭐⭐⭐<br/>実装の指針]
    A --> F[実装<br/>⭐⭐⭐<br/>コードを書く]
    A --> G[テスト<br/>⭐⭐⭐⭐<br/>品質を保証]
    A --> H[リリース<br/>⭐⭐⭐<br/>安全に公開]
    A --> I[運用保守<br/>⭐⭐⭐⭐<br/>継続的改善]
    
    style C fill:#ff5252,stroke:#c62828,color:#fff,stroke-width:4px
    style D fill:#ff9800,stroke:#e65100,stroke-width:3px
    style G fill:#ff9800,stroke:#e65100,stroke-width:3px
    style I fill:#ff9800,stroke:#e65100,stroke-width:3px
```

**最重要：** 要件定義（ここで80%が決まる）  
**重要：** 基本設計、テスト、運用保守  
**中程度：** その他のフェーズ

すべてのフェーズが大切ですが、特に**要件定義**に時間をかけることが成功の鍵です！

---

# 第4章：重要ドキュメント詳細解説

システム開発で作成される様々なドキュメントの中でも、特に重要な6つのドキュメントについて詳しく解説します。

## 📚 本章で解説するドキュメント

```mermaid
graph TD
    A[重要ドキュメント] --> B[SRS<br/>要求仕様書<br/>何を作るか]
    A --> C[AD<br/>アーキテクチャ記述書<br/>どう作るか]
    A --> D[テスト計画書<br/>どう確認するか]
    A --> E[SLO文書<br/>どう運用するか]
    A --> F[RTM<br/>トレーサビリティ<br/>追跡可能性]
    A --> G[ADR<br/>設計決定記録<br/>なぜそうしたか]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#ffcdd2,stroke:#c62828,stroke-width:2px
    style C fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
    style D fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    style E fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
    style F fill:#fff9c4,stroke:#f57f17,stroke-width:2px
    style G fill:#b3e5fc,stroke:#0277bd,stroke-width:2px
```

---

## 4.1 SRS（要求仕様書：Software Requirements Specification）

### 📖 SRSとは

**SRS（エスアールエス）**は、システムに求められる**全ての要求**を明文化したドキュメントです。「何を作るか」を定義する最も重要な文書で、**開発プロジェクトの憲法**とも言えます。

```mermaid
graph LR
    A[ビジネス要求] --> B[SRS作成]
    B --> C[機能要求<br/>FR]
    B --> D[非機能要求<br/>NFR]
    C --> E[設計・開発]
    D --> E
    E --> F[テスト]
    F --> G[受入]
    
    style A fill:#ffcdd2,stroke:#c62828
    style B fill:#fff9c4,stroke:#f57f17,stroke-width:3px
    style C fill:#c8e6c9,stroke:#2e7d32
    style D fill:#b3e5fc,stroke:#0277bd
```

### 🎯 SRSの目的

```mermaid
graph TD
    A[SRSの目的] --> B[📋 要求の明確化]
    A --> C[🤝 関係者の合意形成]
    A --> D[📏 開発の基準設定]
    A --> E[✅ 検証の基準定義]
    
    B --> B1[曖昧さを完全に排除]
    C --> C1[認識のズレを防止]
    D --> D1[何を作るか明確化]
    E --> E1[受入テストの基準]
    
    style A fill:#ff5252,stroke:#c62828,color:#fff,stroke-width:3px
    style B fill:#e1f5ff,stroke:#0277bd
    style C fill:#fff3e0,stroke:#ef6c00
    style D fill:#f3e5f5,stroke:#7b1fa2
    style E fill:#c8e6c9,stroke:#2e7d32
```

### 📝 SRSの基本構成

| セクション | 内容 | 重要度 |
|-----------|------|--------|
| **1. 概要** | プロジェクト背景、目的、スコープ | ⭐⭐⭐ |
| **2. 機能要求** | システムが提供する機能の詳細 | ⭐⭐⭐⭐⭐ |
| **3. 非機能要求** | 性能、セキュリティ、可用性など | ⭐⭐⭐⭐⭐ |
| **4. 外部インターフェース** | 外部システムとの連携仕様 | ⭐⭐⭐⭐ |
| **5. 制約条件** | 技術的・組織的制約 | ⭐⭐⭐ |
| **6. 受入基準** | 各要件の合格条件 | ⭐⭐⭐⭐⭐ |
| **7. 用語集** | プロジェクト固有の用語定義 | ⭐⭐⭐ |

### 📄 SRS詳細テンプレートと記載例

#### 1. ドキュメント情報セクション

```markdown
# ソフトウェア要求仕様書（SRS）
## 顧客管理システム リニューアルプロジェクト

### ドキュメント管理情報

| 項目 | 内容 |
|-----|------|
| **プロジェクト名** | 顧客管理システムリニューアル |
| **プロジェクトコード** | CRM-2025-001 |
| **ドキュメントバージョン** | 2.1 |
| **作成日** | 2025年10月1日 |
| **最終更新日** | 2025年10月22日 |
| **作成者** | 山田太郎（プロジェクトマネージャー） |
| **レビュー者** | 佐藤花子（システムアーキテクト）、田中次郎（QAリード） |
| **承認者** | 鈴木一郎（事業部長） |
| **ステータス** | ✅ 承認済み（Approved） |

### 改訂履歴

| バージョン | 日付 | 変更内容 | 変更者 | 承認者 |
|-----------|------|----------|--------|--------|
| 1.0 | 2025/09/01 | 初版作成 | 山田太郎 | - |
| 1.5 | 2025/09/25 | 要件レビュー反映 | 山田太郎 | - |
| 2.0 | 2025/10/10 | 顧客フィードバック反映 | 山田太郎 | 鈴木一郎 |
| 2.1 | 2025/10/22 | セキュリティ要件追加 | 山田太郎 | 鈴木一郎 |

### 配布先

- プロジェクトチーム全員
- ステークホルダー（営業部長、IT部長）
- 開発ベンダー（ABC株式会社）
- 品質保証部門
```

#### 2. プロジェクト概要セクション

```markdown
## 1. プロジェクト概要

### 1.1 背景

**現状の課題：**

当社の顧客管理システムは2015年に構築され、10年が経過しています。
以下の深刻な課題が発生しており、業務効率の大幅な低下を招いています。

| 課題 | 具体的な問題 | ビジネスへの影響 |
|-----|------------|----------------|
| **性能劣化** | 顧客検索に30秒以上かかる<br/>ピーク時は1分超 | ⚠️ 顧客対応の遅延<br/>⚠️ 営業機会の損失 |
| **スマホ非対応** | PCブラウザのみ対応<br/>画面が小さく操作困難 | ⚠️ 外出先での利用不可<br/>⚠️ 営業生産性の低下 |
| **連携困難** | 他システムとAPI連携なし<br/>CSV手動エクスポート/インポート | ⚠️ データ二重管理<br/>⚠️ 入力ミス多発 |
| **保守困難** | 古い技術スタック（ASP.NET 4.5）<br/>ドキュメント不足 | ⚠️ 改修に時間とコスト<br/>⚠️ 技術者確保困難 |
| **セキュリティ** | 暗号化なし<br/>監査ログなし | ⚠️ 情報漏洩リスク<br/>⚠️ コンプライアンス違反 |

**市場環境の変化：**
- 競合他社はクラウド型CRMを導入し、営業効率が30%向上
- 個人情報保護法改正により、より厳格な管理が必要
- リモートワーク推進により、モバイル対応が必須に

### 1.2 目的

本プロジェクトでは、最新技術を用いた新しい顧客管理システムを構築し、
以下のビジネス価値を実現します。

**定量的目標（KPI）：**
1. **業務効率の向上**
   - 顧客検索時間：30秒 → **3秒以内**（90%短縮）
   - データ入力時間：10分/件 → **5分/件**（50%短縮）
   - 月次レポート作成：4時間 → **30分**（87%短縮）

2. **営業生産性の向上**
   - 外出先での情報確認・更新を可能に（モバイル対応）
   - API連携による二重入力の削減（月間100時間の工数削減）
   - リアルタイムダッシュボードによる意思決定迅速化

3. **セキュリティ強化**
   - 個人情報保護法・GDPR完全準拠
   - 全通信の暗号化（TLS 1.3）
   - 監査ログによる完全な追跡可能性

**定性的目標：**
- ユーザー満足度の向上（使いやすいUI/UX）
- システムの保守性・拡張性の向上
- 技術的負債の解消

### 1.3 スコープ（対象範囲）

**本プロジェクトに含まれる機能：**

✅ **顧客情報管理**
- 顧客の登録・検索・編集・削除
- 企業情報・担当者情報の管理
- 顧客カテゴリ・タグ付け

✅ **活動履歴管理**
- 営業活動の記録（訪問、電話、メール）
- タイムライン表示
- ファイル添付（名刺、資料など）

✅ **検索・抽出機能**
- 高速全文検索（3秒以内）
- 詳細検索（複数条件の組み合わせ）
- お気に入り検索条件の保存

✅ **レポート・ダッシュボード**
- リアルタイムダッシュボード
- 月次レポート自動生成
- グラフ・チャート表示

✅ **外部システム連携**
- メール配信システム（SendGrid）
- 名刺管理システム（Sansan）
- 営業支援システム（Salesforce）
- 会計システム（freee）

✅ **モバイル対応**
- レスポンシブデザイン（PC、タブレット、スマホ）
- オフライン閲覧機能（PWA）

✅ **管理機能**
- ユーザー管理（登録・権限設定）
- 監査ログ閲覧
- システム設定

**本プロジェクトに含まれない機能：**

❌ **請求書発行機能**
- 理由：既存の会計システム（freee）を継続利用
- API連携により顧客情報は共有

❌ **在庫管理機能**
- 理由：別プロジェクトで専用システムを構築予定（2026年）
- 将来的な連携を考慮した設計とする

❌ **MAツール機能**
- 理由：外部のMAツール（HubSpot）を利用
- API連携により顧客データを同期

❌ **コールセンター機能**
- 理由：既存のCTIシステムを継続利用
- 顧客情報の参照APIを提供

### 1.4 前提条件

**技術的前提：**
- インターネット接続環境（常時接続）
- 推奨ブラウザ：Chrome、Edge、Safari（各最新版）
- 画面解像度：1280×720以上推奨

**組織的前提：**
- 専任プロジェクトマネージャー1名配置
- 開発チーム：5〜7名
- ユーザー代表：2名（営業部から選出）
- 月1回のステアリングコミッティ開催

**データ移行：**
- 現行システムから全顧客データを移行（約50,000件）
- 過去3年分の活動履歴を移行（約200,000件）
- 移行期間：2週間（テスト移行含む）

### 1.5 制約条件

**予算制約：**
- 開発費用：3,000万円以内
- 年間運用費用：300万円以内（クラウド費用、保守費用含む）

**スケジュール制約：**
- プロジェクト期間：6ヶ月（2025年11月〜2026年4月）
- リリース期日：2026年5月1日（期首に合わせる）
- 延期不可（営業計画に影響）

**技術制約：**
- クラウド環境：AWS利用必須（社内標準）
- 開発言語：TypeScript（フロントエンド）、Node.js（バックエンド）
- データベース：PostgreSQL（社内標準）
- 既存の社内SSO（Single Sign-On）と連携必須

**法規制制約：**
- 個人情報保護法準拠
- GDPR準拠（EU顧客データを扱う可能性）
- 電子帳簿保存法準拠（必要に応じて）

### 1.6 用語定義

| 用語 | 定義 |
|-----|------|
| **顧客** | 当社と取引がある、または取引の可能性がある企業・個人 |
| **担当者** | 顧客企業に所属する個人（窓口となる人物） |
| **活動履歴** | 営業活動の記録（訪問、電話、メールなど） |
| **リード** | 見込み客（まだ受注していない顧客） |
| **商談** | 具体的な案件・取引の進行状況 |
| **ダッシュボード** | 重要な指標をまとめて表示する画面 |
| **API** | 外部システムとデータをやり取りする仕組み |
| **SSO** | 一度のログインで複数システムにアクセスできる仕組み |
```

#### 3. 機能要求（Functional Requirements）

```markdown
## 2. 機能要求（Functional Requirements）

### 2.1 要件の記載方法

各機能要求には以下の情報を記載します：

- **要件ID**：一意の識別子（例：FR-001）
- **要件名**：機能の名称
- **優先度**：Must（必須）/ Should（重要）/ Could（あれば良い）/ Won't（対象外）
- **説明**：機能の概要
- **詳細仕様**：入力項目、処理内容、出力など
- **ビジネスルール**：業務上のルール・制約
- **受入基準**：Gherkin形式での合格条件

### 2.2 顧客管理機能

#### FR-001：顧客登録機能

**優先度：** Must（必須）

**説明：**
新規顧客情報を登録できる。企業情報と担当者情報を同時に登録可能。

**詳細仕様：**

**入力項目（企業情報）：**
| 項目名 | 必須/任意 | データ型 | 制約 | 例 |
|--------|----------|----------|------|-----|
| 企業名 | 必須 | 文字列 | 全角200文字以内 | 株式会社サンプル商事 |
| 企業名カナ | 必須 | 文字列 | 全角カタカナ200文字以内 | カブシキガイシャサンプルショウジ |
| 業種 | 必須 | 選択 | マスタから選択 | 製造業 |
| 従業員数 | 任意 | 数値 | 1〜999,999 | 500 |
| 資本金 | 任意 | 数値 | 1〜9,999,999（万円） | 10,000 |
| 設立年月日 | 任意 | 日付 | 西暦形式（YYYY/MM/DD） | 2000/04/01 |
| 郵便番号 | 任意 | 文字列 | 半角数字7桁（ハイフンなし） | 1000001 |
| 都道府県 | 任意 | 選択 | マスタから選択 | 東京都 |
| 市区町村 | 任意 | 文字列 | 全角100文字以内 | 千代田区千代田 |
| 番地・ビル名 | 任意 | 文字列 | 全角200文字以内 | 1-1-1 サンプルビル3F |
| 電話番号 | 任意 | 文字列 | 半角数字、ハイフン可、15文字以内 | 03-1234-5678 |
| FAX番号 | 任意 | 文字列 | 半角数字、ハイフン可、15文字以内 | 03-1234-5679 |
| WebサイトURL | 任意 | 文字列 | URL形式、200文字以内 | https://example.com |
| 備考 | 任意 | テキスト | 1,000文字以内 | - |

**入力項目（担当者情報）：**
| 項目名 | 必須/任意 | データ型 | 制約 | 例 |
|--------|----------|----------|------|-----|
| 氏名 | 必須 | 文字列 | 全角100文字以内 | 山田 太郎 |
| 氏名カナ | 必須 | 文字列 | 全角カタカナ100文字以内 | ヤマダ タロウ |
| 部署 | 任意 | 文字列 | 全角50文字以内 | 営業部 |
| 役職 | 任意 | 文字列 | 全角50文字以内 | 部長 |
| メールアドレス | 必須 | 文字列 | メール形式、100文字以内 | yamada@example.com |
| 電話番号（直通） | 任意 | 文字列 | 半角数字、ハイフン可、15文字以内 | 03-1234-5680 |
| 携帯電話 | 任意 | 文字列 | 半角数字、ハイフン可、15文字以内 | 090-1234-5678 |
| 生年月日 | 任意 | 日付 | 西暦形式（YYYY/MM/DD） | 1980/01/01 |

**バリデーション（入力チェック）：**
1. 必須項目が全て入力されているか
2. 文字数制限を超えていないか
3. データ型が正しいか（数値、日付、メールアドレス形式など）
4. 同一企業名が既に登録されている場合は警告を表示（登録は可能）
5. 同一メールアドレスが既に登録されている場合はエラー（登録不可）

**処理フロー：**
```mermaid
graph TD
    A[登録ボタンクリック] --> B{入力チェック}
    B -->|エラーあり| C[エラーメッセージ表示]
    C --> D[入力画面に戻る<br/>入力内容は保持]
    B -->|OK| E{企業名重複チェック}
    E -->|重複あり| F[警告表示<br/>続行確認]
    F -->|キャンセル| D
    F -->|続行| G{メールアドレス<br/>重複チェック}
    E -->|重複なし| G
    G -->|重複あり| H[エラー表示<br/>登録不可]
    H --> D
    G -->|重複なし| I[データベース登録]
    I --> J[ウェルカムメール送信]
    J --> K[確認画面表示]
    K --> L[顧客一覧画面へ遷移]
    
    style B fill:#fff9c4
    style E fill:#fff9c4
    style G fill:#fff9c4
    style I fill:#c8e6c9
    style C fill:#ffcdd2
    style H fill:#ffcdd2
```

**ビジネスルール：**

- 顧客IDは自動採番（CUS + 8桁の連番、例：CUS00000001）
- 登録日時は自動設定（システム日時）
- 登録者は自動設定（ログインユーザー）
- 初期ステータスは「リード」に設定
- 担当営業は登録者に自動設定（後から変更可能）

**画面イメージ：**

```
┌──────────────────────────────────────────┐
│  新規顧客登録                              │
├──────────────────────────────────────────┤
│                                           │
│  【企業情報】                              │
│  企業名 *     [_____________________]     │
│  企業名カナ *  [_____________________]     │
│  業種 *       [選択▼]                     │
│  従業員数     [_____] 人                  │
│  資本金       [_____] 万円                │
│  設立年月日   [____/__/__]                │
│                                           │
│  郵便番号     [___-____]  [住所検索]      │
│  都道府県     [選択▼]                     │
│  市区町村     [_____________________]     │
│  番地・ビル名  [_____________________]     │
│                                           │
│  電話番号     [___-____-____]             │
│  FAX番号      [___-____-____]             │
│  WebサイトURL [_____________________]     │
│                                           │
│  【担当者情報】                            │
│  氏名 *       [_____________________]     │
│  氏名カナ *    [_____________________]     │
│  部署         [_____________________]     │
│  役職         [_____________________]     │
│  メールアドレス * [_____________________] │
│  電話番号（直通）[___-____-____]          │
│  携帯電話     [___-____-____]             │
│                                           │
│  備考                                     │
│  [________________________________]       │
│  [________________________________]       │
│  [________________________________]       │
│                                           │
│         [キャンセル]    [登録]            │
└──────────────────────────────────────────┘
```

**受入基準（Acceptance Criteria）：**

```gherkin
Feature: 顧客登録機能

Background:
  Given ユーザーが管理者権限でログインしている
  And 顧客登録画面を開いている

Scenario: 正常系 - 全ての必須項目を入力して顧客を登録できる
  When 以下の企業情報を入力する
    | 項目 | 値 |
    | 企業名 | 株式会社テスト商事 |
    | 企業名カナ | カブシキガイシャテストショウジ |
    | 業種 | 製造業 |
  And 以下の担当者情報を入力する
    | 項目 | 値 |
    | 氏名 | 山田 太郎 |
    | 氏名カナ | ヤマダ タロウ |
    | メールアドレス | yamada@test.com |
  And 「登録」ボタンをクリックする
  Then 顧客情報がデータベースに保存される
  And 顧客IDが自動採番される（形式：CUS########）
  And 登録日時が記録される
  And 登録者が記録される
  And ステータスが「リード」に設定される
  And 「登録が完了しました」というメッセージが表示される
  And yamada@test.com宛にウェルカムメールが送信される
  And 顧客一覧画面に遷移する
  And 登録した顧客が一覧に表示される

Scenario: 異常系 - 必須項目が未入力の場合エラーになる
  When 企業名を入力せずに「登録」ボタンをクリックする
  Then 「企業名は必須です」というエラーメッセージが表示される
  And 企業名の入力欄が赤くハイライトされる
  And 顧客情報は登録されない
  And 入力済みの他の項目の内容は保持される

Scenario: 異常系 - メールアドレスが重複している場合エラーになる
  Given メールアドレス "yamada@test.com" の担当者が既に登録されている
  When 以下の情報を入力する
    | 項目 | 値 |
    | 企業名 | 株式会社新規商事 |
    | 企業名カナ | カブシキガイシャシンキショウジ |
    | 業種 | 卸売業 |
    | 氏名 | 鈴木 一郎 |
    | 氏名カナ | スズキ イチロウ |
    | メールアドレス | yamada@test.com |
  And 「登録」ボタンをクリックする
  Then 「このメールアドレスは既に登録されています」というエラーメッセージが表示される
  And メールアドレスの入力欄が赤くハイライトされる
  And 顧客情報は登録されない

Scenario: 警告系 - 企業名が重複している場合警告が表示されるが登録可能
  Given 企業名 "株式会社テスト商事" の企業が既に登録されている
  When 以下の情報を入力する
    | 項目 | 値 |
    | 企業名 | 株式会社テスト商事 |
    | 企業名カナ | カブシキガイシャテストショウジ |
    | 業種 | 製造業 |
    | 氏名 | 佐藤 花子 |
    | 氏名カナ | サトウ ハナコ |
    | メールアドレス | sato@test.com |
  And 「登録」ボタンをクリックする
  Then 「同じ企業名が既に登録されています。続けますか？」という警告が表示される
  When 「続ける」をクリックする
  Then 顧客情報がデータベースに保存される
  And 確認画面が表示される

Scenario: 境界値テスト - 企業名が200文字（上限）の場合
  When 企業名に200文字の文字列を入力する
  And その他の必須項目を正しく入力する
  And 「登録」ボタンをクリックする
  Then 顧客情報が正常に登録される

Scenario: 境界値テスト - 企業名が201文字（上限超過）の場合
  When 企業名に201文字の文字列を入力する
  And その他の必須項目を正しく入力する
  And 「登録」ボタンをクリックする
  Then 「企業名は200文字以内で入力してください」というエラーメッセージが表示される
  And 顧客情報は登録されない

Scenario: 郵便番号から住所を自動入力できる
  When 郵便番号に "1000001" を入力する
  And 「住所検索」ボタンをクリックする
  Then 都道府県に "東京都" が自動入力される
  And 市区町村に "千代田区千代田" が自動入力される

Scenario: キャンセルボタンで入力内容を破棄できる
  When 企業名に "株式会社テスト" を入力する
  And 「キャンセル」ボタンをクリックする
  Then 「入力内容は保存されません。よろしいですか？」という確認ダイアログが表示される
  When 「OK」をクリックする
  Then 顧客一覧画面に戻る
  And 入力内容は保存されない
```

**非機能要求：**

- レスポンスタイム：登録処理は1秒以内に完了すること
- エラーメッセージ：具体的で分かりやすい内容であること
- アクセシビリティ：キーボードのみで全操作が可能であること
- 監査ログ：誰がいつ登録したか記録すること

---

#### FR-002：顧客検索機能

**優先度：** Must（必須）

**説明：**
登録済みの顧客を様々な条件で検索できる。検索結果は一覧表示し、ソート・ページングが可能。

**詳細仕様：**

**検索条件：**

| 項目名 | 検索方法 | 備考 |
|--------|---------|------|
| 企業名 | 部分一致 | 前方一致・後方一致・中間一致に対応 |
| 企業名カナ | 部分一致 | 前方一致・後方一致・中間一致に対応 |
| 担当者名 | 部分一致 | 姓のみ、名のみでも検索可能 |
| メールアドレス | 部分一致 | ドメインのみでも検索可能 |
| 電話番号 | 部分一致 | ハイフンなしでも検索可能 |
| 業種 | 完全一致（複数選択可） | チェックボックスで選択 |
| 都道府県 | 完全一致（複数選択可） | チェックボックスで選択 |
| 従業員数 | 範囲指定 | 「〜以上」「〜以下」「〜から〜まで」 |
| 資本金 | 範囲指定 | 「〜以上」「〜以下」「〜から〜まで」 |
| 登録日 | 期間指定 | 「〜から〜まで」「最近7日間」など |
| ステータス | 完全一致（複数選択可） | リード/商談中/受注/失注 |
| 担当営業 | 完全一致（複数選択可） | ユーザーマスタから選択 |
| タグ | 完全一致（複数選択可） | AND/OR条件切り替え可能 |

**検索結果表示：**

| 表示項目 | 説明 |
|---------|------|
| 企業名 | クリックで詳細画面へ遷移 |
| 業種 | - |
| 担当者名 | 主担当者のみ表示 |
| 電話番号 | 企業の代表電話 |
| メールアドレス | 主担当者のメール |
| ステータス | 色分けして表示 |
| 担当営業 | - |
| 登録日 | YYYY/MM/DD形式 |
| 最終更新日 | YYYY/MM/DD HH:MM形式 |

**ソート機能：**

- ソート可能項目：企業名、登録日、最終更新日
- 昇順・降順の切り替え可能
- デフォルト：最終更新日の降順

**ページング機能：**

- 1ページあたりの表示件数：10件 / 25件 / 50件 / 100件（選択可能）
- デフォルト：50件
- 「前へ」「次へ」「最初」「最後」ボタン
- ページ番号の直接入力も可能

**検索条件の保存：**

- 「お気に入り検索」として保存可能
- 保存名を付けられる（例：「関東地方の製造業」）
- 保存した検索は一覧から選択して即座に実行可能

**エクスポート機能：**

- 検索結果をCSV形式でダウンロード可能
- 最大10,000件まで一度にエクスポート可能

**処理フロー：**

```mermaid
graph TD
    A[検索画面を開く] --> B[検索条件を入力]
    B --> C[検索ボタンクリック]
    C --> D{検索条件の<br/>バリデーション}
    D -->|エラーあり| E[エラーメッセージ表示]
    E --> B
    D -->|OK| F[データベース検索]
    F --> G{検索結果あり?}
    G -->|0件| H[「該当する顧客が<br/>見つかりませんでした」<br/>メッセージ表示]
    G -->|1件以上| I[検索結果一覧表示]
    I --> J[ソート・ページング]
    J --> K[顧客をクリック]
    K --> L[顧客詳細画面へ遷移]
    
    I --> M[エクスポートボタン]
    M --> N[CSV生成・ダウンロード]
    
    B --> O[お気に入り検索から選択]
    O --> C
    
    style F fill:#c8e6c9
    style I fill:#c8e6c9
    style H fill:#fff9c4
    style E fill:#ffcdd2
```

**性能要求：**

- 検索処理は3秒以内に完了すること（95パーセンタイル）
- 100万件のデータに対しても3秒以内に結果を返すこと
- 同時に50ユーザーが検索しても性能が劣化しないこと

**受入基準：**

```gherkin
Feature: 顧客検索機能

Background:
  Given ユーザーがログインしている
  And 顧客データベースに以下のデータが登録されている
    | 企業名 | 業種 | 都道府県 | 担当者名 | メールアドレス | 登録日 |
    | 株式会社ABC商事 | 製造業 | 東京都 | 山田太郎 | yamada@abc.com | 2025/10/01 |
    | 株式会社DEF物産 | 卸売業 | 大阪府 | 鈴木一郎 | suzuki@def.com | 2025/10/05 |
    | GHI株式会社 | 製造業 | 東京都 | 田中花子 | tanaka@ghi.com | 2025/10/10 |

Scenario: 正常系 - 企業名で部分一致検索できる
  Given 顧客検索画面を開いている
  When 企業名に "ABC" を入力する
  And 「検索」ボタンをクリックする
  Then 3秒以内に検索結果が表示される
  And 検索結果に "株式会社ABC商事" が表示される
  And 検索結果の件数が "1件" と表示される

Scenario: 正常系 - 複数条件で検索できる
  Given 顧客検索画面を開いている
  When 業種で "製造業" を選択する
  And 都道府県で "東京都" を選択する
  And 「検索」ボタンをクリックする
  Then 検索結果に "株式会社ABC商事" が表示される
  And 検索結果に "GHI株式会社" が表示される
  And 検索結果の件数が "2件" と表示される
  And "株式会社DEF物産" は表示されない

Scenario: 正常系 - 検索結果をソートできる
  Given 顧客検索画面で全件検索している
  And 検索結果が3件表示されている
  When 「登録日」列のヘッダーをクリックする
  Then 検索結果が登録日の昇順でソートされる
  And 1番目に "株式会社ABC商事" が表示される
  And 3番目に "GHI株式会社" が表示される
  When 再度「登録日」列のヘッダーをクリックする
  Then 検索結果が登録日の降順でソートされる
  And 1番目に "GHI株式会社" が表示される

Scenario: 正常系 - 検索条件をお気に入りとして保存できる
  Given 顧客検索画面を開いている
  When 業種で "製造業" を選択する
  And 都道府県で "東京都" を選択する
  And 「お気に入りとして保存」ボタンをクリックする
  And お気に入り名を "東京の製造業" と入力する
  And 「保存」ボタンをクリックする
  Then 「お気に入り検索として保存しました」というメッセージが表示される
  And お気に入り検索一覧に "東京の製造業" が追加される

Scenario: 正常系 - 保存したお気に入り検索を実行できる
  Given お気に入り検索に "東京の製造業" が保存されている
  And 顧客検索画面を開いている
  When お気に入り検索一覧から "東京の製造業" を選択する
  Then 検索条件が自動的に入力される
  And 検索が自動的に実行される
  And 検索結果に東京都の製造業の顧客のみが表示される

Scenario: 正常系 - 検索結果をCSVエクスポートできる
  Given 顧客検索画面で全件検索している
  And 検索結果が3件表示されている
  When 「CSVエクスポート」ボタンをクリックする
  Then CSVファイルがダウンロードされる
  And CSVファイルには3件の顧客データが含まれる
  And CSVファイルのヘッダー行に全ての列名が含まれる

Scenario: 境界値テスト - 検索結果が0件の場合
  Given 顧客検索画面を開いている
  When 企業名に "存在しない企業" を入力する
  And 「検索」ボタンをクリックする
  Then 「該当する顧客が見つかりませんでした」というメッセージが表示される
  And 検索結果一覧は空である

Scenario: 性能テスト - 100万件のデータでも3秒以内に検索できる
  Given 顧客データベースに100万件のデータが登録されている
  And 顧客検索画面を開いている
  When 企業名に "テスト" を入力する
  And 「検索」ボタンをクリックする
  And 検索開始時刻を記録する
  And 検索完了時刻を記録する
  Then 検索処理時間が3秒以内である
  And 検索結果が正しく表示される

Scenario: ページング機能 - 50件ずつ表示できる
  Given 顧客データベースに150件のデータが登録されている
  And 顧客検索画面で全件検索している
  And 1ページあたりの表示件数を "50件" に設定している
  Then 1ページ目に50件の顧客が表示される
  And ページ数が "1 / 3" と表示される
  When 「次へ」ボタンをクリックする
  Then 2ページ目に50件の顧客が表示される
  And ページ数が "2 / 3" と表示される
```

---

この形式で、FR-003以降も続けていきます。次のパートで非機能要求やその他のセクションを追加します。

### 2.3 非機能要求（Non-Functional Requirements）

非機能要求は、システムの「性能」「品質」「制約」に関する要件です。
機能要求が「何ができるか」を定義するのに対し、非機能要求は「どのように動くべきか」を定義します。

```mermaid
graph TD
    A[非機能要求] --> B[性能要求]
    A --> C[可用性要求]
    A --> D[セキュリティ要求]
    A --> E[ユーザビリティ要求]
    A --> F[保守性要求]
    A --> G[移植性要求]
    A --> H[法規制要求]
    
    B --> B1[レスポンスタイム<br/>スループット<br/>リソース使用率]
    C --> C1[稼働率<br/>障害復旧時間<br/>バックアップ]
    D --> D1[認証・認可<br/>暗号化<br/>監査ログ]
    E --> E1[使いやすさ<br/>アクセシビリティ<br/>多言語対応]
    F --> F1[コード品質<br/>ドキュメント<br/>テスト容易性]
    G --> G1[プラットフォーム<br/>ブラウザ対応<br/>環境移行]
    H --> H1[法令準拠<br/>業界標準<br/>監査対応]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
```

#### NFR-001：性能要求（Performance Requirements）

**優先度：** Must（必須）

**レスポンスタイム：**

| 操作 | 目標値（95パーセンタイル） | 測定条件 |
|-----|---------------------------|----------|
| ページ表示 | 2秒以内 | 初回表示、キャッシュなし |
| 顧客検索 | 3秒以内 | 100万件のデータに対して |
| 顧客登録 | 1秒以内 | 通常負荷時 |
| 顧客編集 | 1秒以内 | 通常負荷時 |
| ダッシュボード表示 | 3秒以内 | リアルタイムデータ集計含む |
| レポート生成 | 10秒以内 | 月次レポート、データ1年分 |
| CSVエクスポート | 5秒以内 | 1,000件まで |

**スループット：**

- 同時ユーザー数：100ユーザーまで対応
- ピーク時：200ユーザーまで対応（短時間）
- APIリクエスト：1,000リクエスト/秒まで対応

**リソース使用率（通常負荷時）：**

- CPU使用率：平均50%以下、ピーク70%以下
- メモリ使用率：平均60%以下、ピーク80%以下
- ディスク使用率：70%以下（アラート発火）
- ネットワーク帯域：1Gbpsで十分（予測値）

**データ容量：**

- 顧客データ：100万件まで格納可能
- 活動履歴：1,000万件まで格納可能
- 添付ファイル：1TB（拡張可能）
- データベース容量：初期500GB、最大2TBまで拡張可能

**受入基準：**

```gherkin
Feature: 性能要求

Scenario: レスポンスタイム - 顧客検索が3秒以内
  Given 顧客データベースに100万件のデータが登録されている
  And 性能測定ツールを準備している
  When 50ユーザーが同時に顧客検索を実行する
  And 各ユーザーが10回ずつ検索を繰り返す（合計500回）
  And レスポンスタイムを測定する
  Then 95パーセンタイル値が3秒以内である
  And 平均レスポンスタイムが2秒以内である
  And エラー率が1%以下である

Scenario: スループット - 100ユーザー同時接続
  Given システムが正常に稼働している
  When 100ユーザーが同時にログインする
  And 各ユーザーが顧客一覧画面を開く
  Then 全てのユーザーが2秒以内に画面を表示できる
  And エラーが発生しない

Scenario: リソース使用率 - CPU使用率が70%以下
  Given システムが通常負荷で稼働している
  When 1時間にわたってCPU使用率を監視する
  Then 平均CPU使用率が50%以下である
  And 最大CPU使用率が70%以下である
```

---

#### NFR-002：可用性要求（Availability Requirements）

**優先度：** Must（必須）

**稼働率：**

- **目標稼働率**：99.9%以上（年間ダウンタイム8.76時間以内）
- **月間ダウンタイム**：43.2分以内（計画停止除く）

**稼働率の計算：**

```
可用性(%) = (総稼働時間 - ダウンタイム) / 総稼働時間 × 100

例：
- 月間総時間：30日 × 24時間 = 720時間 = 43,200分
- ダウンタイム：30分
- 可用性 = (43,200 - 30) / 43,200 × 100 = 99.93%
```

**計画停止：**

- 頻度：毎月第3日曜日
- 時間帯：午前2:00〜5:00（最大3時間）
- 事前通知：2週間前にメール通知
- 年間計画停止：最大36時間（稼働率計算から除外）

**障害復旧目標：**

| 指標 | 目標値 | 説明 |
|-----|--------|------|
| **RTO**（Recovery Time Objective） | 2時間以内 | 障害発生から復旧までの目標時間 |
| **RPO**（Recovery Point Objective） | 15分以内 | 復旧時点の目標（データ損失許容範囲） |
| **MTBF**（Mean Time Between Failures） | 720時間以上 | 平均故障間隔 |
| **MTTR**（Mean Time To Repair） | 1時間以内 | 平均復旧時間 |

**バックアップ：**

- **頻度**：
  - フルバックアップ：毎日午前3:00
  - 増分バックアップ：4時間ごと
  - トランザクションログ：リアルタイム
- **保存期間**：
  - 日次バックアップ：7日間
  - 週次バックアップ：4週間
  - 月次バックアップ：12ヶ月
- **保存場所**：
  - プライマリ：AWS S3（東京リージョン）
  - セカンダリ：AWS S3（大阪リージョン）

**冗長化構成：**

```mermaid
graph TD
    A[ユーザー] --> B[AWS CloudFront<br/>CDN]
    B --> C[AWS ALB<br/>ロードバランサー]
    C --> D1[Webサーバー1<br/>AZ-A]
    C --> D2[Webサーバー2<br/>AZ-C]
    D1 --> E[AWS RDS<br/>PostgreSQL<br/>Multi-AZ]
    D2 --> E
    E --> F[プライマリDB<br/>AZ-A]
    E --> G[スタンバイDB<br/>AZ-C]
    F -.自動レプリケーション.-> G
    
    style A fill:#e3f2fd
    style C fill:#fff9c4
    style D1 fill:#c8e6c9
    style D2 fill:#c8e6c9
    style E fill:#ffccbc,stroke:#e64a19,stroke-width:2px
    style F fill:#b2dfdb
    style G fill:#b2dfdb
```

**障害時の自動切り替え：**

- Webサーバー：ヘルスチェック失敗時、自動的に正常なサーバーへ切り替え（30秒以内）
- データベース：プライマリDB障害時、自動的にスタンバイDBへフェイルオーバー（60秒以内）

**受入基準：**

```gherkin
Feature: 可用性要求

Scenario: 稼働率99.9%を達成している
  Given システムが1ヶ月間稼働している
  When 稼働時間とダウンタイムを集計する
  Then 可用性が99.9%以上である
  And 計画停止時間は除外されている

Scenario: バックアップが正常に実行される
  Given システムが稼働している
  When 毎日午前3:00になる
  Then フルバックアップが自動的に実行される
  And バックアップファイルがS3に保存される
  And バックアップ完了通知がSlackに送信される
  And バックアップファイルが正常に復元可能である

Scenario: データベースのフェイルオーバーが60秒以内
  Given Multi-AZ構成のRDSが稼働している
  And プライマリDBが正常に動作している
  When プライマリDBを強制停止する
  And フェイルオーバー開始時刻を記録する
  Then 60秒以内にスタンバイDBがプライマリに昇格する
  And アプリケーションが自動的に新しいプライマリDBに接続する
  And ユーザーは継続してシステムを利用できる
  And データ損失が15分以内である

Scenario: 障害からの復旧が2時間以内
  Given システムに重大な障害が発生した
  And 障害発生時刻を記録する
  When 運用チームが障害対応を開始する
  And バックアップからシステムを復元する
  And 復旧完了時刻を記録する
  Then 復旧時間が2時間以内である
  And データ損失が15分以内である
```

---

#### NFR-003：セキュリティ要求（Security Requirements）

**優先度：** Must（必須）

**認証（Authentication）：**

- **認証方式**：
  - 社内SSO（Single Sign-On）連携
  - フォールバック：ID/パスワード認証
  - 多要素認証（MFA）：管理者は必須、一般ユーザーは推奨
- **パスワードポリシー**：
  - 最低8文字以上
  - 英大文字・小文字・数字・記号を各1文字以上含む
  - 過去3回のパスワードは再利用不可
  - 90日ごとに変更を促す
  - パスワード強度メーターを表示
- **アカウントロック**：
  - 5回連続ログイン失敗で30分間ロック
  - 管理者による手動ロック解除が可能

**認可（Authorization）：**

- **ロールベースアクセス制御（RBAC）**：
  
| ロール | 権限 | 対象ユーザー |
|--------|------|-------------|
| **admin** | 全ての操作が可能（ユーザー管理、システム設定含む） | システム管理者（2名） |
| **manager** | 顧客の作成・編集・削除・閲覧、レポート閲覧 | 営業マネージャー（10名） |
| **staff** | 顧客の作成・編集・閲覧（削除不可）、自分の活動履歴のみ編集 | 一般営業（180名） |
| **viewer** | 顧客の閲覧のみ（編集・削除不可） | 営業アシスタント（8名） |

**データ保護：**

- **保存時の暗号化**：
  - データベース：AES-256暗号化（AWS RDS暗号化）
  - ファイルストレージ：サーバーサイド暗号化（S3 SSE-S3）
  - 個人情報（メール、電話番号）：アプリケーションレベルで追加暗号化
  - パスワード：bcryptでハッシュ化（ソルト付き、コスト係数12）
- **通信時の暗号化**：
  - クライアント⇔サーバー：TLS 1.3
  - サーバー⇔データベース：TLS 1.2以上
  - サーバー⇔外部API：TLS 1.2以上
  - 証明書：Let's Encrypt（自動更新）

**セッション管理：**

- セッションタイムアウト：30分（無操作時）
- セッション固定攻撃対策：ログイン時にセッションIDを再生成
- ログアウト時にセッションを完全に破棄

**監査ログ：**

- **記録対象**：
  - ログイン・ログアウト
  - 顧客データの作成・編集・削除
  - 検索実行（検索条件含む）
  - CSVエクスポート
  - 設定変更
  - 権限変更
- **記録項目**：
  - ユーザーID
  - 操作日時（ミリ秒単位）
  - 操作内容
  - IPアドレス
  - ユーザーエージェント
  - 操作結果（成功/失敗）
  - 変更前後の値（重要な操作のみ）
- **保存期間**：3年間（法令対応）
- **改ざん防止**：ログは追記のみ、削除・編集不可

**脆弱性対策（OWASP Top 10）：**

| 脆弱性 | 対策 |
|--------|------|
| **SQLインジェクション** | プリペアドステートメント使用、入力値のエスケープ |
| **XSS** | 出力時のHTMLエスケープ、Content Security Policy設定 |
| **CSRF** | CSRFトークンの検証 |
| **認証の不備** | 強固なパスワードポリシー、MFA、セッション管理 |
| **機密情報の露出** | エラーメッセージで機密情報を表示しない、暗号化 |
| **アクセス制御の不備** | RBAC、権限チェックの徹底 |
| **セキュリティ設定ミス** | セキュリティヘッダー設定、不要なポート閉鎖 |
| **XXE** | XML入力の検証、外部エンティティの無効化 |
| **安全でない逆シリアル化** | 信頼できないデータの逆シリアル化を避ける |
| **既知の脆弱性** | 依存ライブラリの定期的な更新、脆弱性スキャン |

**セキュリティテスト：**

- ペネトレーションテスト：リリース前に実施
- 脆弱性診断：四半期ごとに実施
- 依存ライブラリのスキャン：CI/CDパイプラインで自動実行

**受入基準：**

```gherkin
Feature: セキュリティ要求

Scenario: パスワードポリシーに準拠していないパスワードは登録できない
  Given パスワード変更画面を開いている
  When 新しいパスワードに "abc123" を入力する（8文字未満、記号なし）
  And 「変更」ボタンをクリックする
  Then 「パスワードは8文字以上で、英大文字・小文字・数字・記号を含む必要があります」というエラーが表示される
  And パスワードは変更されない

Scenario: 5回連続ログイン失敗でアカウントがロックされる
  Given ユーザーアカウント "test@example.com" が存在する
  When 誤ったパスワードで4回ログインを試みる
  Then ログインは失敗するがアカウントはロックされない
  When 5回目も誤ったパスワードでログインを試みる
  Then 「アカウントがロックされました。30分後に再度お試しください」というメッセージが表示される
  When 正しいパスワードでログインを試みる
  Then ログインできない
  When 30分後に正しいパスワードでログインを試みる
  Then ログインに成功する

Scenario: 全ての通信がTLS 1.3で暗号化されている
  Given システムにアクセスする
  When ブラウザの開発者ツールでHTTPS接続を確認する
  Then TLS 1.3以上で暗号化されている
  And HTTPでのアクセスは自動的にHTTPSにリダイレクトされる

Scenario: 操作が監査ログに記録される
  Given ユーザー "yamada@example.com" がログインしている
  When 新規顧客を登録する
  Then 監査ログに以下の情報が記録される
    | 項目 | 値 |
    | ユーザーID | yamada@example.com |
    | 操作 | 顧客登録 |
    | 顧客ID | (登録された顧客のID) |
    | IPアドレス | (ログインしたIPアドレス) |
    | タイムスタンプ | (操作時刻) |
  And 監査ログは削除・編集できない

Scenario: SQLインジェクション攻撃が防がれる
  Given 顧客検索画面を開いている
  When 検索欄に "' OR '1'='1" を入力する
  And 「検索」ボタンをクリックする
  Then SQLインジェクションは実行されない
  And 通常の検索として処理される
  And エラーメッセージは表示されない

Scenario: XSS攻撃が防がれる
  Given 顧客登録画面を開いている
  When 企業名に "<script>alert('XSS')</script>" を入力する
  And 顧客を登録する
  And 登録した顧客の詳細画面を開く
  Then スクリプトは実行されない
  And "<script>alert('XSS')</script>" という文字列がそのまま表示される

Scenario: 管理者以外はユーザー管理画面にアクセスできない
  Given 一般ユーザー（staffロール）でログインしている
  When URL直接入力でユーザー管理画面にアクセスを試みる
  Then 「この機能にアクセスする権限がありません」というエラーが表示される
  And HTTP 403 Forbiddenが返される
  And ユーザー管理画面は表示されない
```

---

#### NFR-004：ユーザビリティ要求（Usability Requirements）

**優先度：** Must（必須）

**使いやすさの目標：**

- 新規ユーザーが基本操作を習得するまで：1時間以内
- 主要タスク（顧客登録）の完了時間：3分以内
- ユーザー満足度：80%以上（5段階評価で4以上）

**UI/UXの原則：**

1. **一貫性**：全画面で共通のデザインパターン
2. **フィードバック**：操作結果を即座に表示
3. **エラー防止**：入力ミスを防ぐ設計（例：必須項目の明示）
4. **回復可能性**：誤操作からの復帰を容易に（例：削除の確認ダイアログ）
5. **効率性**：頻繁な操作をショートカットで実行可能

**レスポンシブデザイン：**

| デバイス | 画面サイズ | 対応内容 |
|---------|-----------|----------|
| **PC** | 1280px以上 | フル機能、3カラムレイアウト |
| **タブレット** | 768px〜1279px | フル機能、2カラムレイアウト、一部メニュー折りたたみ |
| **スマートフォン** | 〜767px | 主要機能のみ、1カラムレイアウト、ハンバーガーメニュー |

**アクセシビリティ：**

- **WCAG 2.1 レベルAA準拠**
- **キーボード操作**：全機能をキーボードのみで操作可能
- **スクリーンリーダー対応**：適切なARIA属性の付与
- **色のコントラスト比**：4.5:1以上（通常テキスト）、3:1以上（大きなテキスト）
- **フォーカスの可視化**：現在フォーカスしている要素が明確に分かる

**多言語対応：**

- 日本語（デフォルト）
- 英語
- 言語切り替えはヘッダーから即座に可能

**ヘルプ機能：**

- コンテキストヘルプ：各画面に「？」アイコンを配置、クリックでその画面のヘルプを表示
- オンラインマニュアル：全機能の詳細マニュアル
- チュートリアル動画：主要機能（5〜10分程度）
- FAQページ：よくある質問と回答

**エラーメッセージ：**

- 具体的で分かりやすい内容
- 問題の原因と解決方法を明示
- 技術的な詳細（エラーコードなど）は非表示、必要時のみ表示

**良いエラーメッセージの例：**

```
❌ 悪い例：
「エラーが発生しました。（エラーコード：ERR_DB_001）」

✅ 良い例：
「メールアドレスが既に登録されています。
別のメールアドレスを使用するか、既存の顧客を編集してください。」
```

**受入基準：**

```gherkin
Feature: ユーザビリティ要求

Scenario: 新規ユーザーが1時間以内に基本操作を習得できる
  Given 本システムを初めて使用するユーザーが5名いる
  And 各ユーザーにチュートリアルを提供する
  When 各ユーザーが以下のタスクを実行する
    | タスク |
    | ログイン |
    | 顧客を登録する |
    | 顧客を検索する |
    | 顧客情報を編集する |
    | 活動履歴を登録する |
  And 所要時間を測定する
  Then 全ユーザーが60分以内に全タスクを完了できる
  And ユーザー満足度アンケートで平均4点以上（5点満点）を獲得する

Scenario: レスポンシブデザインがスマホで正しく表示される
  Given スマートフォン（iPhone 13、375px × 667px）でアクセスする
  When 顧客一覧画面を開く
  Then 画面が横スクロールせずに表示される
  And 全てのボタンが指で押しやすいサイズである（最小44px × 44px）
  And 文字が読みやすいサイズである（最小16px）

Scenario: キーボードのみで全操作ができる
  Given PCでシステムにアクセスする
  And マウスを使用しない
  When Tabキーで要素間を移動する
  And Enterキーでボタンをクリックする
  And 矢印キーでメニューを選択する
  Then 顧客登録から検索、編集、削除まで全ての操作ができる
  And 現在フォーカスしている要素が明確に分かる

Scenario: エラーメッセージが分かりやすい
  Given 顧客登録画面で必須項目を入力せずに登録を試みる
  When 「登録」ボタンをクリックする
  Then 「企業名は必須です」という具体的なエラーメッセージが表示される
  And エラーが発生した項目が赤くハイライトされる
  And エラーメッセージの横に修正方法が表示される
  And 技術的なエラーコードは表示されない

Scenario: コンテキストヘルプが表示される
  Given 顧客登録画面を開いている
  When 企業名の入力欄の横にある「？」アイコンをクリックする
  Then 「企業名には正式名称を入力してください。（例：株式会社サンプル商事）」というヘルプが表示される
  And ヘルプは画面遷移せずにポップアップで表示される

Scenario: 色のコントラスト比がWCAG基準を満たす
  Given システムの全ての画面を確認する
  When 各テキストの色と背景色のコントラスト比を測定する
  Then 全ての通常テキストがコントラスト比4.5:1以上である
  And 全ての大きなテキストがコントラスト比3:1以上である
  And ボタンとリンクがコントラスト比3:1以上である
```

---

次のパートで、アーキテクチャ記述書（AD）、テスト計画書、SLO、RTM、ADRについて解説します。

## 4.2 アーキテクチャ記述書（AD：Architecture Description）

### 📖 ADとは

**アーキテクチャ記述書（AD）**は、システムの**全体構造**と**主要な設計判断**を記述したドキュメントです。「どのように作るか」の青写真となり、開発チーム全体が共通の理解を持つための重要な文書です。

```mermaid
graph LR
    A[ビジネス要求] --> B[SRS<br/>何を作るか]
    B --> C[AD<br/>どう作るか]
    C --> D[詳細設計<br/>具体的な実装]
    D --> E[実装<br/>コード]
    
    style A fill:#ffcdd2
    style B fill:#fff3e0
    style C fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
    style D fill:#b3e5fc
    style E fill:#f8bbd0
```

### 🏗️ ADで記述する内容

```mermaid
graph TD
    A[アーキテクチャ記述書] --> B[システム構造]
    A --> C[コンポーネント設計]
    A --> D[インフラ設計]
    A --> E[データ設計]
    A --> F[セキュリティ設計]
    A --> G[運用設計]
    
    B --> B1[レイヤー構成<br/>コンポーネント配置]
    C --> C1[各コンポーネント<br/>の責務と関係性]
    D --> D1[サーバー構成<br/>ネットワーク設計]
    E --> E1[データモデル<br/>DB設計方針]
    F --> F1[認証・認可<br/>暗号化方式]
    G --> G1[監視・バックアップ<br/>障害対応]
    
    style A fill:#ff9800,stroke:#e65100,stroke-width:3px
```

### 📐 C4モデルによるアーキテクチャ記述

**C4モデル**は、Simon Brownが提唱したソフトウェアアーキテクチャを4つのレベルで記述する手法です。地図のズームレベルのように、段階的に詳細化していきます。

```mermaid
graph TD
    A[C4モデル] --> B[Level 1<br/>コンテキスト図<br/>システムと外部の関係]
    A --> C[Level 2<br/>コンテナ図<br/>システムの主要要素]
    A --> D[Level 3<br/>コンポーネント図<br/>コンテナ内の構造]
    A --> E[Level 4<br/>コード図<br/>クラス・関数レベル]
    
    B -->|ズームイン| C
    C -->|ズームイン| D
    D -->|ズームイン| E
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:2px
    style B fill:#c8e6c9
    style C fill:#fff9c4
    style D fill:#ffccbc
    style E fill:#f8bbd0
```

#### Level 1：コンテキスト図（System Context Diagram）

システムと外部システム・ユーザーの関係を鳥瞰図として示します。

**顧客管理システムのコンテキスト図：**

```mermaid
graph TB
    subgraph "外部ユーザー"
        User[👤 営業担当者<br/>200名]
        Admin[👤 管理者<br/>2名]
    end
    
    System[📦 顧客管理システム<br/>CRM 2.0]
    
    subgraph "外部システム"
        SSO[🔐 社内SSO<br/>Azure AD]
        Email[📧 メール配信<br/>SendGrid]
        Payment[💳 決済システム<br/>Stripe]
        Analytics[📊 分析システム<br/>Google Analytics]
        Sansan[🎫 名刺管理<br/>Sansan API]
        Accounting[💰 会計システム<br/>freee]
    end
    
    User -->|顧客情報を管理| System
    Admin -->|システム設定・<br/>ユーザー管理| System
    
    System -->|認証| SSO
    System -->|メール送信| Email
    System -->|決済処理| Payment
    System -->|アクセスログ送信| Analytics
    System -->|名刺データ取得| Sansan
    System -->|顧客データ連携| Accounting
    
    style System fill:#4CAF50,stroke:#2E7D32,color:#fff,stroke-width:3px
    style User fill:#2196F3,stroke:#1565C0,color:#fff
    style Admin fill:#FF9800,stroke:#E65100,color:#fff
```

**説明文：**

```markdown
### コンテキスト図の説明

**システム概要：**
顧客管理システム（CRM 2.0）は、営業活動を支援するWebアプリケーションです。

**ユーザー：**
- **営業担当者（200名）**：
  - 顧客情報の登録・検索・編集
  - 活動履歴の記録
  - ダッシュボードでの進捗確認
  - レポート閲覧

- **管理者（2名）**：
  - ユーザー管理（登録・権限設定・削除）
  - システム設定
  - 監査ログ閲覧
  - レポート設定

**外部システム連携：**
1. **社内SSO（Azure AD）**：
   - 用途：ユーザー認証
   - プロトコル：SAML 2.0
   - 連携頻度：ログイン時

2. **メール配信（SendGrid）**：
   - 用途：顧客へのメール送信、システム通知
   - プロトコル：REST API
   - 連携頻度：リアルタイム

3. **決済システム（Stripe）**：
   - 用途：クレジットカード決済処理
   - プロトコル：REST API
   - 連携頻度：トランザクション発生時

4. **分析システム（Google Analytics）**：
   - 用途：ユーザー行動分析
   - プロトコル：JavaScript SDK
   - 連携頻度：リアルタイム

5. **名刺管理（Sansan）**：
   - 用途：名刺データのインポート
   - プロトコル：REST API
   - 連携頻度：日次バッチ

6. **会計システム（freee）**：
   - 用途：顧客データ・請求データの連携
   - プロトコル：REST API
   - 連携頻度：リアルタイム + 日次バッチ
```

#### Level 2：コンテナ図（Container Diagram）

システムを構成する主要なコンテナ（アプリケーション、データベース、ストレージなど）を示します。

```mermaid
graph TB
    User[👤 ユーザー<br/>Webブラウザ]
    
    subgraph "顧客管理システム（AWS）"
        CDN[🌐 CDN<br/>CloudFront<br/>静的ファイル配信]
        WebApp[💻 Webアプリケーション<br/>React 18 + TypeScript<br/>S3 + CloudFront]
        API[⚙️ APIサーバー<br/>Node.js 20 + Express 4<br/>ECS Fargate]
        DB[(🗄️ データベース<br/>PostgreSQL 15<br/>RDS Multi-AZ)]
        Cache[(⚡ キャッシュ<br/>Redis 7<br/>ElastiCache)]
        FileStorage[📁 ファイルストレージ<br/>AWS S3]
        Queue[📮 メッセージキュー<br/>AWS SQS]
    end
    
    EmailService[📧 SendGrid API]
    
    User -->|HTTPS<br/>Port 443| CDN
    CDN --> WebApp
    WebApp -->|REST API<br/>HTTPS<br/>JSON| API
    API -->|SQL<br/>Port 5432| DB
    API -->|読み書き<br/>Port 6379| Cache
    API -->|ファイル保存・取得| FileStorage
    API -->|非同期タスク| Queue
    Queue -->|メール送信処理| API
    API -->|メール送信| EmailService
    
    style WebApp fill:#42A5F5,stroke:#1565C0,color:#fff
    style API fill:#66BB6A,stroke:#2E7D32,color:#fff
    style DB fill:#FFA726,stroke:#E65100,color:#fff
    style Cache fill:#FF7043,stroke:#D84315,color:#fff
```

**各コンテナの詳細：**

| コンテナ | 技術スタック | 責務 | デプロイ先 | スケーリング |
|---------|------------|------|-----------|-------------|
| **Webアプリ<br/>（フロントエンド）** | React 18<br/>TypeScript<br/>Vite | UIの提供<br/>ユーザー操作の受付 | S3（静的ホスティング）<br/>+ CloudFront | 自動（CDN） |
| **APIサーバー<br/>（バックエンド）** | Node.js 20<br/>Express 4<br/>Prisma ORM | ビジネスロジック<br/>データ処理<br/>外部API連携 | ECS Fargate | オートスケーリング<br/>2〜10インスタンス |
| **データベース** | PostgreSQL 15 | 顧客データ<br/>トランザクション<br/>データの永続化 | RDS Multi-AZ | 垂直スケーリング |
| **キャッシュ** | Redis 7 | 頻繁にアクセスされる<br/>データのキャッシュ | ElastiCache | 水平スケーリング |
| **ファイルストレージ** | AWS S3 | 画像、PDF、CSV等の<br/>ファイル保存 | S3 | 無制限 |
| **メッセージキュー** | AWS SQS | 非同期タスクの<br/>キューイング | SQS | 自動 |

**通信プロトコル：**

- **クライアント ⇔ CDN**：HTTPS（TLS 1.3）
- **WebApp ⇔ API**：REST API、JSON形式、HTTPS
- **API ⇔ DB**：PostgreSQLプロトコル（TCP/IP）、TLS暗号化
- **API ⇔ Cache**：Redisプロトコル（RESP）、TLS暗号化
- **API ⇔ S3**：AWS SDK（HTTPS）
- **API ⇔ SQS**：AWS SDK（HTTPS）

#### Level 3：コンポーネント図（Component Diagram）

各コンテナ内の主要なコンポーネントとその関係を示します。ここではAPIサーバーの内部構造を詳細化します。

```mermaid
graph TB
    subgraph "APIサーバー（Node.js + Express）"
        subgraph "Controller層"
            AuthCtrl[🔐 AuthController<br/>認証・認可]
            CustomerCtrl[👤 CustomerController<br/>顧客CRUD]
            ActivityCtrl[📝 ActivityController<br/>活動履歴]
            ReportCtrl[📊 ReportController<br/>レポート生成]
        end
        
        subgraph "Service層（ビジネスロジック）"
            AuthSvc[🛡️ AuthService<br/>JWT生成・検証]
            CustomerSvc[📋 CustomerService<br/>顧客管理ロジック]
            ActivitySvc[📅 ActivityService<br/>活動管理ロジック]
            SearchSvc[🔍 SearchService<br/>検索ロジック]
            EmailSvc[📧 EmailService<br/>メール送信]
            ReportSvc[📈 ReportService<br/>レポート生成ロジック]
        end
        
        subgraph "Repository層（データアクセス）"
            CustomerRepo[💾 CustomerRepository<br/>顧客データCRUD]
            UserRepo[💾 UserRepository<br/>ユーザーデータCRUD]
            ActivityRepo[💾 ActivityRepository<br/>活動データCRUD]
            CacheRepo[⚡ CacheRepository<br/>Redisアクセス]
        end
        
        subgraph "Infrastructure層"
            DBClient[🗄️ Database Client<br/>Prisma ORM]
            RedisClient[⚡ Redis Client<br/>ioredis]
            S3Client[📁 S3 Client<br/>AWS SDK]
            QueueClient[📮 SQS Client<br/>AWS SDK]
        end
    end
    
    DB[(PostgreSQL)]
    Cache[(Redis)]
    S3[S3]
    SQS[SQS]
    
    AuthCtrl --> AuthSvc
    CustomerCtrl --> CustomerSvc
    ActivityCtrl --> ActivitySvc
    ReportCtrl --> ReportSvc
    
    CustomerSvc --> CustomerRepo
    CustomerSvc --> EmailSvc
    CustomerSvc --> CacheRepo
    ActivitySvc --> ActivityRepo
    SearchSvc --> CustomerRepo
    SearchSvc --> CacheRepo
    ReportSvc --> CustomerRepo
    ReportSvc --> ActivityRepo
    
    AuthSvc --> UserRepo
    EmailSvc --> QueueClient
    
    CustomerRepo --> DBClient
    UserRepo --> DBClient
    ActivityRepo --> DBClient
    CacheRepo --> RedisClient
    
    DBClient --> DB
    RedisClient --> Cache
    S3Client --> S3
    QueueClient --> SQS
    
    style AuthCtrl fill:#EF5350,color:#fff
    style CustomerCtrl fill:#42A5F5,color:#fff
    style ActivityCtrl fill:#66BB6A,color:#fff
    style ReportCtrl fill:#FFA726,color:#fff
```

**レイヤードアーキテクチャの説明：**

**1. Controller層（コントローラー層）**

- **責務**：
  - HTTPリクエストの受信
  - リクエストのバリデーション
  - Serviceレイヤーの呼び出し
  - HTTPレスポンスの生成
- **依存方向**：Service層に依存
- **原則**：ビジネスロジックを含まない（薄い層）

**2. Service層（サービス層）**

- **責務**：
  - ビジネスロジックの実装
  - トランザクション管理
  - 複数のRepositoryを組み合わせた処理
  - 外部サービスとの連携
- **依存方向**：Repository層に依存
- **原則**：再利用可能な単位でロジックを分割

**3. Repository層（リポジトリ層）**

- **責務**：
  - データの永続化・取得
  - データベースへのクエリ実行
  - キャッシュの読み書き
- **依存方向**：Infrastructure層に依存
- **原則**：データアクセスの詳細を隠蔽

**4. Infrastructure層（インフラストラクチャ層）**

- **責務**：
  - データベース接続
  - 外部サービスとの通信
  - 技術的な詳細の実装
- **依存方向**：外部ライブラリ・サービスに依存
- **原則**：交換可能な設計（DIコンテナ使用）

**設計パターン：**

- **Dependency Injection（DI）**：各層の依存関係をコンストラクタ注入
- **Repository Pattern**：データアクセスの抽象化
- **Service Layer Pattern**：ビジネスロジックのカプセル化

#### Level 4：コード図（Code Diagram）

実装レベルの詳細をUMLクラス図などで示します。

```mermaid
classDiagram
    class Customer {
        +UUID id
        +String name
        +String nameKana
        +String industry
        +Integer employeeCount
        +Integer capital
        +Date establishedAt
        +String postalCode
        +String prefecture
        +String city
        +String address
        +String phone
        +String website
        +String status
        +UUID assignedUserId
        +Date createdAt
        +Date updatedAt
        +create() Customer
        +update() Customer
        +delete() void
        +validate() ValidationResult
    }
    
    class Contact {
        +UUID id
        +UUID customerId
        +String name
        +String nameKana
        +String department
        +String position
        +String email
        +String phone
        +String mobile
        +Date birthday
        +Boolean isPrimary
        +Date createdAt
        +Date updatedAt
    }
    
    class Activity {
        +UUID id
        +UUID customerId
        +UUID userId
        +String type
        +String subject
        +String content
        +Date activityDate
        +Date createdAt
        +Date updatedAt
    }
    
    class CustomerService {
        -CustomerRepository repository
        -EmailService emailService
        -CacheRepository cacheRepository
        +createCustomer(data) Customer
        +updateCustomer(id, data) Customer
        +deleteCustomer(id) void
        +getCustomer(id) Customer
        +searchCustomers(criteria) Customer[]
    }
    
    class CustomerRepository {
        -PrismaClient db
        +save(customer) Customer
        +findById(id) Customer
        +findByEmail(email) Customer
        +search(criteria) Customer[]
        +delete(id) void
        +count() Integer
    }
    
    class EmailService {
        -SendGridClient client
        -SQSClient queue
        +sendWelcomeEmail(customer) void
        +sendNotification(customer, message) void
    }
    
    class CacheRepository {
        -RedisClient redis
        +get(key) any
        +set(key, value, ttl) void
        +delete(key) void
    }
    
    Customer "1" --> "*" Contact : has
    Customer "1" --> "*" Activity : has
    CustomerService --> CustomerRepository
    CustomerService --> EmailService
    CustomerService --> CacheRepository
    CustomerRepository --> Customer
    EmailService --> Customer
```

**主要クラスの責務：**

| クラス | 責務 | 主なメソッド |
|--------|------|------------|
| **Customer** | 顧客エンティティ<br/>顧客データの保持とバリデーション | create, update, delete, validate |
| **Contact** | 担当者エンティティ<br/>担当者データの保持 | - |
| **Activity** | 活動履歴エンティティ<br/>活動データの保持 | - |
| **CustomerService** | 顧客管理のビジネスロジック<br/>複数のRepositoryを組み合わせた処理 | createCustomer, updateCustomer, searchCustomers |
| **CustomerRepository** | 顧客データのCRUD操作<br/>データベースアクセスの抽象化 | save, findById, search, delete |
| **EmailService** | メール送信処理<br/>SendGridとの連携 | sendWelcomeEmail, sendNotification |
| **CacheRepository** | キャッシュの読み書き<br/>Redisとの連携 | get, set, delete |

---

### 🌐 インフラストラクチャ設計

#### ネットワーク構成図

```mermaid
graph TB
    Internet[インターネット]
    
    subgraph "AWS Cloud"
        subgraph "VPC: 10.0.0.0/16"
            subgraph "Availability Zone A"
                PublicA[パブリックサブネット<br/>10.0.1.0/24]
                PrivateA[プライベートサブネット<br/>10.0.11.0/24]
                NATGWA[NAT Gateway]
                
                PublicA --> NATGWA
            end
            
            subgraph "Availability Zone C"
                PublicC[パブリックサブネット<br/>10.0.2.0/24]
                PrivateC[プライベートサブネット<br/>10.0.12.0/24]
                NATGWC[NAT Gateway]
                
                PublicC --> NATGWC
            end
            
            IGW[Internet Gateway]
            ALB[Application Load Balancer]
            
            subgraph "ECS Cluster"
                ECSA[ECS Service<br/>APIサーバー × 2<br/>AZ-A]
                ECSC[ECS Service<br/>APIサーバー × 2<br/>AZ-C]
            end
            
            subgraph "RDS"
                DBPrimary[(Primary DB<br/>AZ-A)]
                DBStandby[(Standby DB<br/>AZ-C)]
            end
            
            subgraph "ElastiCache"
                RedisA[Redis Node<br/>AZ-A]
                RedisC[Redis Replica<br/>AZ-C]
            end
        end
        
        CloudFront[CloudFront<br/>CDN]
        S3Static[S3 Bucket<br/>静的ファイル]
        S3Files[S3 Bucket<br/>ファイルストレージ]
        WAF[AWS WAF]
    end
    
    Internet --> CloudFront
    CloudFront --> S3Static
    Internet --> WAF
    WAF --> IGW
    IGW --> ALB
    ALB --> ECSA
    ALB --> ECSC
    
    ECSA --> DBPrimary
    ECSC --> DBPrimary
    DBPrimary -.レプリケーション.-> DBStandby
    
    ECSA --> RedisA
    ECSC --> RedisA
    RedisA -.レプリケーション.-> RedisC
    
    ECSA --> S3Files
    ECSC --> S3Files
    
    NATGWA --> IGW
    NATGWC --> IGW
    
    style CloudFront fill:#FF9800,color:#fff
    style ALB fill:#FFA726,color:#fff
    style ECSA fill:#66BB6A,color:#fff
    style ECSC fill:#66BB6A,color:#fff
    style DBPrimary fill:#42A5F5,color:#fff
    style DBStandby fill:#90CAF9,color:#fff
```

**インフラ詳細仕様：**

**ネットワーク：**

- **VPC**：10.0.0.0/16
- **パブリックサブネット**：
  - AZ-A：10.0.1.0/24
  - AZ-C：10.0.2.0/24
  - 用途：ALB、NAT Gateway
- **プライベートサブネット**：
  - AZ-A：10.0.11.0/24
  - AZ-C：10.0.12.0/24
  - 用途：ECS、RDS、ElastiCache

**コンピューティング：**

- **ALB**：
  - タイプ：Application Load Balancer
  - リスナー：HTTPS（Port 443）
  - ターゲットグループ：ECS Service
  - ヘルスチェック：/health（10秒間隔）
- **ECS Fargate**：
  - タスク定義：2 vCPU、4GB Memory
  - 最小タスク数：2（各AZに1）
  - 最大タスク数：10
  - オートスケーリング：CPU 70%で追加

**データストア：**

- **RDS PostgreSQL**：
  - インスタンスタイプ：db.t3.medium
  - ストレージ：500GB（gp3）
  - Multi-AZ：有効
  - 自動バックアップ：毎日午前3時、7日間保持
- **ElastiCache Redis**：
  - ノードタイプ：cache.t3.medium
  - レプリカ：1（異なるAZ）
  - クラスターモード：無効
- **S3**：
  - 静的ファイル用バケット（CloudFront連携）
  - ファイルストレージ用バケット（バージョニング有効）

**セキュリティ：**

- **WAF**：
  - SQLインジェクション対策
  - XSS対策
  - レート制限：100リクエスト/5分/IP
- **Security Group**：
  - ALB：HTTPS（443）のみ許可
  - ECS：ALBからの通信のみ許可
  - RDS：ECSからの通信のみ許可（Port 5432）
  - ElastiCache：ECSからの通信のみ許可（Port 6379）

**監視：**

- **CloudWatch**：メトリクス監視、ログ集約
- **X-Ray**：分散トレーシング
- **SNS**：アラート通知（Slackに転送）

---

次のパートで、テスト計画書、SLO、RTM、ADRについて解説します。

## 4.3 テスト計画・仕様書

### 📖 テスト計画書とは

**テスト計画書**は、テスト活動全体の**戦略**と**計画**を定義したドキュメントです。「何を」「どのように」「誰が」「いつ」テストするかを明確化し、品質保証の基盤となります。

### 📊 テストレベルとテストタイプの全体像

```mermaid
graph TD
    A[テスト全体] --> B[テストレベル<br/>どの段階でテストするか]
    A --> C[テストタイプ<br/>何をテストするか]
    
    B --> B1[単体テスト<br/>Unit Test<br/>個々の関数・メソッド]
    B --> B2[統合テスト<br/>Integration Test<br/>コンポーネント間連携]
    B --> B3[システムテスト<br/>System Test<br/>システム全体]
    B --> B4[受入テスト<br/>Acceptance Test<br/>ビジネス要求]
    
    C --> C1[機能テスト<br/>Functional Test<br/>機能が正しく動作]
    C --> C2[非機能テスト<br/>Non-Functional Test]
    C --> C3[回帰テスト<br/>Regression Test<br/>既存機能の確認]
    C --> C4[探索的テスト<br/>Exploratory Test<br/>予期しない問題発見]
    
    C2 --> C2A[性能テスト]
    C2 --> C2B[セキュリティテスト]
    C2 --> C2C[ユーザビリティテスト]
    C2 --> C2D[互換性テスト]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B1 fill:#c8e6c9,stroke:#2e7d32
    style B2 fill:#fff9c4,stroke:#f57f17
    style B3 fill:#b3e5fc,stroke:#0277bd
    style B4 fill:#f8bbd0,stroke:#c2185b
```

---

## 4.4 SLO文書（運用目標：Service Level Objective）

### 📖 SLOとは

**SLO（Service Level Objective）**は、サービスの**信頼性目標**を数値で定義したものです。「どれくらい安定して動くべきか」を明確化し、運用チームの指針となります。

### 🎯 SLI、SLO、SLAの関係

```mermaid
graph TD
    A[サービスレベル] --> B[SLI<br/>Service Level Indicator<br/>実際の測定値]
    A --> C[SLO<br/>Service Level Objective<br/>内部目標]
    A --> D[SLA<br/>Service Level Agreement<br/>顧客との契約]
    
    B --> B1[実測値<br/>可用性: 99.95%<br/>レスポンス: 2.1秒<br/>エラー率: 0.08%]
    C --> C1[内部目標<br/>可用性: 99.9%<br/>レスポンス: 3秒<br/>エラー率: 1%]
    D --> D1[顧客との契約<br/>可用性: 99.5%<br/>違反時は返金]
    
    B -.測定値が.-> C
    C -.より厳しい.-> D
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#c8e6c9,stroke:#2e7d32
    style C fill:#fff9c4,stroke:#f57f17,stroke-width:2px
    style D fill:#ffcdd2,stroke:#c62828
```

**重要な原則：**

- **SLI（実測値）** ≥ **SLO（内部目標）** ≥ **SLA（契約）**
- SLOはSLAより厳しく設定し、バッファ（余裕）を持たせる
- これにより、SLA違反を防ぎ、顧客満足度を維持する

### 📝 SLO定義書の詳細例

```markdown
# SLO定義書 - 顧客管理システム

## 1. サービス概要
- **サービス名**：顧客管理システム（CRM 2.0）
- **対象ユーザー**：社内営業部門（約200名）
- **サービスレベル**：ビジネスクリティカル（業務の中核）
- **営業時間**：24時間365日（計画停止除く）

## 2. SLO定義

### 2.1 可用性（Availability）

**定義：**
システムが正常に動作し、ユーザーが利用可能な時間の割合

**SLO目標：** 99.9%（月間ダウンタイム43.2分以内）

**測定方法：**
```python
availability = (total_time - downtime) / total_time × 100

# 例：
# 月間総時間 = 30日 × 24時間 × 60分 = 43,200分
# ダウンタイム = 30分
# 可用性 = (43,200 - 30) / 43,200 × 100 = 99.93%
# → 目標達成 ✅
```

**エラーバジェット：**

- 許容ダウンタイム：43.2分/月
- 現在の消費状況：リアルタイムダッシュボードで監視
- 消費率80%超過時：アラート発火、新機能リリース凍結を検討

**除外項目（計画停止）：**

- 毎月第3日曜日 午前2:00〜5:00（最大3時間）
- 事前通知：2週間前にメール＋システム内通知
- 年間計画停止：最大36時間（SLO計算から除外）

### 2.2 レスポンスタイム（Latency）

**定義：**
ユーザーのリクエストに対する応答時間

**SLO目標：**

| パーセンタイル | 目標値 | 意味 |
|---------------|--------|------|
| **95%ile** | 3秒以内 | 95%のリクエストが3秒以内に完了 |
| **99%ile** | 5秒以内 | 99%のリクエストが5秒以内に完了 |
| **平均** | 2秒以内 | 全リクエストの平均応答時間 |

**測定対象操作：**

- ページ読み込み時間（First Contentful Paint）
- API応答時間（サーバー処理時間）
- データベースクエリ時間
- 検索処理時間

**測定方法：**

```javascript
// CloudWatchメトリクスで毎分測定
// 全リクエストのレスポンスタイムを記録し、
// 95パーセンタイル値を算出

// 例：100リクエスト中、95番目に遅いリクエストが2.8秒
// → 95パーセンタイル = 2.8秒 → 目標クリア ✅
```

**アラート条件：**

| 条件 | 重要度 | 通知先 | 対応SLA |
|------|--------|--------|---------|
| 95%ile > 3秒（5分継続） | High | 運用チーム | 30分以内 |
| 99%ile > 5秒（5分継続） | Medium | 運用チーム | 1時間以内 |
| 平均 > 2秒（10分継続） | Medium | 運用チーム | 1時間以内 |

### 2.3 エラー率（Error Rate）

**定義：**
全リクエストに対するエラーレスポンスの割合

**SLO目標：** 1%以下

**エラーの定義：**

- HTTP 5xxエラー（サーバーエラー）
- タイムアウト（30秒以上）
- データベース接続エラー
- 外部API連携エラー（SendGrid、Stripeなど）

**測定方法：**

```python
error_rate = (error_requests / total_requests) × 100

# 例：
# 総リクエスト数 = 100,000
# エラーリクエスト数 = 500
# エラー率 = 500 / 100,000 × 100 = 0.5%
# → 目標クリア ✅
```

**エラーバジェット：**

- 許容エラー数：総リクエスト数の1%
- 月間100万リクエストの場合：10,000エラーまで許容
- 80%消費（8,000エラー）でアラート

### 2.4 スループット（Throughput）

**定義：**
単位時間あたりに処理できるリクエスト数

**SLO目標：**

- **通常時**：100リクエスト/秒
- **ピーク時**：200リクエスト/秒（短時間）

**測定方法：**

- リクエスト数を毎秒カウント
- 1分間の平均値を算出
- CloudWatchメトリクスで可視化

## 3. 監視とアラート

### 3.1 リアルタイム監視ダッシュボード

**監視項目：**

1. **可用性**
   - 現在の稼働状況（UP/DOWN）
   - 過去30日間の可用性（%）
   - エラーバジェット残量（%）
   - 計画停止までの残り日数

2. **レスポンスタイム**
   - リアルタイムのレスポンスタイム（過去5分）
   - 95パーセンタイル値（過去1時間）
   - 99パーセンタイル値（過去1時間）
   - 平均レスポンスタイム（過去1時間）

3. **エラー率**
   - エラー発生数（過去1時間）
   - エラー率（%）
   - エラー種別の内訳
   - トップ10エラーメッセージ

4. **システムリソース**
   - CPU使用率（%）
   - メモリ使用率（%）
   - ディスク使用率（%）
   - ネットワーク帯域使用率

5. **ユーザー**
   - 同時接続ユーザー数
   - アクティブセッション数
   - 地域別アクセス分布

**ダッシュボードツール：**

- AWS CloudWatch Dashboard（メインダッシュボード）
- Grafana（詳細分析用）
- DataDog（APM・分散トレーシング）

### 3.2 アラート設定

| アラート名 | 条件 | 重要度 | 通知先 | 対応SLA |
|-----------|------|--------|--------|---------|
| **システムダウン** | ヘルスチェック3回連続失敗 | Critical | 全チーム<br/>+ on-call | 即時 |
| **可用性低下** | 可用性 < 99.9% | Critical | 全チーム | 即時 |
| **エラーバジェット80%消費** | エラーバジェット残量 < 20% | High | 運用・開発リード | 30分以内 |
| **レスポンス遅延** | 95%ile > 3秒（5分継続） | High | 運用チーム | 30分以内 |
| **エラー率上昇** | エラー率 > 1%（5分継続） | High | 運用チーム | 30分以内 |
| **CPU高負荷** | CPU > 80%（10分継続） | Medium | 運用チーム | 1時間以内 |
| **メモリ逼迫** | メモリ > 85%（10分継続） | Medium | 運用チーム | 1時間以内 |
| **ディスク容量** | ディスク使用率 > 85% | Medium | インフラチーム | 4時間以内 |
| **データベース接続エラー** | DB接続失敗（5分で10回以上） | High | 運用・DBAチーム | 30分以内 |
| **外部API異常** | 外部API呼び出し失敗率 > 5% | Medium | 運用チーム | 1時間以内 |

**通知チャネル：**

- **Critical**：Slack + SMS + 電話（on-call）
- **High**：Slack + メール
- **Medium**：Slack

## 4. SLO違反時の対応

### 4.1 インシデント対応フロー

```mermaid
graph TD
    A[SLO違反検知] --> B[インシデント発生宣言]
    B --> C[影響範囲の特定]
    C --> D[緊急対応チーム招集]
    D --> E[暫定対策の実施]
    E --> F{復旧完了?}
    F -->|No| E
    F -->|Yes| G[サービス正常化確認]
    G --> H[根本原因分析<br/>RCA]
    H --> I[恒久対策の策定]
    I --> J[ポストモーテム作成]
    J --> K[再発防止策の実施]
    K --> L[振り返りミーティング]
    
    style A fill:#ff5252,color:#fff
    style B fill:#ff9800,color:#fff
    style E fill:#fff9c4
    style F fill:#fff9c4
    style G fill:#c8e6c9
    style J fill:#b3e5fc
    style K fill:#c8e6c9
```

### 4.2 エスカレーションパス

| 経過時間 | 対応者 | アクション |
|---------|--------|----------|
| **0分（検知時）** | 運用チーム（当番） | アラート確認、初動対応開始 |
| **15分（未解決）** | 運用リーダー | エスカレーション、追加リソース投入 |
| **30分（未解決）** | 技術リーダー | 技術的判断、開発チーム動員検討 |
| **1時間（未解決）** | プロダクトマネージャー | 経営層報告、影響範囲の精査 |
| **2時間（未解決）** | 事業部長・CTO | 全社対応体制、顧客への状況報告 |
| **4時間（未解決）** | 経営層 | 対外発表、メディア対応検討 |

### 4.3 ポストモーテム（事後分析）

**目的：**

- 再発防止
- 組織学習
- 透明性の確保
- 責任追及ではなく、学びを重視（Blameless）

**作成タイミング：**

- Critical / Highインシデント発生後、24時間以内

**記載項目：**

```markdown
# ポストモーテム - [インシデント名]

## サマリー
- **インシデントID**：INC-2025-001
- **発生日時**：2025年11月15日 14:30
- **復旧日時**：2025年11月15日 16:45
- **影響時間**：2時間15分
- **影響範囲**：全ユーザー、顧客検索機能が利用不可
- **根本原因**：データベースのインデックス欠損

## タイムライン
| 時刻 | 出来事 | 対応者 |
|------|--------|--------|
| 14:30 | CloudWatchアラート発火（レスポンス遅延） | 自動 |
| 14:32 | 運用チーム確認開始 | 山田 |
| 14:35 | 顧客検索が30秒以上かかることを確認 | 山田 |
| 14:40 | データベースのスロークエリログ確認 | 山田 |
| 14:50 | インデックスが欠損していることを発見 | 山田 |
| 15:00 | 技術リーダーにエスカレーション | 佐藤 |
| 15:10 | インデックス再作成を決定 | 佐藤 |
| 15:15 | インデックス再作成開始 | 佐藤 |
| 16:30 | インデックス再作成完了 | 佐藤 |
| 16:35 | 検索速度が正常化したことを確認 | 山田 |
| 16:45 | インシデントクローズ宣言 | 佐藤 |

## 根本原因（5 Whys分析）
1. **なぜ検索が遅くなったのか？**
   → データベースのインデックスが欠損していたため

2. **なぜインデックスが欠損したのか？**
   → 先週のデータベースマイグレーション時にインデックス再作成が漏れた

3. **なぜインデックス再作成が漏れたのか？**
   → マイグレーションスクリプトにインデックス作成コマンドが含まれていなかった

4. **なぜスクリプトに含まれていなかったのか？**
   → マイグレーション手順のチェックリストが不完全だった

5. **なぜチェックリストが不完全だったのか？**
   → インデックス管理の標準手順が文書化されていなかった

## 対応内容

**暫定対策：**
- インデックスを手動で再作成（2時間）

**恒久対策：**
1. マイグレーション手順のチェックリストを更新（担当：佐藤、期限：11/20）
2. インデックス管理の標準手順を文書化（担当：田中、期限：11/25）
3. マイグレーション前後のインデックス自動チェックスクリプトを作成（担当：鈴木、期限：12/05）
4. ステージング環境での事前検証を必須化（担当：山田、期限：即時）

## 学び

**うまくいった点：**
- アラートが迅速に発火し、早期検知できた
- 運用チームがスロークエリログから原因を特定できた
- エスカレーションが適切に機能した

**改善点：**
- マイグレーション手順のレビューが不十分だった
- ステージング環境でのテストが形骸化していた
- インデックス管理の知識がチーム全体に共有されていなかった

## アクションアイテム
- [x] ポストモーテムを全社共有（11/16）
- [ ] マイグレーション手順更新（11/20）
- [ ] インデックス管理標準手順作成（11/25）
- [ ] 自動チェックスクリプト作成（12/05）
- [ ] データベース管理勉強会開催（12/10）

## 関連資料
- [CloudWatchアラートログ](link)
- [スロークエリログ](link)
- [マイグレーションスクリプト](link)
```

## 5. SLO見直しとレポート

### 5.1 月次SLOレポート

**レポート項目：**

1. SLO達成状況（可用性、レスポンス、エラー率、スループット）
2. エラーバジェット消費状況（残量と消費ペース）
3. インシデントサマリー（発生件数、重要度別内訳、MTTR）
4. トップ3のエラー原因と対策
5. 改善アクション（実施済み/実施予定）
6. 次月の重点施策

**レポート提出先：**

- プロダクトオーナー
- 技術リーダー
- 経営層
- 顧客（必要に応じて）

**提出タイミング：**

- 毎月第1営業日

### 5.2 SLO見直しプロセス

**見直し頻度：** 四半期ごと

**見直し観点：**

1. **ビジネス要件の変化**
   - 新機能リリース
   - ユーザー数の増加
   - 業務プロセスの変更

2. **技術的な実現可能性**
   - インフラの性能
   - アーキテクチャの制約
   - コストとのバランス

3. **ユーザーのフィードバック**
   - 満足度調査
   - サポート問い合わせ内容
   - 実際の利用状況

4. **競合比較**
   - 業界標準
   - ベストプラクティス

**見直しステップ：**

```mermaid
graph LR
    A[過去3ヶ月のSLI実績分析] --> B[ステークホルダー<br/>レビュー]
    B --> C[新SLO目標の提案]
    C --> D[承認]
    D --> E[次四半期から適用]
    
    style A fill:#e1f5ff
    style B fill:#fff9c4
    style C fill:#ffccbc
    style D fill:#c8e6c9
```

---

## 4.5 RTM（トレーサビリティマトリクス）

### 📖 RTMとは

**RTM（Requirements Traceability Matrix）**は、要件が設計・実装・テストの各フェーズで正しく実現されていることを追跡するための表です。要件の抜け漏れを防ぎ、品質を保証します。

### 🔍 トレーサビリティの重要性

```mermaid
graph LR
    A[要件<br/>FR-001] -->|前方トレース| B[設計<br/>BD-001]
    B -->|前方トレース| C[実装<br/>Code]
    C -->|前方トレース| D[テスト<br/>TC-001]
    
    D -.後方トレース.-> C
    C -.後方トレース.-> B
    B -.後方トレース.-> A
    
    style A fill:#ffcdd2,stroke:#c62828
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#c8e6c9,stroke:#2e7d32
    style D fill:#b3e5fc,stroke:#0277bd
```

### 📊 RTMの基本例

| 要件ID | 要件名 | 優先度 | 設計ID | 実装 | 単体テストID | 統合テストID | システムテストID | ステータス |
|--------|--------|--------|--------|------|-------------|-------------|----------------|-----------|
| FR-001 | 顧客登録機能 | Must | BD-001<br/>DD-001 | ✅ | UT-001〜010 | IT-001〜003 | ST-001 | ✅完了 |
| FR-002 | 顧客検索機能 | Must | BD-002<br/>DD-002 | ✅ | UT-011〜020 | IT-004〜006 | ST-002 | ✅完了 |
| FR-003 | 顧客編集機能 | Must | BD-003<br/>DD-003 | 🟡 | UT-021〜030 | IT-007〜009 | ST-003 | 🟡進行中 |
| NFR-001 | レスポンスタイム | Must | BD-010<br/>DD-020 | ✅ | UT-100〜105 | IT-050 | ST-100 | ✅完了 |

---

## 4.6 ADR（設計決定記録）

### 📖 ADRとは

**ADR（Architecture Decision Record）**は、重要な設計決定を記録するドキュメントです。「なぜその技術を選んだのか」「なぜその設計にしたのか」を後から理解できるようにします。

### 📝 ADRのフォーマット例

```markdown
# ADR-001：データベースにPostgreSQLを採用

## ステータス
採用（Accepted）

## コンテキスト
顧客管理システムのバックエンドで使用するデータベースを選定する必要がある。

**要件：**
- 顧客データ100万件以上を格納
- トランザクション整合性（ACID）
- 複雑な検索クエリ（JOIN、集計）
- JSON型データの格納

**制約：**
- 予算：月額$500以内
- チームスキル：SQL経験あり

## 決定事項
**PostgreSQL 15（AWS RDS）を採用する**

## 理由
1. **ACID準拠**：トランザクション整合性が保証される
2. **JSON型サポート**：柔軟なデータ構造に対応
3. **豊富な機能**：全文検索、GINインデックス
4. **実績とコミュニティ**：30年以上の歴史、安定性
5. **コスト**：オープンソース、AWS RDSで月額$150

## 影響
**ポジティブ：**
- ✅ データの正確性が向上
- ✅ 柔軟なデータ構造
- ✅ チームのSQL経験を活用

**ネガティブ：**
- ⚠️ 水平スケーリングが困難

## 関連資料
- [PostgreSQL公式](https://www.postgresql.org/)
- [AWS RDS料金](link)
```

---

## 第4章のまとめ

本章では、システム開発における6つの重要ドキュメントを詳細に解説しました：

1. **SRS（要求仕様書）**
   - 機能要求と非機能要求を明確化
   - Gherkin形式の受入基準

2. **AD（アーキテクチャ記述書）**
   - C4モデルで4つのレベルで記述
   - インフラ・セキュリティ・性能設計

3. **テスト計画書**
   - 単体〜受入テストまで網羅
   - 性能・セキュリティテストも含む

4. **SLO文書**
   - 可用性・レスポンス・エラー率を数値化
   - エラーバジェットで運用の余裕を確保

5. **RTM（トレーサビリティマトリクス）**
   - 要件から実装・テストまで追跡
   - 抜け漏れ防止

6. **ADR（設計決定記録）**
   - 技術選定の背景と理由を記録
   - 将来の変更判断の材料

次の第5章では、これらのドキュメントを作成するための**実践的手法とツール**について解説します！

---

# 第5章：実践的手法とツール

この章では、システム開発ドキュメントを実際に作成する際に使用する、具体的な手法とツールについて解説します。理論だけでなく、**明日から実務で使える実践的な知識**を提供します。

## 5.1 要件定義の技法

### 📖 要件定義とは

要件定義は、**「何を作るか」を明確にするプロセス**です。システム開発の成否を決める最も重要なフェーズであり、ここでの失敗は後から取り返すのが非常に困難です。

### 🎯 要件の3つのカテゴリ

```mermaid
graph TD
    A[要件] --> B[機能要求<br/>Functional Requirements]
    A --> C[非機能要求<br/>Non-Functional Requirements]
    A --> D[制約<br/>Constraints]
    
    B --> B1[システムが<br/>何をするか]
    C --> C1[システムが<br/>どう動くか]
    D --> D1[守るべき<br/>条件・制限]
    
    B1 --> B2[例: 顧客を登録する<br/>商品を検索する<br/>注文を処理する]
    C1 --> C2[例: 2秒以内に応答<br/>99.9%稼働<br/>安全に通信]
    D1 --> D2[例: 予算500万円<br/>3ヶ月で完成<br/>既存DBを使用]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#ffcdd2,stroke:#c62828
    style C fill:#fff3e0,stroke:#ef6c00
    style D fill:#c8e6c9,stroke:#2e7d32
```

### 🛠️ 要件定義の5つの技法

#### 技法1：インタビュー法（ヒアリング）

**概要：**
ステークホルダーと直接対話して要件を引き出す最も基本的な手法

**実施手順：**

```mermaid
graph LR
    A[①事前準備<br/>質問リスト作成] --> B[②インタビュー実施<br/>60〜90分]
    B --> C[③議事録作成<br/>24時間以内]
    C --> D[④確認<br/>認識のズレ修正]
    D --> E[⑤要件文書化]
    
    style A fill:#fff3e0
    style B fill:#e1f5ff
    style C fill:#f3e5f5
    style D fill:#fff9c4
    style E fill:#c8e6c9
```

**質問テクニック：**

| 質問タイプ | 例 | 目的 |
|-----------|---|------|
| **オープン質問** | 「現在の業務フローについて教えてください」 | 自由に語ってもらい、潜在的なニーズを発見 |
| **クローズド質問** | 「承認は2段階ですか？」 | 具体的な事実を確認 |
| **深掘り質問** | 「なぜその処理が必要なのですか？」 | 本質的な要求を理解 |
| **仮定質問** | 「もしこの機能があったら、どう使いますか？」 | 新しいアイデアを引き出す |

**インタビューチェックリスト：**

```markdown
## インタビュー準備チェックリスト

### 事前準備
- [ ] インタビュー対象者の役割を理解
- [ ] 質問リストを作成（10〜15問）
- [ ] 必要な資料を準備（現行システムの画面キャプチャなど）
- [ ] 録音・録画の許可を取得（議事録作成のため）
- [ ] 会議室の予約（静かな環境）

### 当日
- [ ] 時間通りに開始
- [ ] アイスブレイク（軽い雑談で緊張をほぐす）
- [ ] インタビューの目的を説明
- [ ] メモを取りながら傾聴
- [ ] 不明点はその場で確認
- [ ] 時間内に終了

### 事後
- [ ] 24時間以内に議事録作成
- [ ] 対象者に確認依頼（48時間以内）
- [ ] フィードバックを反映
- [ ] 要件一覧に追加
```

**実例：ECサイトのインタビュー**

```
【インタビュー相手】：マーケティング担当者

Q: 現在の購入プロセスで、お客様からどんな不満がありますか？
A: 「カートに入れた商品が消えてしまう」という声が多いです。

Q: どういうときに消えるのですか？
A: ログアウトすると消えるみたいです。

Q: お客様は、カートの商品をどのくらいの期間保存したいと思っていますか？
A: 少なくとも1週間は残してほしいと言われます。

→ 要件：カート内商品は7日間保存する（ログイン・ログアウトに関係なく）
```

#### 技法2：ワークショップ法

**概要：**
複数のステークホルダーを集めて、グループで要件を整理・合意する手法

**適用場面：**

- ✅ 関係者が多く、意見が分かれている
- ✅ 短期間で全体像を把握したい
- ✅ チーム全体の合意形成が必要

**実施手順：**

```mermaid
graph TD
    A[ワークショップ<br/>2〜4時間] --> B[①アイスブレイク<br/>15分]
    B --> C[②現状の課題整理<br/>ブレインストーミング<br/>30分]
    C --> D[③課題の優先順位付け<br/>投票・議論<br/>30分]
    D --> E[④解決策の検討<br/>グループワーク<br/>60分]
    E --> F[⑤発表・フィードバック<br/>45分]
    F --> G[⑥まとめ・Next Action<br/>15分]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:2px
    style B fill:#fff3e0
    style C fill:#ffcdd2
    style D fill:#fff9c4
    style E fill:#c8e6c9
    style F fill:#b3e5fc
    style G fill:#f3e5f5
```

**ファシリテーション技術：**

1. **ブレインストーミング**
   - ルール：批判禁止、質より量、自由奔放、便乗歓迎
   - 付箋紙やホワイトボードを活用
   - 全員が発言できる雰囲気を作る

2. **KJ法（親和図法）**
   - 似たアイデアをグルーピング
   - グループに見出しをつける
   - 構造化して全体像を把握

3. **投票法（ドット投票）**
   - 各参加者に3〜5票を配布
   - 重要だと思う項目にシールを貼る
   - 優先順位を可視化

**ワークショップ実例：社内システムリニューアル**

```
【参加者】：営業部5名、経理部3名、IT部2名、経営層1名

【成果物】：
- 現状の課題：35個
- 優先度トップ3：
  1. 見積作成が手作業で時間がかかる（営業）
  2. 承認フローが複雑でミスが多い（経理）
  3. 外出先から確認できない（営業）
  
- 解決策の合意：
  1. 見積自動作成機能
  2. 電子承認ワークフロー
  3. モバイル対応
```

#### 技法3：プロトタイピング法

**概要：**
実際に動く試作品（プロトタイプ）を作って、ユーザーに触ってもらいながら要件を明確化する手法

**プロトタイプの種類：**

| タイプ | 説明 | 作成時間 | 適用場面 | ツール例 |
|--------|------|---------|---------|---------|
| **ペーパープロトタイプ** | 紙に画面を描く | 1〜2時間 | 初期段階の画面イメージ共有 | 紙、ペン |
| **ワイヤーフレーム** | 画面の骨組み | 1〜3日 | レイアウト・導線の確認 | Figma、Adobe XD |
| **モックアップ** | デザイン込みの静的画面 | 3〜5日 | デザイン確認 | Figma、Sketch |
| **インタラクティブ** | クリックして動く | 5〜10日 | 操作感の確認 | Figma、Axure |
| **動くプロトタイプ** | 実際にコードで動作 | 2〜4週間 | 技術的検証 | React、Vue.js |

**プロトタイピングの流れ：**

```mermaid
graph LR
    A[①ラフスケッチ<br/>紙に描く] --> B[②ワイヤーフレーム<br/>ツールで作成]
    B --> C[③ユーザー<br/>レビュー]
    C --> D{OK?}
    D -->|No| E[フィードバック<br/>反映]
    E --> B
    D -->|Yes| F[④モックアップ<br/>作成]
    F --> G[⑤最終確認]
    G --> H[要件確定]
    
    style A fill:#fff3e0
    style B fill:#e1f5ff
    style C fill:#fff9c4
    style D fill:#ffcdd2
    style F fill:#c8e6c9
    style H fill:#b3e5fc
```

**プロトタイプ作成のベストプラクティス：**

1. **Lo-Fi（低忠実度）から始める**
   - まずは紙とペンで十分
   - 早く、安く、何度でも作り直せる
   - 細部にこだわらない

2. **ユーザーに早期に見せる**
   - 完璧を目指さない
   - 「60%の完成度で見せる」
   - フィードバックを得て改善

3. **捨てることを恐れない**
   - プロトタイプは「学ぶため」のもの
   - ダメなら作り直す
   - 本番コードに流用しない

**実例：モバイルアプリの画面設計**

```
【状況】：新しい勤怠管理アプリを開発

【プロセス】：
1. 紙にラフスケッチ（1時間）
   → 営業担当「打刻ボタンが小さすぎる」
   
2. Figmaでワイヤーフレーム作成（1日）
   → ユーザー「出勤と退勤を間違えそう」
   
3. 色とアイコンを追加したモックアップ（2日）
   → ユーザー「これなら分かりやすい！」
   
4. クリックできるプロトタイプ（3日）
   → ユーザーが実際に操作して最終確認
   
【結果】：
- 開発前に5回の改善を実施
- 開発後の仕様変更ゼロ
- ユーザー満足度95%
```

#### 技法4：ユースケース法

**概要：**
「誰が」「何を」「どのように」使うかをシナリオで記述する手法

**ユースケース図の書き方：**

```mermaid
graph LR
    A((顧客)) -->|登録する| B[顧客登録]
    A -->|検索する| C[顧客検索]
    A -->|編集する| D[顧客情報編集]
    E((営業担当者)) -->|登録する| B
    E -->|検索する| C
    E -->|編集する| D
    E -->|削除する| F[顧客削除]
    G((管理者)) -->|管理する| H[ユーザー管理]
    G -->|バックアップする| I[データバックアップ]
    
    style A fill:#ffcdd2
    style E fill:#fff3e0
    style G fill:#c8e6c9
```

**ユースケース記述書の例：**

```markdown
## ユースケース：顧客登録

**ID**：UC-001  
**概要**：新規顧客情報をシステムに登録する  
**アクター**：営業担当者  
**事前条件**：営業担当者がログイン済み  
**事後条件**：顧客情報がデータベースに保存される  

### 基本フロー
1. 営業担当者が「新規登録」ボタンをクリック
2. システムが登録フォームを表示
3. 営業担当者が必須項目を入力
   - 会社名（必須）
   - 担当者名（必須）
   - 電話番号（必須）
   - メールアドレス（必須）
   - 住所（任意）
4. 営業担当者が「登録」ボタンをクリック
5. システムが入力内容を検証
6. システムが顧客情報を保存
7. システムが「登録完了」メッセージを表示
8. システムが顧客一覧画面に遷移

### 代替フロー

**5a. 必須項目が未入力の場合**
- 5a-1. システムがエラーメッセージを表示
- 5a-2. 未入力項目を赤枠で強調表示
- 5a-3. 基本フロー3に戻る

**5b. メールアドレスの形式が不正な場合**
- 5b-1. システムが「正しいメールアドレスを入力してください」とエラー表示
- 5b-2. 基本フロー3に戻る

**5c. 同じ会社名が既に登録されている場合**
- 5c-1. システムが確認ダイアログを表示「同じ会社名が既に存在します。続けますか？」
- 5c-2. 営業担当者が「はい」を選択した場合、基本フロー6へ
- 5c-3. 営業担当者が「いいえ」を選択した場合、基本フロー3へ

### 非機能要求
- レスポンス時間：2秒以内
- 同時登録：50ユーザーまで対応
- データ暗号化：個人情報は暗号化して保存

### UI/UX要求
- フォームはシンプルで見やすいデザイン
- 入力補助（郵便番号から住所自動入力）
- モバイル対応

### ビジネスルール
- 同一メールアドレスの重複登録は不可
- 退職した担当者の顧客は「担当者なし」に設定
```

#### 技法5：ユーザーストーリー法（アジャイル）

**概要：**
ユーザー視点で「誰が、何を、なぜ必要か」を簡潔に記述する手法。アジャイル開発でよく使われます。

**フォーマット：**

```
【役割】として、
【機能】がほしい。
なぜなら【理由】だから。
```

英語版：

```
As a [role],
I want [feature],
So that [benefit].
```

**ユーザーストーリーの例：**

```markdown
## ユーザーストーリー集

### US-001：ログイン
**As a** 営業担当者  
**I want** メールアドレスとパスワードでログインしたい  
**So that** 自分の顧客情報に安全にアクセスできる

**受入基準：**
- [ ] 正しいメールアドレスとパスワードでログインできる
- [ ] 間違ったパスワードでログインできない
- [ ] 5回連続で失敗すると30分ロックされる
- [ ] ログイン後はダッシュボード画面が表示される

**見積もり：** 5ストーリーポイント  
**優先度：** Must

---

### US-002：顧客検索
**As a** 営業担当者  
**I want** 会社名や担当者名で顧客を検索したい  
**So that** 必要な顧客情報をすぐに見つけられる

**受入基準：**
- [ ] 会社名の部分一致で検索できる
- [ ] 担当者名の部分一致で検索できる
- [ ] 検索結果は50件まで一覧表示される
- [ ] 検索結果が0件の場合「該当なし」と表示される
- [ ] 検索は2秒以内に完了する

**見積もり：** 3ストーリーポイント  
**優先度：** Must

---

### US-003：モバイル対応
**As a** 営業担当者  
**I want** スマートフォンから顧客情報を見たい  
**So that** 外出先でもすぐに顧客情報を確認できる

**受入基準：**
- [ ] iPhoneで正しく表示される
- [ ] Androidで正しく表示される
- [ ] タップ操作がスムーズ
- [ ] 画面が見やすい（文字サイズ適切）

**見積もり：** 8ストーリーポイント  
**優先度：** Should
```

**ユーザーストーリーのベストプラクティス：**

1. **INVEST原則**
   - **I**ndependent（独立している）：他のストーリーに依存しない
   - **N**egotiable（交渉可能）：詳細は後で調整できる
   - **V**aluable（価値がある）：ユーザーに価値を提供
   - **E**stimable（見積もり可能）：開発工数を見積もれる
   - **S**mall（小さい）：1〜2週間で完成する
   - **T**estable（テスト可能）：受入基準が明確

2. **3C原則**
   - **Card**（カード）：簡潔に書く
   - **Conversation**（会話）：詳細は対話で決める
   - **Confirmation**（確認）：受入基準で確認

### 📊 技法の使い分け

| 技法 | 向いているケース | 成果物 | 所要時間 | 難易度 |
|------|----------------|--------|---------|--------|
| **インタビュー** | 個別の詳細なヒアリングが必要 | 議事録、要件リスト | 半日〜1日 | ⭐ |
| **ワークショップ** | 多数の関係者の合意形成が必要 | 課題リスト、優先順位 | 半日〜1日 | ⭐⭐ |
| **プロトタイピング** | UIが重要、イメージの共有が難しい | プロトタイプ | 1週間〜 | ⭐⭐⭐ |
| **ユースケース** | 業務フローが複雑 | ユースケース図、記述書 | 3日〜1週間 | ⭐⭐ |
| **ユーザーストーリー** | アジャイル開発、素早く進めたい | ユーザーストーリーカード | 1〜3日 | ⭐ |

### 🎓 要件定義の成功法則

```mermaid
graph TD
    A[成功する要件定義] --> B[①WHYを理解する<br/>なぜ必要か]
    A --> C[②WHATを明確にする<br/>何を作るか]
    A --> D[③HOWは後回し<br/>どう作るかは設計で]
    
    B --> B1[ビジネス価値<br/>を常に意識]
    C --> C1[曖昧さを<br/>徹底的に排除]
    D --> D1[技術詳細は<br/>要件定義で決めない]
    
    style A fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
    style B fill:#e1f5ff,stroke:#0277bd
    style C fill:#fff3e0,stroke:#ef6c00
    style D fill:#f3e5f5,stroke:#7b1fa2
```

**成功のための10のチェックポイント：**

```markdown
## 要件定義チェックリスト

### ビジネス理解
- [ ] システムを作る目的（WHY）が明確
- [ ] 解決したい課題が具体的
- [ ] ビジネス価値（ROI）が測定可能

### 要件の品質
- [ ] 全ての機能要求が「〜できる」形式で記述
- [ ] 全ての非機能要求が数値で定義
- [ ] 曖昧な表現（「適切に」「柔軟に」など）がない
- [ ] 受入基準が明確

### ステークホルダー
- [ ] 全ての関係者から意見を聞いた
- [ ] 要件の優先順位に合意
- [ ] 変更管理プロセスを確立

### 次のステップ
- [ ] 要件が実現可能か技術的に検証済み
```

---

## 5.2 設計手法（C4モデル、UML）

### 📖 設計手法とは

設計手法は、**システムの構造を分かりやすく表現するための方法**です。プログラマーだけでなく、ビジネス側の人も理解できる図を描くことが重要です。

### 🏗️ C4モデル（推奨）

**C4モデル**は、現代のソフトウェア設計で最も推奨される手法です。4つのレベル（Context、Container、Component、Code）でシステムを段階的に詳細化します。

#### レベル1：Context（コンテキスト図）

**目的：** システム全体と外部との関係を示す  
**対象読者：** 全員（経営層、ビジネス、技術者）

```mermaid
graph TD
    User1((個人ユーザー)) -->|商品を検索・購入| System[ECサイトシステム]
    User2((管理者)) -->|商品を管理| System
    
    System -->|決済処理| External1[決済サービス<br/>Stripe]
    System -->|メール送信| External2[メール配信<br/>SendGrid]
    System -->|在庫確認| External3[在庫管理システム<br/>既存]
    
    style System fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style User1 fill:#ffcdd2
    style User2 fill:#fff3e0
    style External1 fill:#c8e6c9
    style External2 fill:#c8e6c9
    style External3 fill:#c8e6c9
```

**記述例：**

```markdown
## Context図：ECサイトシステム

### システム概要
個人ユーザーが商品を検索・購入できるECサイト

### 主要ユーザー
- **個人ユーザー**：商品を検索・カートに入れ・購入
- **管理者**：商品情報の登録・更新・削除

### 外部システム
- **決済サービス（Stripe）**：クレジットカード決済処理
- **メール配信（SendGrid）**：注文確認メールの送信
- **在庫管理システム**：在庫数の確認・更新
```

#### レベル2：Container（コンテナ図）

**目的：** システム内部の主要な構成要素を示す  
**対象読者：** 技術者、アーキテクト

```mermaid
graph TD
    User((ユーザー)) -->|HTTPS| Web[Webアプリケーション<br/>React<br/>:3000]
    Admin((管理者)) -->|HTTPS| AdminWeb[管理画面<br/>React<br/>:3001]
    
    Web -->|JSON/HTTPS| API[APIサーバー<br/>Node.js/Express<br/>:4000]
    AdminWeb -->|JSON/HTTPS| API
    
    API -->|SQL| DB[(データベース<br/>PostgreSQL<br/>:5432)]
    API -->|HTTP| Redis[キャッシュ<br/>Redis<br/>:6379]
    API -->|HTTP| S3[ストレージ<br/>AWS S3]
    
    API -->|HTTPS| Stripe[Stripe API]
    API -->|HTTPS| SendGrid[SendGrid API]
    
    style Web fill:#e1f5ff
    style AdminWeb fill:#e1f5ff
    style API fill:#fff3e0
    style DB fill:#c8e6c9
    style Redis fill:#f3e5f5
    style S3 fill:#fff9c4
```

**記述例：**

```markdown
## Container図：ECサイトシステム

### Webアプリケーション（フロントエンド）
- **技術スタック**：React 18 + TypeScript
- **ポート**：3000
- **責務**：ユーザーインターフェース、画面表示

### 管理画面（フロントエンド）
- **技術スタック**：React 18 + TypeScript
- **ポート**：3001
- **責務**：管理者向けUI、商品管理

### APIサーバー（バックエンド）
- **技術スタック**：Node.js + Express + TypeScript
- **ポート**：4000
- **責務**：ビジネスロジック、データ処理

### データベース
- **技術スタック**：PostgreSQL 15
- **ポート**：5432
- **責務**：データ永続化

### キャッシュ
- **技術スタック**：Redis 7
- **ポート**：6379
- **責務**：セッション管理、頻繁にアクセスされるデータのキャッシュ

### ストレージ
- **技術スタック**：AWS S3
- **責務**：商品画像の保存
```

#### レベル3：Component（コンポーネント図）

**目的：** 各コンテナ内部の主要コンポーネントを示す  
**対象読者：** 開発者

```mermaid
graph TD
    API[APIサーバー] --> Auth[認証<br/>コンポーネント]
    API --> Product[商品管理<br/>コンポーネント]
    API --> Order[注文管理<br/>コンポーネント]
    API --> Payment[決済<br/>コンポーネント]
    API --> Email[メール<br/>コンポーネント]
    
    Auth -->|JWT発行・検証| AuthService[認証サービス]
    Product -->|CRUD| ProductService[商品サービス]
    Order -->|処理| OrderService[注文サービス]
    Payment -->|決済処理| PaymentService[決済サービス]
    Email -->|送信| EmailService[メールサービス]
    
    ProductService --> DB[(DB)]
    OrderService --> DB
    PaymentService --> Stripe[Stripe]
    EmailService --> SendGrid[SendGrid]
    
    style API fill:#e1f5ff,stroke:#0277bd,stroke-width:2px
    style Auth fill:#ffcdd2
    style Product fill:#fff3e0
    style Order fill:#c8e6c9
    style Payment fill:#f3e5f5
    style Email fill:#fff9c4
```

**記述例：**

```markdown
## Component図：APIサーバー

### 認証コンポーネント
- **責務**：ユーザー認証、JWT発行・検証、権限チェック
- **主要機能**：
  - ログイン処理
  - トークン生成・検証
  - パスワードハッシュ化

### 商品管理コンポーネント
- **責務**：商品情報のCRUD操作
- **主要機能**：
  - 商品一覧取得
  - 商品詳細取得
  - 商品登録・更新・削除
  - 在庫確認

### 注文管理コンポーネント
- **責務**：注文処理、注文履歴管理
- **主要機能**：
  - カート管理
  - 注文作成
  - 注文履歴取得
  - 注文キャンセル

### 決済コンポーネント
- **責務**：決済処理
- **主要機能**：
  - Stripe連携
  - 決済情報の検証
  - 決済実行
  - 決済履歴管理

### メールコンポーネント
- **責務**：メール送信
- **主要機能**：
  - 注文確認メール
  - 発送通知メール
  - パスワードリセットメール
```

#### レベル4：Code（コード図）

**目的：** クラス・関数レベルの詳細設計  
**対象読者：** 実装担当者

通常はコードそのものとコメントで十分なので、特別な図は不要な場合が多いです。必要な場合はクラス図を使用します。

### 📐 UML（Unified Modeling Language）

UMLは、オブジェクト指向設計で広く使われる標準的な図法です。13種類の図がありますが、実務でよく使うのは以下の4つです。

#### 1. クラス図

**目的：** クラスの構造と関係を表現

```mermaid
classDiagram
    class User {
        -id: number
        -email: string
        -passwordHash: string
        -createdAt: Date
        +register()
        +login()
        +updateProfile()
    }
    
    class Order {
        -id: number
        -userId: number
        -totalAmount: number
        -status: OrderStatus
        -createdAt: Date
        +create()
        +cancel()
        +getItems()
    }
    
    class OrderItem {
        -id: number
        -orderId: number
        -productId: number
        -quantity: number
        -price: number
        +calculate()
    }
    
    class Product {
        -id: number
        -name: string
        -price: number
        -stock: number
        +updateStock()
        +isAvailable()
    }
    
    User "1" -- "0..*" Order : has
    Order "1" -- "1..*" OrderItem : contains
    Product "1" -- "0..*" OrderItem : ordered as
```

**関係の種類：**

| 記号 | 意味 | 説明 | 例 |
|------|------|------|---|
| `--` | 関連 | 一般的な関係 | UserとOrderの関係 |
| `<|--` | 継承 | is-a関係 | PremiumUserはUserを継承 |
| `*--` | コンポジション | 強い所有関係 | OrderがOrderItemを所有 |
| `o--` | 集約 | 弱い所有関係 | チームがメンバーを持つ |
| `<..` | 依存 | 一時的な関係 | サービスがリポジトリを使用 |

#### 2. シーケンス図

**目的：** オブジェクト間の相互作用を時系列で表現

```mermaid
sequenceDiagram
    participant User as ユーザー
    participant Web as Webアプリ
    participant API as APIサーバー
    participant DB as データベース
    participant Stripe as Stripe API
    
    User->>Web: 購入ボタンをクリック
    Web->>API: POST /orders（注文情報）
    
    API->>DB: 在庫確認
    DB-->>API: 在庫あり
    
    API->>Stripe: 決済リクエスト
    Stripe-->>API: 決済成功
    
    API->>DB: 注文を保存
    DB-->>API: 保存完了
    
    API->>DB: 在庫を減らす
    DB-->>API: 更新完了
    
    API-->>Web: 注文完了レスポンス
    Web-->>User: 完了画面を表示
```

**記述のポイント：**

- 上から下へ時間が流れる
- 実線矢印（→）：同期呼び出し
- 点線矢印（-->）：応答
- 四角の箱：処理の実行中

#### 3. 状態遷移図

**目的：** オブジェクトの状態変化を表現

```mermaid
stateDiagram-v2
    [*] --> 下書き
    
    下書き --> 確認待ち : 提出する
    確認待ち --> 承認済み : 承認する
    確認待ち --> 差戻し : 差し戻す
    差戻し --> 下書き : 修正する
    承認済み --> 発注済み : 発注する
    発注済み --> 完了 : 完了する
    
    下書き --> [*] : キャンセル
    確認待ち --> [*] : キャンセル
    差戻し --> [*] : キャンセル
    
    完了 --> [*]
```

**実務での使用例：**

- 注文のステータス管理
- ワークフローの設計
- 承認プロセスの可視化

#### 4. アクティビティ図

**目的：** 業務フローやアルゴリズムを表現

```mermaid
graph TD
    A([開始：商品購入]) --> B{ログイン<br/>している?}
    B -->|No| C[ログイン画面へ]
    C --> B
    B -->|Yes| D[カート内容を確認]
    D --> E{在庫は<br/>ある?}
    E -->|No| F[在庫切れ<br/>メッセージ表示]
    F --> Z([終了])
    E -->|Yes| G[配送先情報を入力]
    G --> H[決済情報を入力]
    H --> I[確認画面を表示]
    I --> J{内容<br/>OK?}
    J -->|No| G
    J -->|Yes| K[決済処理]
    K --> L{決済<br/>成功?}
    L -->|No| M[エラー<br/>メッセージ表示]
    M --> H
    L -->|Yes| N[注文確定]
    N --> O[在庫を減らす]
    O --> P[確認メールを送信]
    P --> Q[完了画面を表示]
    Q --> Z
    
    style A fill:#c8e6c9
    style B fill:#fff9c4
    style E fill:#fff9c4
    style J fill:#fff9c4
    style L fill:#fff9c4
    style Z fill:#ffcdd2
```

### 🆚 C4モデル vs UML の使い分け

| 観点 | C4モデル | UML |
|------|---------|-----|
| **学習コスト** | ⭐ 低い | ⭐⭐⭐ 高い |
| **わかりやすさ** | ⭐⭐⭐ 非技術者にも分かる | ⭐⭐ 技術者向け |
| **ツールの必要性** | 不要（手書きOK） | あると便利 |
| **適用場面** | システム全体の構造 | 詳細設計 |
| **推奨度** | ⭐⭐⭐ 現代的 | ⭐⭐ 伝統的 |

**実務での推奨：**

- **大枠の設計**：C4モデルを使用（レベル1〜3）
- **詳細設計**：必要に応じてUMLのクラス図・シーケンス図を追加

### 🛠️ 設計図作成ツール

| ツール名 | 特徴 | 価格 | 推奨度 | URL |
|---------|------|------|--------|-----|
| **Mermaid** | テキストで図を書ける<br/>Markdown対応 | 無料 | ⭐⭐⭐ | <https://mermaid.js.org/> |
| **Draw.io（diagrams.net）** | 無料で高機能<br/>ブラウザで動作 | 無料 | ⭐⭐⭐ | <https://www.diagrams.net/> |
| **Figma** | UI設計に最適<br/>共同編集可能 | 無料〜 | ⭐⭐⭐ | <https://www.figma.com/> |
| **Lucidchart** | 多機能<br/>企業向け | 有料 | ⭐⭐ | <https://www.lucidchart.com/> |
| **PlantUML** | テキストでUML図<br/>エンジニア向け | 無料 | ⭐⭐ | <https://plantuml.com/> |
| **Microsoft Visio** | 伝統的なツール | 有料 | ⭐ | <https://www.microsoft.com/visio> |

**初心者におすすめ：**

1. **Mermaid**（このガイドで使用）：Markdownに埋め込める
2. **Draw.io**：ドラッグ&ドロップで簡単

---

## 5.3 テスト設計技法

### 📖 テスト設計とは

テスト設計は、**どのようにテストするか**を決めるプロセスです。闇雲にテストするのではなく、効率的に品質を確保するための技法があります。

### 🎯 テスト設計の重要性

```mermaid
graph TD
    A[テスト設計なし] --> A1[❌ 場当たり的なテスト]
    A --> A2[❌ バグの見落とし]
    A --> A3[❌ 無駄なテストの重複]
    
    B[テスト設計あり] --> B1[✅ 網羅的なテスト]
    B --> B2[✅ 効率的なテスト]
    B --> B3[✅ 品質の可視化]
    
    style A fill:#ffcdd2,stroke:#c62828
    style B fill:#c8e6c9,stroke:#2e7d32
```

### 🛠️ 主要なテスト設計技法

#### 技法1：同値分割法

**概要：**
入力値の範囲を「同じ結果になるグループ」に分けて、各グループから1つだけテストする手法

**例：年齢入力のテスト**

```markdown
## 仕様
- 0歳以上18歳未満：「未成年」と表示
- 18歳以上65歳未満：「成人」と表示
- 65歳以上150歳以下：「シニア」と表示
- 上記以外：エラー

## 同値分割
| クラス | 範囲 | 代表値 | 期待結果 |
|--------|------|--------|---------|
| 有効同値1 | 0〜17 | 10 | 「未成年」 |
| 有効同値2 | 18〜64 | 30 | 「成人」 |
| 有効同値3 | 65〜150 | 70 | 「シニア」 |
| 無効同値1 | -1以下 | -1 | エラー |
| 無効同値2 | 151以上 | 151 | エラー |

## テストケース（5件）
1. 入力：10 → 期待：「未成年」
2. 入力：30 → 期待：「成人」
3. 入力：70 → 期待：「シニア」
4. 入力：-1 → 期待：エラー
5. 入力：151 → 期待：エラー
```

**メリット：**

- ✅ テストケースを大幅に削減
- ✅ 体系的にテストできる
- ✅ 漏れが少ない

#### 技法2：境界値分析

**概要：**
範囲の境界（端の値）をテストする手法。バグは境界で起こりやすい

**例：年齢入力のテスト（同値分割の拡張）**

```markdown
## 境界値分析

| テストNo | 入力値 | 境界の種類 | 期待結果 |
|---------|--------|-----------|---------|
| 1 | -1 | 無効境界 | エラー |
| 2 | 0 | 最小有効値 | 「未成年」 |
| 3 | 1 | 最小有効値+1 | 「未成年」 |
| 4 | 17 | 境界値 | 「未成年」 |
| 5 | 18 | 境界値 | 「成人」 |
| 6 | 19 | 境界値+1 | 「成人」 |
| 7 | 64 | 境界値 | 「成人」 |
| 8 | 65 | 境界値 | 「シニア」 |
| 9 | 66 | 境界値+1 | 「シニア」 |
| 10 | 149 | 最大有効値-1 | 「シニア」 |
| 11 | 150 | 最大有効値 | 「シニア」 |
| 12 | 151 | 無効境界 | エラー |
```

**境界値の選び方：**

- 最小値 - 1
- 最小値
- 最小値 + 1
- 最大値 - 1
- 最大値
- 最大値 + 1

#### 技法3：デシジョンテーブル（決定表）

**概要：**
複数の条件の組み合わせを表で整理する手法

**例：割引料金の計算**

```markdown
## 仕様
- 会員かつ購入金額1万円以上：20%割引
- 会員かつ購入金額1万円未満：10%割引
- 非会員かつ購入金額1万円以上：10%割引
- 非会員かつ購入金額1万円未満：割引なし

## デシジョンテーブル

| ケースNo | 条件1：会員 | 条件2：1万円以上 | アクション：割引率 |
|---------|-----------|---------------|----------------|
| 1 | ○ | ○ | 20% |
| 2 | ○ | × | 10% |
| 3 | × | ○ | 10% |
| 4 | × | × | 0% |

## テストケース
1. 会員=true, 金額=15000 → 割引20%
2. 会員=true, 金額=5000 → 割引10%
3. 会員=false, 金額=15000 → 割引10%
4. 会員=false, 金額=5000 → 割引0%
```

**メリット：**

- ✅ 複雑な条件を整理できる
- ✅ 組み合わせの漏れを防げる
- ✅ ビジネスロジックのレビューに使える

#### 技法4：状態遷移テスト

**概要：**
状態の変化をテストする手法

**例：ATMのカードロック機能**

```mermaid
stateDiagram-v2
    [*] --> 正常
    正常 --> 警告 : PINコード誤り（1回目）
    警告 --> 危険 : PINコード誤り（2回目）
    危険 --> ロック : PINコード誤り（3回目）
    
    正常 --> 正常 : PINコード正解
    警告 --> 正常 : PINコード正解
    危険 --> 正常 : PINコード正解
    
    ロック --> [*] : 解除不可
```

**テストケース：**

| テストNo | 初期状態 | イベント | 期待される次状態 | 備考 |
|---------|---------|---------|---------------|------|
| 1 | 正常 | 正しいPIN | 正常 | 正常系 |
| 2 | 正常 | 誤ったPIN | 警告 | 1回目の失敗 |
| 3 | 警告 | 正しいPIN | 正常 | 回復 |
| 4 | 警告 | 誤ったPIN | 危険 | 2回目の失敗 |
| 5 | 危険 | 正しいPIN | 正常 | 回復 |
| 6 | 危険 | 誤ったPIN | ロック | 3回目の失敗 |
| 7 | ロック | 正しいPIN | ロック | ロック後は解除不可 |

**状態遷移カバレッジ：**

- **0-スイッチカバレッジ**：全ての状態を通る（最低限）
- **1-スイッチカバレッジ**：全ての遷移を通る（推奨）
- **N-スイッチカバレッジ**：N個の連続した遷移を全て通る（厳密）

#### 技法5：ペアワイズ法（組み合わせテスト）

**概要：**
全ての組み合わせではなく、「任意の2つのパラメータの組み合わせ」を網羅する手法

**例：Webブラウザのテスト**

```markdown
## パラメータ
- ブラウザ：Chrome、Firefox、Safari（3種類）
- OS：Windows、Mac、Linux（3種類）
- 画面サイズ：Desktop、Tablet、Mobile（3種類）

## 全組み合わせ
3 × 3 × 3 = 27パターン（現実的でない）

## ペアワイズ法で削減
最小9パターンで全てのペアをカバー可能！

| No | ブラウザ | OS | 画面サイズ |
|----|---------|-------|----------|
| 1 | Chrome | Windows | Desktop |
| 2 | Chrome | Mac | Tablet |
| 3 | Chrome | Linux | Mobile |
| 4 | Firefox | Windows | Tablet |
| 5 | Firefox | Mac | Mobile |
| 6 | Firefox | Linux | Desktop |
| 7 | Safari | Windows | Mobile |
| 8 | Safari | Mac | Desktop |
| 9 | Safari | Linux | Tablet |
```

**ツール：**

- **PICT**（Microsoft製、無料）
- **AllPairs**（オンラインツール）
- **CTE XL**（Excelアドイン）

**メリット：**

- ✅ テストケースを大幅削減（70〜90%削減）
- ✅ 実用的なバグの多くを検出可能
- ✅ 短期間でリリース可能

### 📊 技法の使い分け

| 技法 | 適用場面 | 削減効果 | 難易度 |
|------|---------|---------|--------|
| **同値分割** | 入力値の範囲がある | ⭐⭐⭐ | ⭐ |
| **境界値分析** | 範囲の端でバグが出やすい | ⭐⭐ | ⭐ |
| **デシジョンテーブル** | 複数条件の組み合わせ | ⭐⭐ | ⭐⭐ |
| **状態遷移テスト** | 状態を持つシステム | ⭐⭐ | ⭐⭐ |
| **ペアワイズ** | パラメータが多い | ⭐⭐⭐ | ⭐⭐⭐ |

### 🎓 テスト設計のベストプラクティス

```mermaid
graph TD
    A[テスト設計] --> B[①正常系を網羅]
    A --> C[②異常系を忘れずに]
    A --> D[③境界値を必ずテスト]
    A --> E[④期待結果を明確に]
    
    B --> B1[ユーザーが期待する<br/>動作をテスト]
    C --> C1[エラー処理も<br/>重要な機能]
    D --> D1[バグは境界で<br/>起こりやすい]
    E --> E1[「正しく動く」では<br/>不十分]
    
    style A fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
    style B fill:#e1f5ff
    style C fill:#ffcdd2
    style D fill:#fff3e0
    style E fill:#f3e5f5
```

**テスト設計チェックリスト：**

```markdown
## テスト設計チェックリスト

### 網羅性
- [ ] 正常系のテストケースがある
- [ ] 異常系のテストケースがある
- [ ] 境界値のテストケースがある
- [ ] 全ての機能要求がカバーされている

### 明確性
- [ ] 各テストケースに一意のIDがある
- [ ] 前提条件が明確
- [ ] テスト手順が具体的
- [ ] 期待結果が明確（数値や文言まで）

### 実行可能性
- [ ] テストデータの準備方法が明確
- [ ] テスト環境の構築方法が明確
- [ ] 自動化可能なテストは自動化を検討
- [ ] テストの実行時間が適切

### トレーサビリティ
- [ ] 要件とテストケースが紐付いている
- [ ] カバレッジが測定可能
```

### 🔧 テスト設計ツール

| ツール名 | 用途 | 特徴 |
|---------|------|------|
| **TestRail** | テストケース管理 | 商用、UIが優れている |
| **Qase** | テストケース管理 | 商用、モダンなUI |
| **TestLink** | テストケース管理 | オープンソース、無料 |
| **PICT** | ペアワイズ生成 | Microsoft製、無料 |
| **Xmind** | マインドマップ | テスト設計の整理に便利 |

---

## 5.4 Gherkinによる受入基準

### 📖 Gherkinとは

**Gherkin**は、ビジネス側と技術側が共通理解を持つための、自然言語に近い記述形式です。Given-When-Then形式で書きます。

### 🎯 Gherkinの基本構文

```gherkin
Feature: ログイン機能
  ユーザーがシステムに安全にログインできる

  Scenario: 正しいメールアドレスとパスワードでログイン
    Given ユーザー "test@example.com" が登録されている
    And パスワードは "SecurePass123" である
    When ユーザーがメールアドレス "test@example.com" を入力
    And パスワード "SecurePass123" を入力
    And "ログイン" ボタンをクリック
    Then ダッシュボード画面が表示される
    And "ようこそ、山田太郎さん" というメッセージが表示される

  Scenario: 誤ったパスワードでログイン
    Given ユーザー "test@example.com" が登録されている
    When ユーザーがメールアドレス "test@example.com" を入力
    And パスワード "WrongPassword" を入力
    And "ログイン" ボタンをクリック
    Then "メールアドレスまたはパスワードが間違っています" というエラーが表示される
    And ログイン画面のままである
```

### 📝 Gherkinキーワード

| キーワード | 意味 | 使い方 |
|-----------|------|--------|
| **Feature** | 機能 | テストする機能の名前と説明 |
| **Scenario** | シナリオ | 1つのテストケース |
| **Given** | 前提条件 | テスト実行前の状態 |
| **When** | 実行 | ユーザーのアクション |
| **Then** | 検証 | 期待される結果 |
| **And** | 追加 | Given/When/Thenの追加 |
| **But** | 例外 | Andと同じだが、否定的な意味 |
| **Background** | 共通前提 | 全シナリオ共通の前提条件 |
| **Scenario Outline** | パラメータ化 | データを変えて同じテストを繰り返す |

### 🔄 Scenario Outlineの例

```gherkin
Feature: 商品検索機能

  Scenario Outline: さまざまなキーワードで商品検索
    Given 以下の商品が登録されている
      | 商品名 | カテゴリ | 価格 |
      | MacBook Pro | パソコン | 250000 |
      | iPhone 15 | スマートフォン | 120000 |
      | AirPods Pro | オーディオ | 35000 |
    When ユーザーが "<キーワード>" で検索
    Then <件数> 件の商品が表示される
    And 最初の商品は "<最初の商品名>" である

    Examples:
      | キーワード | 件数 | 最初の商品名 |
      | Mac | 1 | MacBook Pro |
      | iPhone | 1 | iPhone 15 |
      | Pro | 2 | MacBook Pro |
      | オーディオ | 1 | AirPods Pro |
      | Android | 0 | （なし） |
```

### ✅ Gherkinのメリット

```mermaid
graph TD
    A[Gherkin] --> B[📖 読みやすい]
    A --> C[🤝 共通言語]
    A --> D[🔄 自動化可能]
    A --> E[📋 ドキュメント]
    
    B --> B1[非技術者も理解できる]
    C --> C1[ビジネスと開発の<br/>認識を統一]
    D --> D1[CucumberやBehave<br/>で自動テスト]
    E --> E1[仕様書としても機能]
    
    style A fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
```

### 🛠️ Gherkinを使った開発フロー（BDD）

```mermaid
graph LR
    A[①要件定義] --> B[②Gherkin<br/>シナリオ作成]
    B --> C[③レビュー<br/>ビジネス側と合意]
    C --> D[④実装]
    D --> E[⑤自動テスト実行]
    E --> F{Pass?}
    F -->|No| D
    F -->|Yes| G[✅完了]
    
    style A fill:#fff3e0
    style B fill:#e1f5ff
    style C fill:#fff9c4
    style D fill:#c8e6c9
    style E fill:#f3e5f5
    style G fill:#c8e6c9
```

### 📚 実践例：ECサイトのカート機能

```gherkin
Feature: ショッピングカート機能
  ユーザーが商品をカートに追加・削除・購入できる

  Background:
    Given ユーザー "test@example.com" がログインしている
    And カートは空である

  Scenario: 商品をカートに追加
    Given 商品 "MacBook Pro" が在庫10個で存在する
    When ユーザーが商品詳細ページで "MacBook Pro" を表示
    And 数量 "2" を選択
    And "カートに追加" ボタンをクリック
    Then カートに "MacBook Pro" が 2個 追加される
    And "カートに追加しました" というメッセージが表示される

  Scenario: カート内の商品数量を変更
    Given カートに以下の商品がある
      | 商品名 | 数量 | 単価 |
      | MacBook Pro | 2 | 250000 |
    When ユーザーがカート画面を開く
    And "MacBook Pro" の数量を "3" に変更
    Then カート内の "MacBook Pro" が 3個 になる
    And 合計金額が "750000円" と表示される

  Scenario: カートから商品を削除
    Given カートに以下の商品がある
      | 商品名 | 数量 |
      | MacBook Pro | 2 |
      | iPhone 15 | 1 |
    When ユーザーが "iPhone 15" の "削除" ボタンをクリック
    Then カートから "iPhone 15" が削除される
    And カートには "MacBook Pro" のみ残る

  Scenario: 在庫を超える数量を追加しようとする
    Given 商品 "MacBook Pro" が在庫5個で存在する
    When ユーザーが商品詳細ページで "MacBook Pro" を表示
    And 数量 "10" を選択
    And "カートに追加" ボタンをクリック
    Then "在庫が不足しています（在庫数：5）" というエラーが表示される
    And カートには何も追加されない
```

### 🎓 Gherkin記述のベストプラクティス

**良い例：**

```gherkin
Scenario: ユーザー登録（良い例）
  Given ユーザー登録画面を開いている
  When メールアドレス "test@example.com" を入力
  And パスワード "SecurePass123" を入力
  And パスワード（確認） "SecurePass123" を入力
  And "登録" ボタンをクリック
  Then "登録完了" ページが表示される
  And "確認メールを送信しました" というメッセージが表示される
```

**悪い例：**

```gherkin
Scenario: ユーザー登録（悪い例）
  Given 登録フォームがある
  When データを入力
  And 送信する
  Then 成功する
  # ← 具体性がなく、何をテストしているか不明
```

**ルール：**

1. **具体的に書く**：「データを入力」ではなく「メールアドレス "<test@example.com>" を入力」
2. **実装の詳細を書かない**：「DBに INSERT する」ではなく「ユーザーが登録される」
3. **1シナリオ1テスト**：複数のことを1つのシナリオでテストしない
4. **ユーザー目線で書く**：技術用語を避ける

---

## 5.5 バージョン管理とトレーサビリティ

### 📖 バージョン管理とは

**バージョン管理**は、ドキュメントやコードの変更履歴を記録し、いつでも過去の状態に戻せるようにする仕組みです。

### 🎯 なぜバージョン管理が必要なのか

```mermaid
graph TD
    A[バージョン管理なし] --> A1[❌ 誰が何を変更したか<br/>分からない]
    A --> A2[❌ 過去の状態に<br/>戻せない]
    A --> A3[❌ 複数人で編集すると<br/>上書きされる]
    
    B[バージョン管理あり] --> B1[✅ 全ての変更履歴が<br/>記録される]
    B --> B2[✅ いつでも過去に<br/>戻れる]
    B --> B3[✅ 複数人で<br/>同時作業可能]
    
    style A fill:#ffcdd2,stroke:#c62828
    style B fill:#c8e6c9,stroke:#2e7d32
```

### 🛠️ バージョン管理の方法

#### 方法1：ファイル名でのバージョン管理（非推奨）

**やり方：**

```
要件定義書_v1.0.docx
要件定義書_v1.1.docx
要件定義書_v1.2_修正版.docx
要件定義書_最終版.docx
要件定義書_最終版_本当に最終.docx  ← こうなりがち...
```

**問題点：**

- ❌ ファイルが増えて混乱
- ❌ 何が変更されたか分からない
- ❌ 複数人で同時編集できない
- ❌ 過去のバージョン間の差分が見づらい

#### 方法2：Git（推奨）

**Git**は、世界中で最も使われているバージョン管理システムです。

**基本概念：**

```mermaid
graph LR
    A[作業ディレクトリ] -->|git add| B[ステージング]
    B -->|git commit| C[ローカルリポジトリ]
    C -->|git push| D[リモートリポジトリ<br/>GitHub/GitLab]
    D -->|git pull| A
    
    style A fill:#fff3e0
    style B fill:#fff9c4
    style C fill:#e1f5ff
    style D fill:#c8e6c9
```

**基本コマンド：**

| コマンド | 説明 | 使用例 |
|---------|------|--------|
| `git init` | リポジトリを初期化 | `git init` |
| `git add` | 変更をステージング | `git add 要件定義書.md` |
| `git commit` | 変更を記録 | `git commit -m "顧客検索機能を追加"` |
| `git push` | リモートに送信 | `git push origin main` |
| `git pull` | リモートから取得 | `git pull origin main` |
| `git status` | 現在の状態を確認 | `git status` |
| `git log` | 変更履歴を表示 | `git log --oneline` |
| `git diff` | 差分を表示 | `git diff` |

**実践例：要件定義書のバージョン管理**

```bash
# 1. リポジトリを初期化
git init

# 2. 要件定義書を作成
vim 要件定義書.md

# 3. 変更をステージング
git add 要件定義書.md

# 4. 変更を記録（コミット）
git commit -m "初版：顧客管理機能の要件定義"

# 5. 顧客検索機能を追加
vim 要件定義書.md
git add 要件定義書.md
git commit -m "顧客検索機能の要件を追加"

# 6. 変更履歴を確認
git log --oneline
# 出力例：
# abc1234 顧客検索機能の要件を追加
# def5678 初版：顧客管理機能の要件定義

# 7. 差分を確認
git diff def5678 abc1234
```

**コミットメッセージのベストプラクティス：**

```markdown
# 良いコミットメッセージの例
✅ feat: 顧客検索機能の要件を追加
✅ fix: 登録フォームのバリデーション条件を修正
✅ docs: アーキテクチャ図を更新
✅ refactor: 非機能要求のセクションを再構成

# 悪いコミットメッセージの例
❌ 修正
❌ 更新
❌ いろいろ変更
❌ asdf
```

**コミットメッセージのルール（Conventional Commits）：**

| プレフィックス | 意味 | 例 |
|--------------|------|---|
| `feat:` | 新機能の追加 | `feat: ログイン機能の要件を追加` |
| `fix:` | バグ修正 | `fix: レスポンスタイムの目標値を修正` |
| `docs:` | ドキュメントの変更 | `docs: 用語集にAPIの説明を追加` |
| `refactor:` | リファクタリング | `refactor: 要件の構成を見直し` |
| `test:` | テストの追加・修正 | `test: 境界値テストケースを追加` |
| `chore:` | その他の変更 | `chore: 誤字を修正` |

#### 方法3：クラウドドキュメント（Google Docs、Notion）

**メリット：**

- ✅ リアルタイムで複数人が同時編集
- ✅ 自動保存
- ✅ 変更履歴の確認が簡単
- ✅ コメント機能で議論可能

**デメリット：**

- ❌ Gitほど細かいバージョン管理はできない
- ❌ オフライン作業が難しい
- ❌ 大規模なプロジェクトには向かない

**使い分け：**

- **Git**：コードと一緒に管理する技術ドキュメント
- **Google Docs/Notion**：ビジネス側も編集するドキュメント

### 🔗 トレーサビリティとは

**トレーサビリティ**は、要件から設計、実装、テストまでの**つながりを追跡できる**ようにすることです。

### 📊 トレーサビリティの重要性

```mermaid
graph LR
    A[要件<br/>FR-001] -->|前方トレース| B[設計<br/>BD-001]
    B -->|前方トレース| C[実装<br/>Code]
    C -->|前方トレース| D[テスト<br/>TC-001]
    
    D -.後方トレース.-> C
    C -.後方トレース.-> B
    B -.後方トレース.-> A
    
    style A fill:#ffcdd2,stroke:#c62828
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#c8e6c9,stroke:#2e7d32
    style D fill:#b3e5fc,stroke:#0277bd
```

**トレーサビリティがあると：**

- ✅ 要件の抜け漏れを防げる
- ✅ 変更の影響範囲が分かる
- ✅ なぜそう作ったのかが分かる
- ✅ テストのカバレッジが分かる

### 🛠️ トレーサビリティの実現方法

#### 方法1：ID体系の確立

**命名規則の例：**

```markdown
## ID体系

### 要件
- 機能要求：FR-001, FR-002, ...
- 非機能要求：NFR-001, NFR-002, ...
- ビジネスルール：BR-001, BR-002, ...

### 設計
- 基本設計：BD-001, BD-002, ...
- 詳細設計：DD-001, DD-002, ...
- データベース設計：DB-001, DB-002, ...

### テスト
- 単体テスト：UT-001, UT-002, ...
- 統合テスト：IT-001, IT-002, ...
- システムテスト：ST-001, ST-002, ...
- 受入テスト：AT-001, AT-002, ...

### その他
- バグ：BUG-001, BUG-002, ...
- タスク：TASK-001, TASK-002, ...
```

#### 方法2：トレーサビリティマトリクス（RTM）

**完全版の例：**

```markdown
## トレーサビリティマトリクス

| 要件ID | 要件名 | 優先度 | 基本設計 | 詳細設計 | 実装 | 単体テスト | 統合テスト | システムテスト | ステータス |
|--------|--------|--------|---------|---------|------|-----------|-----------|--------------|-----------|
| FR-001 | 顧客登録 | Must | BD-001 | DD-001<br/>DD-002 | CustomerController.ts<br/>CustomerService.ts | UT-001〜010 | IT-001〜003 | ST-001 | ✅完了 |
| FR-002 | 顧客検索 | Must | BD-002 | DD-003 | SearchController.ts | UT-011〜020 | IT-004〜006 | ST-002 | ✅完了 |
| FR-003 | 顧客編集 | Must | BD-003 | DD-004 | CustomerController.ts | UT-021〜030 | IT-007〜009 | ST-003 | 🟡進行中 |
| FR-004 | 顧客削除 | Must | BD-004 | DD-005 | CustomerController.ts | UT-031〜040 | IT-010〜012 | ST-004 | 🔴未着手 |
| NFR-001 | レスポンス | Must | BD-010 | DD-020 | 全体 | UT-100〜105 | IT-050 | ST-100 | ✅完了 |
| NFR-002 | セキュリティ | Must | BD-011 | DD-021<br/>DD-022 | AuthMiddleware.ts | UT-106〜115 | IT-051〜053 | ST-101 | ✅完了 |
```

**カバレッジの計算：**

```
テストカバレッジ = テスト済み要件数 / 全要件数 × 100
                = 4 / 6 × 100
                = 66.7%
```

#### 方法3：ツールを使った管理

**推奨ツール：**

| ツール | 用途 | 特徴 | 料金 |
|--------|------|------|------|
| **Jira** | プロジェクト管理 | 要件・タスク・バグを一元管理 | 有料 |
| **Azure DevOps** | 開発ライフサイクル全体 | Microsoft製、統合環境 | 無料〜 |
| **GitHub Issues** | 軽量な課題管理 | Gitと統合、シンプル | 無料〜 |
| **Notion** | ドキュメント管理 | 柔軟なデータベース機能 | 無料〜 |
| **Confluence** | ドキュメント管理 | Jiraと連携 | 有料 |

**Jiraでのトレーサビリティ例：**

```markdown
## 要件（Epic）
ID: PROJ-1
タイトル: 顧客管理機能
説明: 顧客情報の登録・検索・編集・削除

### 子タスク（Story）
- PROJ-10: 顧客登録画面の実装
- PROJ-11: 顧客検索機能の実装
- PROJ-12: 顧客編集機能の実装

### リンク
- テストケース: TEST-001〜TEST-010
- 設計書: [Confluence] 顧客管理設計書
- バグ: BUG-050（リンク済み）
```

### 🎓 バージョン管理とトレーサビリティのベストプラクティス

```mermaid
graph TD
    A[ベストプラクティス] --> B[①小さく頻繁にコミット]
    A --> C[②意味のあるコミットメッセージ]
    A --> D[③ブランチ戦略を決める]
    A --> E[④IDを一貫して使う]
    
    B --> B1[1日1回は最低限<br/>コミット]
    C --> C1[「何を」「なぜ」<br/>変更したか]
    D --> D1[main/develop/<br/>feature分離]
    E --> E1[全ドキュメントで<br/>同じルール]
    
    style A fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
    style B fill:#e1f5ff
    style C fill:#fff3e0
    style D fill:#f3e5f5
    style E fill:#fff9c4
```

**Git運用のブランチ戦略（Git Flow）：**

```mermaid
gitGraph
    commit id: "Initial"
    branch develop
    checkout develop
    commit id: "開発開始"
    
    branch feature/login
    checkout feature/login
    commit id: "ログイン機能"
    commit id: "テスト追加"
    
    checkout develop
    merge feature/login
    
    branch feature/search
    checkout feature/search
    commit id: "検索機能"
    
    checkout develop
    merge feature/search
    
    checkout main
    merge develop tag: "v1.0.0"
```

**ブランチ戦略の説明：**

| ブランチ | 用途 | 保護 |
|---------|------|------|
| **main** | 本番環境にデプロイされるコード | 🔒 直接コミット禁止 |
| **develop** | 開発の最新状態 | 🔒 レビュー必須 |
| **feature/***| 新機能開発 | ✅ 自由に開発 |
| **hotfix/*** | 緊急バグ修正 | ⚠️ mainから分岐 |
| **release/** | リリース準備 | ⚠️ バージョンタグ付け |

### 📋 チェックリスト

```markdown
## バージョン管理チェックリスト

### 初期設定
- [ ] Gitリポジトリを作成
- [ ] .gitignoreファイルを設定（不要なファイルを除外）
- [ ] ブランチ戦略を決定
- [ ] コミットメッセージのルールを決定

### 日常作業
- [ ] 作業前に最新版をpull
- [ ] 意味のある単位でcommit
- [ ] 分かりやすいコミットメッセージ
- [ ] 1日1回はpush

### トレーサビリティ
- [ ] 全てのドキュメントにIDを付与
- [ ] RTMを定期的に更新
- [ ] 変更時は関連するドキュメントも更新
- [ ] リンク切れがないか確認
```

---

## 第5章のまとめ

本章では、システム開発ドキュメントを作成するための**実践的手法とツール**を解説しました：

### 5.1 要件定義の技法

- **インタビュー法**：ステークホルダーから直接ヒアリング
- **ワークショップ法**：複数人でグループワーク
- **プロトタイピング法**：実際に動く試作品で確認
- **ユースケース法**：シナリオで要件を記述
- **ユーザーストーリー法**：アジャイル向けの簡潔な記述

### 5.2 設計手法

- **C4モデル**：4つのレベルでシステム構造を表現（推奨）
- **UML**：クラス図、シーケンス図、状態遷移図、アクティビティ図
- 使い分け：大枠はC4、詳細はUML

### 5.3 テスト設計技法

- **同値分割法**：グループ分けで効率化
- **境界値分析**：バグが出やすい境界をテスト
- **デシジョンテーブル**：複数条件の組み合わせを整理
- **状態遷移テスト**：状態の変化をテスト
- **ペアワイズ法**：組み合わせを大幅削減（70〜90%削減）

### 5.4 Gherkinによる受入基準

- **Given-When-Then形式**：自然言語に近い記述
- **ビジネス側と技術側の共通言語**
- **自動テスト**：CucumberやBehaveで実行可能

### 5.5 バージョン管理とトレーサビリティ

- **Git**：世界標準のバージョン管理システム
- **トレーサビリティマトリクス**：要件から実装・テストまで追跡
- **ブランチ戦略**：Git Flowで効率的な開発

次の第6章では、**国際標準規格（ISO）**について解説します。システム開発の世界標準を学びましょう！

---

# 第6章:国際標準規格(ISO)

## 📖 第6章の概要

本章では、システム開発に関連する**国際標準規格(ISO/IEC/IEEE)**について解説します。これらの規格は、世界中で使われている開発のベストプラクティスをまとめたものです。

```mermaid
graph TD
    A[国際標準規格の役割] --> B[🌍 世界共通の品質基準]
    A --> C[📋 ドキュメント作成の指針]
    A --> D[🤝 国際的な協業の円滑化]
    A --> E[✅ 品質保証の根拠]
    
    B --> B1[どの国でも<br/>通用する基準]
    C --> C1[何を書くべきか<br/>明確に定義]
    D --> D1[共通言語で<br/>コミュニケーション]
    E --> E1[規格準拠で<br/>信頼性向上]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#c8e6c9,stroke:#2e7d32
    style C fill:#fff3e0,stroke:#ef6c00
    style D fill:#f3e5f5,stroke:#7b1fa2
    style E fill:#fff9c4,stroke:#f57f17
```

### ❓ なぜ国際規格を知る必要があるのか？

| 理由 | 説明 | メリット |
|------|------|---------|
| **品質保証** | 規格に準拠することで最低限の品質を担保 | 😊 顧客の信頼獲得 |
| **効率化** | ベストプラクティスを活用できる | ⚡ 無駄な試行錯誤を削減 |
| **国際展開** | グローバルスタンダードで開発 | 🌍 海外展開が容易 |
| **監査対応** | 第三者認証の取得が可能 | 🏆 競争力の向上 |
| **知識体系** | 体系的な学習が可能 | 📚 スキルアップ |

---

## 6.1 ISO/IEC/IEEE 29148(要求工学)

### 📘 規格の概要

**ISO/IEC/IEEE 29148**は、**要求工学(Requirements Engineering)**に関する国際規格です。要求の定義、分析、文書化、検証の方法を標準化しています。

**正式名称:**  
`ISO/IEC/IEEE 29148:2018 - Systems and software engineering — Life cycle processes — Requirements engineering`

```mermaid
graph LR
    A[ISO/IEC/IEEE 29148] --> B[要求の収集]
    A --> C[要求の分析]
    A --> D[要求の仕様化]
    A --> E[要求の検証]
    
    B --> B1[ステークホルダー<br/>ニーズの特定]
    C --> C1[要求の優先順位付け<br/>実現可能性分析]
    D --> D1[SRS作成<br/>要求の文書化]
    E --> E1[要求の妥当性確認<br/>トレーサビリティ]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#f3e5f5,stroke:#7b1fa2
    style D fill:#c8e6c9,stroke:#2e7d32
    style E fill:#fff9c4,stroke:#f57f17
```

### 🎯 規格の主要内容

#### 1. 要求の分類

ISO 29148では、要求を以下のように分類します:

```mermaid
graph TD
    A[要求の分類] --> B[ステークホルダー要求]
    A --> C[システム要求]
    A --> D[ソフトウェア要求]
    
    B --> B1[ビジネスニーズ<br/>ユーザーニーズ]
    C --> C1[システム全体の<br/>要求仕様]
    D --> D1[ソフトウェア<br/>詳細要求]
    
    B1 -.変換.-> C1
    C1 -.詳細化.-> D1
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#ffcdd2,stroke:#c62828
    style C fill:#fff9c4,stroke:#f57f17
    style D fill:#c8e6c9,stroke:#2e7d32
```

**詳細説明:**

| 分類 | 定義 | 具体例 | 担当者 |
|------|------|--------|--------|
| **ステークホルダー要求** | ビジネス上の目的や<br/>ユーザーの期待 | 「売上を20%向上させたい」<br/>「スマホで使いたい」 | 👔 経営層<br/>👥 エンドユーザー |
| **システム要求** | システム全体が<br/>満たすべき要求 | 「1000ユーザーが同時接続可能」<br/>「99.9%の稼働率」 | 🔧 システムアーキテクト<br/>📊 PMO |
| **ソフトウェア要求** | ソフトウェアが<br/>実装すべき機能 | 「ログイン画面を表示する」<br/>「パスワードを暗号化する」 | 💻 開発者<br/>🎨 デザイナー |

#### 2. 要求の品質特性

ISO 29148が定義する**良い要求の特性**:

```markdown
## 良い要求の8つの特性

### ① 明確性(Unambiguous)
- ✅ 解釈が1つしかない
- ❌ 「使いやすい」「高速」などの曖昧な表現

### ② 完全性(Complete)
- ✅ 必要な情報が全て含まれている
- ❌ 「詳細は後で決める」という先送り

### ③ 一貫性(Consistent)
- ✅ 他の要求と矛盾しない
- ❌ 「24時間対応」と「営業時間のみ」が混在

### ④ 検証可能性(Verifiable)
- ✅ テストで確認できる
- ❌ 「直感的なUI」など主観的な表現

### ⑤ 追跡可能性(Traceable)
- ✅ 元のニーズまで遡れる
- ❌ 「誰が言ったか分からない要求」

### ⑥ 優先順位付け(Prioritized)
- ✅ Must/Should/Couldで分類
- ❌ 全て同じ重要度

### ⑦ 実現可能性(Feasible)
- ✅ 技術的・予算的に可能
- ❌ 「タイムマシンを作る」

### ⑧ 必要性(Necessary)
- ✅ ビジネス価値がある
- ❌ 「あったら良いかも」レベル
```

#### 3. SRS(Software Requirements Specification)の構成

ISO 29148が推奨するSRSの標準構成:

```markdown
# ソフトウェア要求仕様書(SRS)テンプレート

## 1. はじめに
   1.1 目的
   1.2 対象範囲
   1.3 定義、略語、略称
   1.4 参照文書
   1.5 文書の概要

## 2. 全体的な記述
   2.1 製品の概観
   2.2 製品の機能
   2.3 ユーザーの特性
   2.4 制約
   2.5 前提と依存関係

## 3. 詳細な要求
   3.1 機能要求
       3.1.1 ユーザー管理
       3.1.2 データ管理
       3.1.3 レポート機能
   
   3.2 非機能要求
       3.2.1 性能要求
       3.2.2 セキュリティ要求
       3.2.3 信頼性要求
       3.2.4 保守性要求
       3.2.5 移植性要求
   
   3.3 外部インターフェース要求
       3.3.1 ユーザーインターフェース
       3.3.2 ハードウェアインターフェース
       3.3.3 ソフトウェアインターフェース
       3.3.4 通信インターフェース

## 4. 検証
   4.1 検証方法
   4.2 検証基準

## 付録
   A. 用語集
   B. 分析モデル
   C. 変更履歴
```

### 📋 要求記述の実例

**❌ 悪い例:**

```markdown
要求: システムは高速に動作すること
```

**問題点:**

- 「高速」が曖昧
- 検証不可能
- 優先順位不明

**✅ 良い例:**

```markdown
【機能要求】FR-001: 検索レスポンス時間
優先度: Must
説明: ユーザーが検索ボタンをクリックしてから、
      検索結果が画面に表示されるまでの時間は、
      通常の負荷(同時接続100ユーザー)において
      2秒以内でなければならない。

検証方法: 
- 性能テストツールで100ユーザーを同時接続
- 100回の検索を実行
- 95パーセンタイル値が2秒以内であることを確認

関連要求: NFR-001(性能要求)
トレース元: BR-010(ビジネス要求)
```

### 🎓 ISO 29148準拠のチェックリスト

```markdown
## 要求品質チェックリスト

### 明確性の確認
- [ ] 専門用語は全て定義されているか？
- [ ] 複数の解釈ができる文章はないか？
- [ ] 「など」「適切な」などの曖昧な表現を避けているか？

### 完全性の確認
- [ ] 全ての機能要求を網羅しているか？
- [ ] エラー処理も含まれているか？
- [ ] 境界条件も記述されているか？

### 一貫性の確認
- [ ] 他の要求と矛盾していないか？
- [ ] 用語の使い方は統一されているか？
- [ ] 優先順位に矛盾はないか？

### 検証可能性の確認
- [ ] テストで確認できるか？
- [ ] 定量的な基準があるか？
- [ ] 合格条件が明確か？

### 追跡可能性の確認
- [ ] 要求IDは付与されているか？
- [ ] 元のビジネスニーズと紐づいているか？
- [ ] 設計・実装・テストと紐づけられるか？
```

---

## 6.2 ISO/IEC/IEEE 42010(アーキテクチャ記述)

### 📘 規格の概要

**ISO/IEC/IEEE 42010**は、**システムアーキテクチャの記述方法**を標準化した規格です。アーキテクチャをどのように文書化し、伝達するかを定義しています。

**正式名称:**  
`ISO/IEC/IEEE 42010:2022 - Software, systems and enterprise — Architecture description`

```mermaid
graph TD
    A[ISO/IEC/IEEE 42010] --> B[アーキテクチャ<br/>フレームワーク]
    A --> C[ビューポイント]
    A --> D[ビュー]
    A --> E[ステークホルダー<br/>関心事]
    
    B --> B1[全体構造の<br/>定義]
    C --> C1[見る視点<br/>の定義]
    D --> D1[具体的な<br/>表現]
    E --> E1[誰が何に<br/>関心があるか]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#f3e5f5,stroke:#7b1fa2
    style D fill:#c8e6c9,stroke:#2e7d32
    style E fill:#fff9c4,stroke:#f57f17
```

### 🎯 規格の主要概念

#### 1. アーキテクチャの定義

ISO 42010では、アーキテクチャを以下のように定義しています:

```markdown
## アーキテクチャとは

システムの構造を決める基本的な概念や特性、
およびそれらが環境や原則の中で
どのように設計・進化するかを示すもの
```

**アーキテクチャの3要素:**

```mermaid
graph LR
    A[アーキテクチャ] --> B[コンポーネント]
    A --> C[関係性]
    A --> D[原則]
    
    B --> B1[システムを<br/>構成する部品]
    C --> C1[部品同士の<br/>つながり]
    D --> D1[設計の<br/>指針・ルール]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#c8e6c9,stroke:#2e7d32
    style C fill:#fff9c4,stroke:#f57f17
    style D fill:#f3e5f5,stroke:#7b1fa2
```

#### 2. ステークホルダーと関心事

異なるステークホルダーは、異なる関心事を持っています:

```mermaid
graph TD
    A[ステークホルダーの関心事] --> B[👔 経営層]
    A --> C[📊 プロジェクトマネージャー]
    A --> D[🔧 開発者]
    A --> E[🛡️ セキュリティ担当]
    A --> F[⚙️ 運用担当]
    
    B --> B1[ビジネス価値<br/>投資対効果<br/>戦略適合性]
    C --> C1[スケジュール<br/>コスト<br/>リソース]
    D --> D1[技術選定<br/>実装方法<br/>開発しやすさ]
    E --> E1[脅威対策<br/>認証・認可<br/>データ保護]
    F --> F1[可用性<br/>保守性<br/>監視方法]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#ffcdd2,stroke:#c62828
    style C fill:#fff3e0,stroke:#ef6c00
    style D fill:#c8e6c9,stroke:#2e7d32
    style E fill:#fff9c4,stroke:#f57f17
    style F fill:#b3e5fc,stroke:#0277bd
```

#### 3. ビューポイントとビュー

**ビューポイント(Viewpoint)**と**ビュー(View)**の関係:

```mermaid
graph TD
    A[ビューポイント<br/>見方のルール] --> B[機能ビューポイント]
    A --> C[情報ビューポイント]
    A --> D[同時実行ビューポイント]
    A --> E[開発ビューポイント]
    A --> F[配置ビューポイント]
    
    B -.適用.-> B1[機能ビュー<br/>実際の図]
    C -.適用.-> C1[情報ビュー<br/>実際の図]
    D -.適用.-> D1[同時実行ビュー<br/>実際の図]
    E -.適用.-> E1[開発ビュー<br/>実際の図]
    F -.適用.-> F1[配置ビュー<br/>実際の図]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#f3e5f5,stroke:#7b1fa2
    style D fill:#c8e6c9,stroke:#2e7d32
    style E fill:#fff9c4,stroke:#f57f17
    style F fill:#b3e5fc,stroke:#0277bd
```

**5つの主要ビューポイント:**

| ビューポイント | 目的 | 主な関心事 | 使用する図 | ステークホルダー |
|--------------|------|-----------|----------|---------------|
| **機能ビュー**<br/>(Functional) | システムの機能要素 | どんな機能があるか<br/>機能間の関係 | ユースケース図<br/>機能ブロック図 | 👥 エンドユーザー<br/>📊 PM |
| **情報ビュー**<br/>(Information) | データ構造と流れ | どんなデータを扱うか<br/>データの流れ | ER図<br/>データフロー図 | 📊 データアナリスト<br/>💾 DB管理者 |
| **同時実行ビュー**<br/>(Concurrency) | 並行処理と同期 | どう並列処理するか<br/>排他制御 | シーケンス図<br/>状態遷移図 | 🔧 開発者<br/>⚡ 性能担当 |
| **開発ビュー**<br/>(Development) | モジュール構成 | コード構造<br/>依存関係 | クラス図<br/>パッケージ図 | 💻 開発者<br/>🏗️ アーキテクト |
| **配置ビュー**<br/>(Deployment) | 物理配置 | ハードウェア構成<br/>ネットワーク | デプロイ図<br/>ネットワーク図 | ⚙️ インフラ担当<br/>🔒 運用担当 |

### 📐 C4モデルとの対応

ISO 42010のビューポイントは、**C4モデル**(第5章参照)と組み合わせると効果的です:

```mermaid
graph TD
    A[C4モデルのレベル] --> B[Level 1: Context<br/>システムコンテキスト]
    A --> C[Level 2: Container<br/>コンテナ]
    A --> D[Level 3: Component<br/>コンポーネント]
    A --> E[Level 4: Code<br/>コード]
    
    B --> B1[配置ビュー<br/>機能ビュー]
    C --> C1[配置ビュー<br/>情報ビュー]
    D --> D1[開発ビュー<br/>同時実行ビュー]
    E --> E1[開発ビュー<br/>詳細設計]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#ffcdd2,stroke:#c62828
    style C fill:#fff9c4,stroke:#f57f17
    style D fill:#c8e6c9,stroke:#2e7d32
    style E fill:#b3e5fc,stroke:#0277bd
```

### 📝 アーキテクチャ記述書(AD)の構成

ISO 42010準拠のアーキテクチャ記述書テンプレート:

```markdown
# アーキテクチャ記述書(Architecture Description)

## 1. 識別情報
   - ドキュメント名
   - バージョン
   - 作成日・更新日
   - 作成者

## 2. ステークホルダーと関心事
   ### 2.1 ステークホルダー一覧
   | 役割 | 名前 | 主な関心事 |
   |------|------|-----------|
   | 経営層 | 〇〇 | ROI、戦略適合性 |
   | PM | △△ | スケジュール、コスト |
   | 開発 | □□ | 技術選定、実装容易性 |
   
   ### 2.2 関心事の詳細
   - 性能要件への対応
   - セキュリティ対策
   - スケーラビリティ
   - 保守性

## 3. ビューポイント定義
   ### 3.1 機能ビューポイント
   - 目的: システムの機能構造を示す
   - 関心事: 機能分割、機能間連携
   - モデル種類: ユースケース図、機能ブロック図
   - 適用ステークホルダー: エンドユーザー、PM
   
   ### 3.2 情報ビューポイント
   - 目的: データ構造とフローを示す
   - 関心事: エンティティ、関係、制約
   - モデル種類: ER図、データフロー図
   - 適用ステークホルダー: データアナリスト、DBA
   
   ### 3.3 同時実行ビューポイント
   - 目的: 並行処理と同期を示す
   - 関心事: スレッド、プロセス、排他制御
   - モデル種類: シーケンス図、状態遷移図
   - 適用ステークホルダー: 開発者、性能担当
   
   ### 3.4 開発ビューポイント
   - 目的: コード構造を示す
   - 関心事: モジュール分割、依存関係
   - モデル種類: クラス図、パッケージ図
   - 適用ステークホルダー: 開発者、アーキテクト
   
   ### 3.5 配置ビューポイント
   - 目的: 物理配置を示す
   - 関心事: サーバー構成、ネットワーク
   - モデル種類: デプロイ図
   - 適用ステークホルダー: インフラ担当、運用担当

## 4. ビュー(具体的な図)
   ### 4.1 機能ビュー
   [ユースケース図やブロック図を記載]
   
   ### 4.2 情報ビュー
   [ER図やデータフロー図を記載]
   
   ### 4.3 同時実行ビュー
   [シーケンス図や状態遷移図を記載]
   
   ### 4.4 開発ビュー
   [クラス図やパッケージ図を記載]
   
   ### 4.5 配置ビュー
   [デプロイ図を記載]

## 5. アーキテクチャの根拠
   ### 5.1 設計原則
   - 疎結合・高凝集
   - レイヤー化
   - 関心の分離
   
   ### 5.2 技術選定の理由
   - なぜこの技術スタックを選んだのか
   - 代替案との比較
   
   ### 5.3 制約
   - 技術的制約
   - 組織的制約
   - ビジネス制約

## 6. 整合性とトレーサビリティ
   ### 6.1 ビュー間の整合性
   - 各ビューが矛盾していないか確認
   
   ### 6.2 要求とのトレーサビリティ
   - 各要求がどのビューで実現されているか

## 7. アーキテクチャの評価
   ### 7.1 品質特性の評価
   - 性能
   - セキュリティ
   - 保守性
   - スケーラビリティ
   
   ### 7.2 リスク
   - 既知のリスクと対策

## 付録
   A. 用語集
   B. 参照ドキュメント
   C. 変更履歴
```

### 🎓 ISO 42010準拠のチェックリスト

```markdown
## アーキテクチャ記述品質チェックリスト

### ステークホルダーの確認
- [ ] 全てのステークホルダーを特定したか？
- [ ] 各ステークホルダーの関心事を明確にしたか？
- [ ] 誰がこのドキュメントを読むか想定したか？

### ビューポイントの確認
- [ ] 適切なビューポイントを選択したか？
- [ ] 各ビューポイントの目的は明確か？
- [ ] 使用するモデルの種類を定義したか？

### ビューの確認
- [ ] 各ビューは理解しやすいか？
- [ ] 図の凡例や説明は十分か？
- [ ] 複数のビューに矛盾はないか？

### 根拠の確認
- [ ] なぜこの設計にしたのか説明があるか？
- [ ] 代替案との比較はあるか？
- [ ] 制約条件は明記されているか？

### トレーサビリティの確認
- [ ] 要求とアーキテクチャは紐づいているか？
- [ ] 設計判断の根拠は追跡できるか？
- [ ] 変更の影響範囲が分かるか？
```

---

## 6.3 ISO/IEC/IEEE 29119(テスト)

### 📘 規格の概要

**ISO/IEC/IEEE 29119**は、**ソフトウェアテスト**に関する包括的な国際規格です。テストプロセス、文書化、技法を標準化しています。

**正式名称:**  
`ISO/IEC/IEEE 29119 - Software and systems engineering — Software testing`

**規格の構成:**

```mermaid
graph TD
    A[ISO/IEC/IEEE 29119] --> B[Part 1<br/>概念と定義]
    A --> C[Part 2<br/>テストプロセス]
    A --> D[Part 3<br/>テスト文書]
    A --> E[Part 4<br/>テスト技法]
    A --> F[Part 5<br/>キーワード駆動テスト]
    
    B --> B1[テストの基本概念<br/>用語の定義]
    C --> C1[テストライフサイクル<br/>アクティビティ]
    D --> D1[テスト計画書<br/>テスト仕様書など]
    E --> E1[ブラックボックス<br/>ホワイトボックス<br/>経験ベース]
    F --> F1[自動テストの<br/>標準アプローチ]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#f3e5f5,stroke:#7b1fa2
    style D fill:#c8e6c9,stroke:#2e7d32
    style E fill:#fff9c4,stroke:#f57f17
    style F fill:#b3e5fc,stroke:#0277bd
```

### 🎯 テストプロセス(Part 2)

#### テストライフサイクル

ISO 29119が定義するテストの流れ:

```mermaid
graph TD
    A[テストプロセス] --> B[1. テスト計画]
    B --> C[2. テスト監視・制御]
    C --> D[3. テスト分析]
    D --> E[4. テスト設計]
    E --> F[5. テスト実装]
    F --> G[6. テスト実行]
    G --> H[7. テスト完了]
    
    C -.フィードバック.-> B
    G -.フィードバック.-> C
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#ffcdd2,stroke:#c62828
    style D fill:#f3e5f5,stroke:#7b1fa2
    style E fill:#c8e6c9,stroke:#2e7d32
    style F fill:#fff9c4,stroke:#f57f17
    style G fill:#b3e5fc,stroke:#0277bd
    style H fill:#e0f2f1,stroke:#00695c
```

**各フェーズの詳細:**

| フェーズ | 主な活動 | 成果物 | 担当者 |
|---------|---------|--------|--------|
| **1. テスト計画** | テスト戦略の策定<br/>リソース計画<br/>スケジュール作成 | テスト計画書 | 🎯 テストマネージャー |
| **2. 監視・制御** | 進捗監視<br/>課題管理<br/>計画の調整 | 進捗レポート<br/>課題管理表 | 🎯 テストマネージャー |
| **3. テスト分析** | 要件レビュー<br/>テスト条件の特定<br/>優先順位付け | テスト条件リスト | 🧪 テストアナリスト |
| **4. テスト設計** | テストケース設計<br/>テストデータ設計<br/>環境設計 | テストケース<br/>テストデータ仕様 | 🧪 テストアナリスト |
| **5. テスト実装** | テストスクリプト作成<br/>テスト環境構築<br/>テストデータ準備 | テストスクリプト<br/>テスト環境 | 🛠️ テストエンジニア |
| **6. テスト実行** | テスト実行<br/>不具合報告<br/>再テスト | テスト実行ログ<br/>不具合報告書 | 🧪 テスター |
| **7. テスト完了** | テスト終了判定<br/>成果物の保管<br/>教訓のまとめ | テスト完了報告書 | 🎯 テストマネージャー |

#### テストレベル

ISO 29119が定義するテストレベル:

```mermaid
graph TD
    A[テストレベル] --> B[コンポーネントテスト<br/>単体テスト]
    A --> C[統合テスト]
    A --> D[システムテスト]
    A --> E[受入テスト]
    
    B --> B1[個々のモジュール<br/>関数のテスト]
    C --> C1[モジュール間<br/>連携のテスト]
    D --> D1[システム全体<br/>機能のテスト]
    E --> E1[ユーザー視点<br/>検収テスト]
    
    B -.合格.-> C
    C -.合格.-> D
    D -.合格.-> E
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#c8e6c9,stroke:#2e7d32
    style C fill:#fff9c4,stroke:#f57f17
    style D fill:#f3e5f5,stroke:#7b1fa2
    style E fill:#ffcdd2,stroke:#c62828
```

### 📋 テスト文書(Part 3)

#### 主要なテスト文書

ISO 29119が定義する標準的なテスト文書:

```mermaid
graph TD
    A[テスト文書] --> B[組織レベル]
    A --> C[テストプロジェクトレベル]
    A --> D[動的テストレベル]
    
    B --> B1[組織テスト方針<br/>組織テスト戦略]
    C --> C1[テスト計画書<br/>テスト完了報告書]
    D --> D1[テスト設計仕様書<br/>テストケース仕様書<br/>テスト実行記録]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#f3e5f5,stroke:#7b1fa2
    style D fill:#c8e6c9,stroke:#2e7d32
```

**1. テスト計画書(Test Plan)テンプレート:**

```markdown
# テスト計画書テンプレート(ISO 29119準拠)

## 1. 識別情報
   - ドキュメントID
   - バージョン
   - 作成日・承認日
   - 作成者・承認者

## 2. はじめに
   ### 2.1 目的
   ### 2.2 対象範囲
   ### 2.3 対象読者
   ### 2.4 参照文書

## 3. テストアイテム
   ### 3.1 テスト対象
   - システム名
   - バージョン
   - モジュール一覧
   
   ### 3.2 テスト対象外
   - 除外する機能
   - 除外の理由

## 4. テスト戦略
   ### 4.1 テストレベル
   | レベル | 目的 | 担当 | 期間 |
   |--------|------|------|------|
   | 単体テスト | モジュール単位 | 開発者 | 2週間 |
   | 統合テスト | 連携確認 | テスター | 1週間 |
   | システムテスト | 全体機能 | テスター | 2週間 |
   | 受入テスト | 検収 | ユーザー | 1週間 |
   
   ### 4.2 テスト技法
   - 同値分割法
   - 境界値分析
   - 状態遷移テスト
   - ペアワイズ法
   
   ### 4.3 終了基準
   - 全テストケースの実行完了
   - 致命的バグ0件
   - 重大バグ2件以下
   - テストカバレッジ80%以上

## 5. テスト環境
   ### 5.1 ハードウェア
   ### 5.2 ソフトウェア
   ### 5.3 ネットワーク
   ### 5.4 テストデータ

## 6. スケジュール
   ### 6.1 全体スケジュール
   ### 6.2 マイルストーン
   ### 6.3 依存関係

## 7. リソース
   ### 7.1 人員
   | 役割 | 人数 | 担当者 |
   |------|------|--------|
   | テストマネージャー | 1名 | 〇〇 |
   | テストアナリスト | 2名 | △△、□□ |
   | テスター | 4名 | ×××× |
   
   ### 7.2 ツール
   - テスト管理: Jira
   - 自動テスト: Selenium
   - 性能テスト: JMeter

## 8. リスク管理
   ### 8.1 識別されたリスク
   | リスク | 影響度 | 発生確率 | 対策 |
   |--------|--------|---------|------|
   | 環境構築遅延 | 高 | 中 | 事前準備 |
   | 要員不足 | 中 | 低 | 外部委託検討 |
   
   ### 8.2 リスク対応計画

## 9. コミュニケーション
   ### 9.1 報告体制
   ### 9.2 会議体
   ### 9.3 エスカレーション

## 10. 成果物
   - テスト設計仕様書
   - テストケース仕様書
   - テスト実行記録
   - 不具合報告書
   - テスト完了報告書

## 11. 承認
   | 役割 | 氏名 | 承認日 | 署名 |
   |------|------|--------|------|
   | テストマネージャー | | | |
   | プロジェクトマネージャー | | | |
   | 品質保証担当 | | | |
```

**2. テストケース仕様書テンプレート:**

```markdown
# テストケース仕様書テンプレート(ISO 29119準拠)

## テストケース情報

### TC-001: ログイン機能_正常系

**テストケースID:** TC-001  
**テスト設計ID:** TD-001  
**要件ID:** FR-001  
**優先度:** High  
**作成者:** 田中太郎  
**作成日:** 2025-01-15  
**レビュー者:** 山田花子  
**レビュー日:** 2025-01-16

---

### テスト条件
有効なユーザーIDとパスワードでログインできること

### 前提条件
- [ ] テストユーザーがデータベースに登録済み
- [ ] ログイン画面が表示されている
- [ ] ブラウザ: Chrome 最新版

### テストデータ
| 項目 | 値 |
|------|-----|
| ユーザーID | testuser01 |
| パスワード | Password123! |

### テスト手順
| ステップ | 操作 | 期待結果 | 実際の結果 | 合否 |
|---------|------|---------|----------|------|
| 1 | ユーザーID入力欄に「testuser01」を入力 | 入力欄にtextuser01が表示される | | |
| 2 | パスワード入力欄に「Password123!」を入力 | 入力欄に●●●●●●●●●●●●が表示される | | |
| 3 | 「ログイン」ボタンをクリック | ホーム画面に遷移する | | |
| 4 | 画面右上のユーザー名を確認 | 「testuser01」が表示される | | |

### 事後条件
- ログインセッションが確立されている
- セッションタイムアウトは30分

### 備考
- セキュリティ: パスワードはマスク表示される
- パフォーマンス: ログイン処理は2秒以内
- ログ: ログインイベントがログに記録される

---

## テスト実行記録

| 実行日 | 実行者 | ビルドNo. | 結果 | 備考 |
|--------|--------|----------|------|------|
| 2025-01-20 | 田中太郎 | v1.0.1 | 合格 | - |
| 2025-01-25 | 佐藤次郎 | v1.0.2 | 合格 | - |
| 2025-02-01 | 鈴木三郎 | v1.1.0 | 不合格 | BUG-123登録 |
| 2025-02-03 | 鈴木三郎 | v1.1.1 | 合格 | BUG-123修正確認 |
```

### 🔬 テスト技法(Part 4)

ISO 29119 Part 4で定義される主なテスト技法:

#### 1. ブラックボックステスト技法

```mermaid
graph TD
    A[ブラックボックス<br/>テスト技法] --> B[同値分割法]
    A --> C[境界値分析]
    A --> D[デシジョンテーブル]
    A --> E[状態遷移テスト]
    A --> F[ユースケーステスト]
    A --> G[分類木法]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#f3e5f5,stroke:#7b1fa2
    style D fill:#c8e6c9,stroke:#2e7d32
    style E fill:#fff9c4,stroke:#f57f17
    style F fill:#b3e5fc,stroke:#0277bd
    style G fill:#e0f2f1,stroke:#00695c
```

#### 2. ホワイトボックステスト技法

```mermaid
graph TD
    A[ホワイトボックス<br/>テスト技法] --> B[ステートメント<br/>カバレッジ]
    A --> C[ブランチ<br/>カバレッジ]
    A --> D[条件カバレッジ]
    A --> E[パスカバレッジ]
    
    B --> B1[全ての文を<br/>実行]
    C --> C1[全ての分岐を<br/>実行]
    D --> D1[全ての条件を<br/>真/偽で実行]
    E --> E1[全ての経路を<br/>実行]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#c8e6c9,stroke:#2e7d32
    style C fill:#fff9c4,stroke:#f57f17
    style D fill:#f3e5f5,stroke:#7b1fa2
    style E fill:#ffcdd2,stroke:#c62828
```

#### 3. 経験ベーステスト技法

```mermaid
graph TD
    A[経験ベース<br/>テスト技法] --> B[エラー推測]
    A --> C[探索的テスト]
    A --> D[チェックリストベース<br/>テスト]
    
    B --> B1[過去の経験から<br/>バグが出そうな箇所]
    C --> C1[テスト実行しながら<br/>学習・設計]
    D --> D1[チェックリストに基づき<br/>確認]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#f3e5f5,stroke:#7b1fa2
    style D fill:#c8e6c9,stroke:#2e7d32
```

### 📊 テストカバレッジの計算

**カバレッジの種類と計算式:**

```markdown
## 主要カバレッジ指標

### 1. ステートメントカバレッジ(文カバレッジ)
計算式: 実行された文の数 / 全体の文の数 × 100

例:
- 全体の文の数: 100行
- 実行された文: 85行
- カバレッジ: 85%

### 2. ブランチカバレッジ(分岐カバレッジ)
計算式: 実行された分岐の数 / 全体の分岐の数 × 100

例:
- 全体の分岐: 20個
- 実行された分岐: 18個
- カバレッジ: 90%

### 3. 条件カバレッジ
計算式: 真偽両方テストした条件の数 / 全体の条件の数 × 100

例:
- 全体の条件: 15個
- 真偽両方テスト: 12個
- カバレッジ: 80%

### 4. 経路カバレッジ
計算式: 実行された経路の数 / 全ての可能な経路の数 × 100

例:
- 全ての可能な経路: 1000通り
- 実行された経路: 100通り
- カバレッジ: 10%

※ 経路カバレッジは組み合わせ爆発するため、
  実務では100%を目指さない
```

**推奨カバレッジ目標:**

| テストレベル | ステートメント | ブランチ | 備考 |
|------------|--------------|---------|------|
| 単体テスト | 80%以上 | 70%以上 | 重要モジュールは90%以上 |
| 統合テスト | 60%以上 | 50%以上 | インターフェース重視 |
| システムテスト | 40%以上 | 30%以上 | 機能網羅重視 |

### 🎓 ISO 29119準拠のチェックリスト

```markdown
## テストプロセスチェックリスト

### テスト計画
- [ ] テスト計画書は作成されているか?
- [ ] テスト戦略は明確か?
- [ ] リソース計画は適切か?
- [ ] リスクは識別されているか?
- [ ] 終了基準は定義されているか?

### テスト分析
- [ ] 要件は全てレビューされたか?
- [ ] テスト条件は特定されたか?
- [ ] 優先順位は付けられているか?
- [ ] テスト可能性は確認されたか?

### テスト設計
- [ ] 適切なテスト技法を選択したか?
- [ ] テストケースは十分か?
- [ ] テストデータは定義されたか?
- [ ] テスト環境は定義されたか?
- [ ] レビューは完了したか?

### テスト実装
- [ ] テスト環境は構築されたか?
- [ ] テストデータは準備されたか?
- [ ] テストスクリプトは作成されたか?
- [ ] 実行順序は決まっているか?

### テスト実行
- [ ] テストは計画通り実行されているか?
- [ ] 不具合は適切に報告されているか?
- [ ] 再テストは実施されているか?
- [ ] 進捗は記録されているか?

### テスト完了
- [ ] 終了基準は満たされているか?
- [ ] 成果物は全て揃っているか?
- [ ] 教訓はまとめられているか?
- [ ] 承認は得られているか?
```

---

## 6.4 その他の関連規格

### 📚 システム開発に関連するISO規格

システム開発には、これまで紹介した3つ以外にも多くの関連規格があります:

```mermaid
graph TD
    A[関連ISO規格] --> B[品質管理]
    A --> C[プロジェクト管理]
    A --> D[セキュリティ]
    A --> E[保守・運用]
    
    B --> B1[ISO 25010<br/>品質モデル]
    B --> B2[ISO 9001<br/>品質マネジメント]
    
    C --> C1[ISO 21500<br/>プロジェクト管理]
    C --> C2[ISO/IEC 12207<br/>ライフサイクル]
    
    D --> D1[ISO 27001<br/>情報セキュリティ]
    D --> D2[ISO 27002<br/>セキュリティ管理策]
    
    E --> E1[ISO 20000<br/>ITサービス管理]
    E --> E2[ISO 25000<br/>SQuaRE]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#f3e5f5,stroke:#7b1fa2
    style D fill:#ffcdd2,stroke:#c62828
    style E fill:#c8e6c9,stroke:#2e7d32
```

### 🎯 主要な関連規格の詳細

#### 1. ISO/IEC 25010:品質モデル

**品質特性の定義:**

```mermaid
graph TD
    A[ISO/IEC 25010<br/>品質特性] --> B[機能適合性]
    A --> C[性能効率性]
    A --> D[互換性]
    A --> E[使用性]
    A --> F[信頼性]
    A --> G[セキュリティ]
    A --> H[保守性]
    A --> I[移植性]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#f3e5f5,stroke:#7b1fa2
    style D fill:#c8e6c9,stroke:#2e7d32
    style E fill:#fff9c4,stroke:#f57f17
    style F fill:#b3e5fc,stroke:#0277bd
    style G fill:#ffcdd2,stroke:#c62828
    style H fill:#e0f2f1,stroke:#00695c
    style I fill:#f8bbd0,stroke:#c2185b
```

**8つの品質特性:**

| 品質特性 | 説明 | 評価例 | 重要度 |
|---------|------|--------|--------|
| **機能適合性**<br/>(Functional Suitability) | 要求された機能を<br/>正しく提供する | 全機能が仕様通り動作するか | ⭐⭐⭐ |
| **性能効率性**<br/>(Performance Efficiency) | 資源を効率的に使用し<br/>適切な性能を発揮する | レスポンスタイム<br/>メモリ使用量 | ⭐⭐⭐ |
| **互換性**<br/>(Compatibility) | 他のシステムと<br/>共存・連携できる | 既存システムとの連携<br/>データ形式の互換性 | ⭐⭐ |
| **使用性**<br/>(Usability) | ユーザーが効率的に<br/>使いやすい | UIの分かりやすさ<br/>学習のしやすさ | ⭐⭐⭐ |
| **信頼性**<br/>(Reliability) | 安定して動作し<br/>障害に強い | 稼働率<br/>MTBF(平均故障間隔) | ⭐⭐⭐ |
| **セキュリティ**<br/>(Security) | 不正アクセスや<br/>データ漏洩を防ぐ | 認証・認可<br/>暗号化 | ⭐⭐⭐ |
| **保守性**<br/>(Maintainability) | 修正・改善が<br/>容易にできる | コードの読みやすさ<br/>モジュール性 | ⭐⭐ |
| **移植性**<br/>(Portability) | 異なる環境に<br/>移行しやすい | OSの違いへの対応<br/>クラウド移行の容易さ | ⭐ |

#### 2. ISO/IEC 12207:システム・ソフトウェアライフサイクルプロセス

**ライフサイクルプロセスの全体像:**

```mermaid
graph TD
    A[ISO/IEC 12207<br/>プロセス分類] --> B[主ライフサイクルプロセス]
    A --> C[組織のライフサイクルプロセス]
    A --> D[支援ライフサイクルプロセス]
    
    B --> B1[取得<br/>供給<br/>開発<br/>運用<br/>保守]
    
    C --> C1[管理<br/>インフラ<br/>改善<br/>訓練]
    
    D --> D1[文書化<br/>構成管理<br/>品質保証<br/>検証<br/>妥当性確認<br/>レビュー<br/>監査<br/>問題解決]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#f3e5f5,stroke:#7b1fa2
    style D fill:#c8e6c9,stroke:#2e7d32
```

**主な活動:**

| プロセス分類 | プロセス | 目的 |
|------------|---------|------|
| **主ライフサイクル** | 取得 | システムを入手する |
| | 供給 | システムを提供する |
| | 開発 | システムを作る |
| | 運用 | システムを使う |
| | 保守 | システムを維持する |
| **組織** | 管理 | プロジェクト管理 |
| | インフラ | 環境整備 |
| | 改善 | プロセス改善 |
| | 訓練 | 教育訓練 |
| **支援** | 文書化 | ドキュメント作成 |
| | 構成管理 | バージョン管理 |
| | 品質保証 | 品質確保 |
| | 検証 | 正しく作られたか |
| | 妥当性確認 | 正しいものを作ったか |

#### 3. ISO/IEC 27001:情報セキュリティマネジメントシステム

**セキュリティ管理のフレームワーク:**

```mermaid
graph TD
    A[ISO 27001<br/>ISMS] --> B[リスクアセスメント]
    A --> C[リスク対応]
    A --> D[PDCA サイクル]
    
    B --> B1[資産の特定<br/>脅威の識別<br/>脆弱性の評価]
    
    C --> C1[リスクの受容<br/>リスクの回避<br/>リスクの移転<br/>リスクの低減]
    
    D --> D1[Plan: 計画<br/>Do: 実施<br/>Check: 監視<br/>Act: 改善]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#ffcdd2,stroke:#c62828
    style C fill:#fff9c4,stroke:#f57f17
    style D fill:#c8e6c9,stroke:#2e7d32
```

**ISO 27002の管理策(一部抜粋):**

| 分類 | 管理策 | 具体例 |
|------|--------|--------|
| **組織的管理策** | 情報セキュリティ方針 | セキュリティポリシーの策定 |
| | 役割と責任 | セキュリティ責任者の任命 |
| **人的管理策** | 雇用前 | バックグラウンドチェック |
| | 教育訓練 | セキュリティ研修の実施 |
| **物理的管理策** | 物理的セキュリティ境界 | 入退室管理 |
| | 装置のセキュリティ | デバイスの盗難防止 |
| **技術的管理策** | アクセス制御 | 認証・認可の実装 |
| | 暗号化 | データの暗号化 |
| | ログ取得 | 監査ログの記録 |

#### 4. ISO 20000:ITサービスマネジメント

**ITILとの関係:**

```mermaid
graph LR
    A[ITIL<br/>ベストプラクティス集] -.実装.-> B[ISO 20000<br/>認証規格]
    
    B --> C[サービス提供プロセス]
    B --> D[関係プロセス]
    B --> E[解決プロセス]
    B --> F[管理プロセス]
    
    C --> C1[サービスレベル管理<br/>サービスカタログ管理]
    D --> D1[ビジネス関係管理<br/>供給者管理]
    E --> E1[インシデント管理<br/>問題管理]
    F --> F1[変更管理<br/>リリース管理<br/>構成管理]
    
    style A fill:#e1f5ff,stroke:#0277bd
    style B fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style C fill:#fff3e0,stroke:#ef6c00
    style D fill:#f3e5f5,stroke:#7b1fa2
    style E fill:#ffcdd2,stroke:#c62828
    style F fill:#c8e6c9,stroke:#2e7d32
```

### 📖 規格の学習方法と活用

#### 学習の進め方

```mermaid
graph TD
    A[ISO規格の学習] --> B[Step 1<br/>概要を理解]
    B --> C[Step 2<br/>自分の業務に関連する部分を深掘り]
    C --> D[Step 3<br/>実際のプロジェクトで適用]
    D --> E[Step 4<br/>継続的な改善]
    
    B --> B1[公式サイトの概要<br/>解説書を読む]
    C --> C1[該当章を熟読<br/>テンプレートを入手]
    D --> D1[部分的に導入<br/>チームで共有]
    E --> E1[フィードバック<br/>改善を繰り返す]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#f3e5f5,stroke:#7b1fa2
    style D fill:#c8e6c9,stroke:#2e7d32
    style E fill:#fff9c4,stroke:#f57f17
```

#### 規格の入手方法

```markdown
## ISO規格の入手方法

### 公式購入
- **日本規格協会(JSA)**: https://www.jsa.or.jp/
  - 日本語版あり
  - 有料(規格により異なる)
  - 正式な規格文書

### 概要の確認
- **ISOの公式サイト**: https://www.iso.org/
  - 無料で概要を確認可能
  - 英語版

### 解説書の活用
- 市販の解説書を購入
  - 「図解 ISO/IEC 29119」などの書籍
  - 実践的な内容が含まれる
  - 比較的安価

### オンライン学習
- Udemyなどのオンライン講座
- YouTube の解説動画
- 技術ブログ・Qiita記事
```

### 🏆 認証取得のメリット

**ISO認証を取得すると:**

| メリット | 説明 | 対象 |
|---------|------|------|
| **顧客信頼の獲得** | 品質が保証されている証明 | 🏢 企業全体 |
| **競争力の向上** | 入札条件になることも | 📊 営業・マーケティング |
| **プロセスの標準化** | 属人化を防げる | 👥 開発チーム |
| **継続的改善** | PDCAサイクルが回る | 🔄 組織全体 |
| **リスク低減** | トラブルの予防 | 🛡️ 品質保証 |
| **国際展開** | 海外でも通用する | 🌍 グローバル展開 |

**主な認証:**

```mermaid
graph TD
    A[主なISO認証] --> B[ISO 9001<br/>品質マネジメント]
    A --> C[ISO 27001<br/>情報セキュリティ]
    A --> D[ISO 20000<br/>ITサービス]
    
    B --> B1[最も一般的<br/>品質保証の基本]
    C --> C1[セキュリティ重視の<br/>企業に必須]
    D --> D1[IT企業に有利<br/>運用品質の証明]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#c8e6c9,stroke:#2e7d32
    style C fill:#ffcdd2,stroke:#c62828
    style D fill:#fff9c4,stroke:#f57f17
```

### 🎓 実務への適用チェックリスト

```markdown
## ISO規格活用チェックリスト

### 導入前の確認
- [ ] 自社の課題は何か明確にする
- [ ] どの規格が最も関連するか特定する
- [ ] 経営層の理解と支援を得る
- [ ] 必要なリソース(人・時間・予算)を確保する

### 段階的な導入
- [ ] まずは部分的に導入する(スモールスタート)
- [ ] パイロットプロジェクトで試す
- [ ] フィードバックを集める
- [ ] 改善してから全社展開

### 形式にとらわれない
- [ ] 完璧を目指さない(70-80%で十分)
- [ ] 自社の実情に合わせてカスタマイズ
- [ ] 「規格のための規格」にならない
- [ ] 実用性を重視する

### 継続的な改善
- [ ] 定期的にレビューする
- [ ] チームからのフィードバックを収集
- [ ] 無駄なプロセスは削減する
- [ ] より良い方法を常に探す

### 教育・訓練
- [ ] チームメンバーに規格の目的を説明
- [ ] 実践的なトレーニングを提供
- [ ] テンプレートやツールを整備
- [ ] 疑問に答えられる体制を作る
```

---

## 第6章のまとめ

本章では、システム開発に関連する**国際標準規格(ISO)**について解説しました:

### 6.1 ISO/IEC/IEEE 29148(要求工学)

- **要求の分類**: ステークホルダー要求、システム要求、ソフトウェア要求
- **良い要求の8つの特性**: 明確性、完全性、一貫性、検証可能性、追跡可能性、優先順位付け、実現可能性、必要性
- **SRSの標準構成**: 体系的な要求仕様書の作り方

### 6.2 ISO/IEC/IEEE 42010(アーキテクチャ記述)

- **ビューポイントとビュー**: 異なる視点からシステムを記述
- **5つの主要ビュー**: 機能、情報、同時実行、開発、配置
- **ステークホルダーの関心事**: 誰が何に関心があるか明確化
- **C4モデルとの統合**: 実践的なアーキテクチャ記述

### 6.3 ISO/IEC/IEEE 29119(テスト)

- **7つのテストプロセス**: 計画、監視・制御、分析、設計、実装、実行、完了
- **4つのテストレベル**: 単体、統合、システム、受入
- **テスト技法**: ブラックボックス、ホワイトボックス、経験ベース
- **標準テスト文書**: テスト計画書、テストケース仕様書など

### 6.4 その他の関連規格

- **ISO/IEC 25010**: ソフトウェア品質モデル(8つの品質特性)
- **ISO/IEC 12207**: ライフサイクルプロセス
- **ISO/IEC 27001**: 情報セキュリティマネジメント
- **ISO 20000**: ITサービスマネジメント

**重要なポイント:**

- 規格は「守るべきルール」ではなく「参考にすべきベストプラクティス」
- 完璧を目指さず、自社に合った形で段階的に導入
- 形式にとらわれず、実用性を重視
- 継続的な改善が重要

次の第7章では、**完全用語集(あいうえお順・アルファベット順)**を提供します。分からない用語が出てきたら、すぐに調べられる辞書として活用してください!

---

# 第7章：完全用語集（あいうえお順・アルファベット順）

> **システム開発で出てくる全ての用語を完全網羅！**  
> 初心者向けの基礎用語から実務で使う専門用語まで詳しく解説

**用語集の使い方:**

- 📖 辞書として必要な時に参照してください
- 🔍 Ctrl+F (Cmd+F) で検索が便利です
- 💡 関連用語も一緒に覚えると理解が深まります
- 🌟 重要度を★マークで示しています

---

## 7.1 日本語用語（あいうえお順）

### 【あ行】

#### アーキテクチャ（Architecture / アーキテクチャー）

**読み方:** アーキテクチャ  
**重要度:** ⭐⭐⭐

**意味:**
システムの全体的な構造や設計のこと。「建築物の設計」という意味から来ており、ソフトウェアでは「システムの骨組み」を指します。

**具体例:**

- Webアプリケーションの3層アーキテクチャ（プレゼンテーション層、ビジネスロジック層、データ層）
- マイクロサービスアーキテクチャ
- クラウドネイティブアーキテクチャ

**関連用語:** アーキテクト、システム設計、設計パターン

---

#### アジャイル開発（Agile Development / アジャイルかいはつ）

**読み方:** アジャイルかいはつ  
**重要度:** ⭐⭐⭐

**意味:**
短い期間（通常1〜4週間）で、計画→開発→テスト→リリースを繰り返す開発手法。変化に柔軟に対応できるのが特徴。

**具体例:**

- スクラム: 2週間のスプリントで開発
- カンバン: タスクボードで作業を見える化
- XP(エクストリームプログラミング): ペアプログラミングを重視

**対義語:** ウォーターフォール開発

**関連用語:** スプリント、スクラム、イテレーション、デイリースタンドアップ

---

#### 受入テスト（Acceptance Test / うけいれテスト）

**読み方:** うけいれテスト  
**重要度:** ⭐⭐⭐

**意味:**
システムが要件を満たしているか、実際の利用者（お客様）の視点で確認するテスト。最終的な「合格判定」を行う重要なテスト。

**具体例:**

- ユーザー受入テスト(UAT): お客様が実際に使ってみて確認
- 運用受入テスト(OAT): 運用チームが運用可能か確認
- アルファテスト、ベータテスト: リリース前の実ユーザーによるテスト

**英語:** UAT (User Acceptance Test)

**関連用語:** システムテスト、ベータ版、本番環境

---

#### 運用（Operation / うんよう）

**読み方:** うんよう  
**重要度:** ⭐⭐⭐

**意味:**
システムをリリースした後、実際にユーザーが使っている状態で、正常に動作するよう管理・監視すること。

**具体的な作業:**

- システムの監視（エラーが出ていないか）
- バックアップの取得
- ログの確認
- 定期的なメンテナンス
- 問い合わせ対応

**関連用語:** 保守、監視、運用保守、DevOps、SRE

---

#### エラーハンドリング（Error Handling / エラーハンドリング）

**読み方:** エラーハンドリング  
**重要度:** ⭐⭐

**意味:**
プログラムでエラー(異常)が発生した時に、適切に処理する仕組み。エラーを無視せず、ユーザーに分かりやすいメッセージを表示したり、ログに記録したりすること。

**具体例:**

```python
try:
    # 処理を実行
    result = 10 / 0
except ZeroDivisionError:
    # エラーが起きた時の処理
    print("0で割ることはできません")
```

**関連用語:** 例外処理、トライキャッチ、例外クラス

---

### 【か行】

#### 開発環境（Development Environment / かいはつかんきょう）

**読み方:** かいはつかんきょう  
**重要度:** ⭐⭐

**意味:**
プログラマーがコードを書いたり、テストしたりする環境。本番環境とは別に用意され、自由に実験できる。

**環境の種類:**

```mermaid
graph LR
    A[開発環境<br/>Development] --> B[ステージング環境<br/>Staging]
    B --> C[本番環境<br/>Production]
    
    A --> A1[開発者が自由に試す]
    B --> B1[本番と同じ環境でテスト]
    C --> C1[実際のユーザーが使う]
    
    style A fill:#c8e6c9,stroke:#2e7d32
    style B fill:#fff9c4,stroke:#f57f17
    style C fill:#ffcdd2,stroke:#c62828
```

**関連用語:** テスト環境、ステージング環境、本番環境、ローカル環境

---

#### 機能要件（Functional Requirements / きのうようけん）

**読み方:** きのうようけん  
**重要度:** ⭐⭐⭐

**意味:**
システムが「何をするか」を定義した要件。具体的な機能のこと。

**具体例（ECサイトの場合）:**

- 商品を検索できる
- カートに商品を追加できる
- クレジットカードで決済できる
- 注文履歴を確認できる
- レビューを投稿できる

**対義語:** 非機能要件

**関連用語:** ユースケース、ユーザーストーリー、機能仕様

---

#### 基本設計（Basic Design / きほんせっけい）

**読み方:** きほんせっけい  
**重要度:** ⭐⭐⭐

**意味:**
「どう作るか」の大枠を決める設計。外側から見た設計で、ユーザーから見える部分（画面、帳票など）と、システムの全体構造を決める。

**成果物:**

- 画面設計書
- 帳票設計書
- 外部インターフェース設計書
- システム構成図
- データベース設計書（概要レベル）

**別名:** 外部設計

**関連用語:** 詳細設計、アーキテクチャ設計、システム設計

---

#### クライアント（Client / クライアント）

**読み方:** クライアント  
**重要度:** ⭐⭐

**意味:**

1. **技術的な意味**: サービスを利用する側のコンピューター（例: Webブラウザ、スマホアプリ）
2. **ビジネス的な意味**: お客様、発注者

**技術的な例:**

```mermaid
graph LR
    A[クライアント<br/>スマホアプリ] -->|リクエスト| B[サーバー<br/>APIサーバー]
    B -->|レスポンス| A
    
    style A fill:#e1f5fe,stroke:#0277bd
    style B fill:#fff3e0,stroke:#ef6c00
```

**対義語:** サーバー

**関連用語:** クライアントサイド、フロントエンド、クライアントサーバーシステム

---

#### クラウド（Cloud / クラウド）

**読み方:** クラウド  
**重要度:** ⭐⭐⭐

**意味:**
インターネット経由で利用できるコンピューターリソース（サーバー、ストレージ、データベースなど）のこと。自分でサーバーを買わなくても、必要な分だけ借りて使える。

**主要なクラウドサービス:**

- **AWS (Amazon Web Services / アマゾン ウェブ サービシーズ)**: Amazonが提供する世界最大のクラウド
- **Azure (Microsoft Azure / マイクロソフト アジュール)**: Microsoftが提供
- **GCP (Google Cloud Platform / グーグル クラウド プラットフォーム)**: Googleが提供

**サービスの種類:**

- **IaaS (イアース)**: インフラだけ借りる（EC2など）
- **PaaS (パース)**: 開発環境ごと借りる（Herokuなど）
- **SaaS (サース)**: アプリケーションを使う（Gmailなど）

**関連用語:** オンプレミス、クラウドネイティブ、サーバーレス

---

#### コードレビュー（Code Review / コードレビュー）

**読み方:** コードレビュー  
**重要度:** ⭐⭐⭐

**意味:**
書いたコードを他の開発者にチェックしてもらうこと。バグの早期発見、品質向上、知識共有が目的。

**確認するポイント:**

- ✅ バグがないか
- ✅ 読みやすいコードか
- ✅ セキュリティ問題はないか
- ✅ パフォーマンスに問題はないか
- ✅ コーディング規約に従っているか
- ✅ テストは十分か

**ツール例:** GitHub Pull Request、GitLab Merge Request

**関連用語:** ピアレビュー、プルリクエスト、ペアプログラミング

---

### 【さ行】

#### サーバー（Server / サーバー）

**読み方:** サーバー  
**重要度:** ⭐⭐⭐

**意味:**
サービスや情報を提供するコンピューター。クライアントからのリクエストを受け取り、処理して結果を返す。

**サーバーの種類:**

| 種類 | 役割 | 具体例 |
|------|------|--------|
| **Webサーバー** | Webページを配信 | Apache, Nginx |
| **アプリケーションサーバー** | ビジネスロジックを実行 | Tomcat, Node.js |
| **データベースサーバー** | データを保存・管理 | MySQL, PostgreSQL |
| **ファイルサーバー** | ファイルを共有 | NAS, Samba |
| **メールサーバー** | メールを送受信 | Postfix, Exchange |

**対義語:** クライアント

**関連用語:** サーバーサイド、バックエンド、サーバーレス

---

#### 仕様書（Specification / しようしょ）

**読み方:** しようしょ  
**重要度:** ⭐⭐⭐

**意味:**
システムやソフトウェアが「何をするか」「どう動くか」を詳しく記述した文書。開発の設計図となる重要なドキュメント。

**主な仕様書:**

- 要件仕様書（SRS）
- 機能仕様書
- 設計仕様書
- インターフェース仕様書
- テスト仕様書

**関連用語:** ドキュメント、要件定義書、設計書

---

#### ステークホルダー（Stakeholder / ステークホルダー）

**読み方:** ステークホルダー  
**重要度:** ⭐⭐⭐

**意味:**
プロジェクトに関わる全ての関係者。利害関係者。

**ステークホルダーの例:**

```mermaid
graph TD
    A[ステークホルダー] --> B[内部関係者]
    A --> C[外部関係者]
    
    B --> B1[経営層<br/>プロジェクトマネージャー<br/>開発者<br/>デザイナー<br/>QA<br/>運用チーム]
    
    C --> C1[顧客/ユーザー<br/>発注者<br/>エンドユーザー<br/>保守ベンダー<br/>監督機関]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#c8e6c9,stroke:#2e7d32
    style C fill:#fff3e0,stroke:#ef6c00
```

**関連用語:** 関係者、利害関係者、プロジェクトメンバー

---

#### スプリント（Sprint / スプリント）

**読み方:** スプリント  
**重要度:** ⭐⭐⭐

**意味:**
アジャイル開発における開発の単位期間。通常1〜4週間で、その期間内に計画・開発・テスト・リリースを行う。

**スプリントの流れ:**

```mermaid
graph LR
    A[スプリント計画] --> B[デイリースタンドアップ]
    B --> C[開発作業]
    C --> B
    C --> D[スプリントレビュー]
    D --> E[スプリント振り返り]
    E --> F[次のスプリント]
    
    style A fill:#c8e6c9,stroke:#2e7d32
    style B fill:#e1f5fe,stroke:#0277bd
    style C fill:#fff3e0,stroke:#ef6c00
    style D fill:#f3e5f5,stroke:#7b1fa2
    style E fill:#fff9c4,stroke:#f57f17
    style F fill:#ffcdd2,stroke:#c62828
```

**関連用語:** スクラム、イテレーション、アジャイル開発

---

#### セキュリティ（Security / セキュリティ）

**読み方:** セキュリティ  
**重要度:** ⭐⭐⭐

**意味:**
システムを不正アクセスや攻撃から守ること。情報漏洩やデータ改ざんを防ぐための仕組み。

**主なセキュリティ対策:**

| 対策 | 説明 | 具体例 |
|------|------|--------|
| **認証** | 本人確認 | パスワード、二段階認証 |
| **認可** | 権限管理 | 管理者のみ編集可能 |
| **暗号化** | データを読めなくする | SSL/TLS、AES暗号化 |
| **ファイアウォール** | 不正なアクセスを遮断 | WAF、ネットワークFW |
| **脆弱性対策** | セキュリティホールを塞ぐ | 定期的なアップデート |

**主な脅威:**

- SQLインジェクション
- クロスサイトスクリプティング(XSS)
- DDoS攻撃
- ランサムウェア

**関連用語:** 脆弱性、セキュリティホール、暗号化、認証

---

#### ソースコード（Source Code / ソースコード）

**読み方:** ソースコード  
**重要度:** ⭐⭐⭐

**意味:**
プログラマーが書いたプログラムの文字列。人間が読める形式で書かれている。

**具体例:**

```python
# これがソースコード
def hello():
    print("Hello, World!")

hello()  # 関数を呼び出す
```

**関連用語:** コード、プログラム、コンパイル、バイナリ

---

### 【た行】

#### データベース（Database / データベース）

**読み方:** データベース  
**重要度:** ⭐⭐⭐

**意味:**
データを整理して保存し、必要な時に取り出せるようにする仕組み。

**データベースの種類:**

```mermaid
graph TD
    A[データベース] --> B[RDB<br/>リレーショナルデータベース]
    A --> C[NoSQL<br/>非リレーショナル]
    
    B --> B1[MySQL<br/>PostgreSQL<br/>Oracle<br/>SQL Server]
    
    C --> C1[MongoDB<br/>Cassandra<br/>Redis<br/>DynamoDB]
    
    B --> B2[表形式でデータを管理<br/>SQLで操作]
    C --> C2[柔軟な形式でデータを管理<br/>大量データに強い]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#c8e6c9,stroke:#2e7d32
    style C fill:#fff3e0,stroke:#ef6c00
```

**関連用語:** DB、DBMS、SQL、テーブル、レコード

---

#### テスト（Test / テスト）

**読み方:** テスト  
**重要度:** ⭐⭐⭐

**意味:**
システムやプログラムが正しく動作するか確認すること。バグを見つけて修正するために行う。

**テストの種類（レベル別）:**

| レベル | 目的 | 実施者 | タイミング |
|--------|------|--------|-----------|
| **単体テスト**<br/>(Unit Test) | 個々の関数やメソッドが<br/>正しく動くか | 開発者 | 実装直後 |
| **統合テスト**<br/>(Integration Test) | 複数の機能を組み合わせた時に<br/>正しく動くか | 開発者/QA | 単体テスト後 |
| **システムテスト**<br/>(System Test) | システム全体が<br/>要件を満たすか | QAチーム | 統合テスト後 |
| **受入テスト**<br/>(Acceptance Test) | お客様の要求を<br/>満たしているか | お客様/ユーザー | リリース前 |

**テストの種類（手法別）:**

- **ブラックボックステスト**: 内部構造を見ずに、入力と出力だけ確認
- **ホワイトボックステスト**: プログラムの中身を見てテスト
- **回帰テスト**: 修正による影響がないか確認
- **パフォーマンステスト**: 性能を確認
- **セキュリティテスト**: セキュリティの脆弱性を確認

**関連用語:** QA、バグ、デバッグ、テストケース

---

#### デバッグ（Debug / デバッグ）

**読み方:** デバッグ  
**重要度:** ⭐⭐

**意味:**
プログラムのバグ（不具合）を見つけて修正すること。

**デバッグの方法:**

- ログを出力して確認
- デバッガーツールで1行ずつ実行
- テストを書いて確認
- エラーメッセージを読む

**語源:** バグ(Bug)は虫の意味。コンピューターの黎明期に、実際に虫がコンピューターの中に入り込んで故障したことが由来。

**関連用語:** バグ、デバッガー、トラブルシューティング

---

#### デプロイ（Deploy / デプロイ）

**読み方:** デプロイ  
**重要度:** ⭐⭐⭐

**意味:**
開発したシステムを本番環境に配置して、ユーザーが使えるようにすること。

**デプロイの流れ:**

```mermaid
graph LR
    A[開発環境] --> B[ステージング環境]
    B --> C[本番環境]
    
    A --> A1[開発者が作業]
    B --> B1[本番と同じ環境で<br/>最終確認]
    C --> C1[ユーザーが<br/>実際に使う]
    
    style A fill:#c8e6c9,stroke:#2e7d32
    style B fill:#fff9c4,stroke:#f57f17
    style C fill:#ffcdd2,stroke:#c62828
```

**関連用語:** リリース、デプロイメント、CI/CD、リリース

---

#### ドキュメント（Document / ドキュメント）

**読み方:** ドキュメント  
**重要度:** ⭐⭐⭐

**意味:**
プロジェクトやシステムに関する情報を記録した文書。設計書、仕様書、マニュアルなど。

**主なドキュメント:**

- 要件定義書
- 設計書（基本設計書、詳細設計書）
- テスト仕様書
- 運用マニュアル
- ユーザーマニュアル
- API仕様書

**ドキュメントの重要性:**

- 認識の統一
- 知識の保存
- 引き継ぎの円滑化
- トラブル時の対応

**関連用語:** 文書、ドキュメンテーション、仕様書

---

### 【な行】

#### 認証（Authentication / にんしょう）

**読み方:** にんしょう  
**重要度:** ⭐⭐⭐

**意味:**
「あなたは誰ですか？」を確認すること。本人確認。

**認証の方法:**

| 方法 | 説明 | 具体例 | セキュリティレベル |
|------|------|--------|------------------|
| **知識認証** | 知っていることで認証 | パスワード、PIN | ⭐⭐ |
| **所有認証** | 持っているもので認証 | ICカード、スマホ | ⭐⭐⭐ |
| **生体認証** | 本人の身体で認証 | 指紋、顔認証 | ⭐⭐⭐ |
| **二要素認証**<br/>(2FA) | 2つの方法を組み合わせ | パスワード+SMS | ⭐⭐⭐ |
| **多要素認証**<br/>(MFA) | 3つ以上の方法を組み合わせ | パスワード+指紋+SMS | ⭐⭐⭐ |

**対義語:** 認可

**関連用語:** ログイン、パスワード、二段階認証、OAuth

---

#### 認可（Authorization / にんか）

**読み方:** にんか  
**重要度:** ⭐⭐⭐

**意味:**
「あなたは何ができますか？」を管理すること。権限管理。

**具体例:**

```mermaid
graph TD
    A[ユーザー] --> B{認証<br/>あなたは誰？}
    B -->|OK| C{認可<br/>何ができる？}
    
    C --> D[管理者]
    C --> E[一般ユーザー]
    C --> F[ゲスト]
    
    D --> D1[全ての操作が可能]
    E --> E1[閲覧と編集が可能]
    F --> F1[閲覧のみ可能]
    
    style B fill:#e1f5fe,stroke:#0277bd
    style C fill:#fff3e0,stroke:#ef6c00
```

**対義語:** 認証

**関連用語:** アクセス制御、権限、ロール、RBAC

---

### 【は行】

#### バージョン管理（Version Control / バージョンかんり）

**読み方:** バージョンかんり  
**重要度:** ⭐⭐⭐

**意味:**
ソースコードやドキュメントの変更履歴を記録し、過去のバージョンに戻せるようにする仕組み。

**主なツール:**

- **Git (ギット)**: 最も広く使われている分散型バージョン管理システム
- **GitHub (ギットハブ)**: Gitのホスティングサービス
- **GitLab (ギットラボ)**: GitHub類似のサービス
- **Subversion (サブバージョン / SVN)**: 集中型バージョン管理システム

**Gitの主なコマンド:**

```bash
git add .          # 変更をステージング
git commit -m "メッセージ"  # コミット
git push           # リモートに送信
git pull           # リモートから取得
git branch         # ブランチ一覧
git merge          # ブランチをマージ
```

**関連用語:** Git、GitHub、コミット、ブランチ、マージ

---

#### バグ（Bug / バグ）

**読み方:** バグ  
**重要度:** ⭐⭐⭐

**意味:**
プログラムの不具合、誤動作のこと。「虫」という意味で、コンピューターに虫が入り込んだことが語源。

**バグの種類:**

| 種類 | 説明 | 具体例 | 深刻度 |
|------|------|--------|--------|
| **致命的バグ**<br/>(Critical) | システムが動かない | 起動しない、データ消失 | 🔴 最高 |
| **重大バグ**<br/>(Major) | 主要機能が使えない | 決済ができない | 🟠 高 |
| **軽微バグ**<br/>(Minor) | 一部機能に問題 | 表示が崩れる | 🟡 中 |
| **些細なバグ**<br/>(Trivial) | ほとんど影響なし | 誤字脱字 | 🟢 低 |

**バグの原因:**

- コーディングミス
- 設計の誤り
- 要件の不明確さ
- テスト不足
- 環境の違い

**関連用語:** デバッグ、不具合、障害、エラー

---

#### フロントエンド（Frontend / フロントエンド）

**読み方:** フロントエンド  
**重要度:** ⭐⭐⭐

**意味:**
ユーザーが直接見て操作する部分。Webサイトの見た目やスマホアプリの画面など。

**主な技術:**

```mermaid
graph TD
    A[フロントエンド] --> B[HTML]
    A --> C[CSS]
    A --> D[JavaScript]
    
    B --> B1[構造を作る]
    C --> C1[見た目を整える]
    D --> D1[動きをつける]
    
    A --> E[フレームワーク]
    E --> E1[React<br/>Vue.js<br/>Angular]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#c8e6c9,stroke:#2e7d32
    style D fill:#fff9c4,stroke:#f57f17
    style E fill:#f3e5f5,stroke:#7b1fa2
```

**対義語:** バックエンド

**関連用語:** UI、UX、クライアントサイド、レスポンシブデザイン

---

#### プロトタイプ（Prototype / プロトタイプ）

**読み方:** プロトタイプ  
**重要度:** ⭐⭐

**意味:**
完成品を作る前に作る試作品。動作確認やイメージ共有のために作る。

**プロトタイプの種類:**

| 種類 | 説明 | 用途 | ツール例 |
|------|------|------|---------|
| **紙プロトタイプ** | 紙に描いた画面 | 初期段階のアイデア検証 | 紙とペン |
| **ワイヤーフレーム** | 線画で画面を描く | レイアウト確認 | Figma, Sketch |
| **モックアップ** | 実際に近いデザイン | 見た目の確認 | Figma, Adobe XD |
| **動作プロトタイプ** | 実際に動くもの | 操作感の確認 | HTML/CSS/JS |

**関連用語:** モックアップ、ワイヤーフレーム、MVP

---

#### フレームワーク（Framework / フレームワーク）

**読み方:** フレームワーク  
**重要度:** ⭐⭐⭐

**意味:**
アプリケーション開発のための「枠組み」「土台」となるソフトウェア。よく使う機能があらかじめ用意されていて、効率的に開発できる。

**主なフレームワーク:**

| 言語 | フレームワーク | 読み方 | 用途 |
|------|--------------|--------|------|
| **JavaScript** | React | リアクト | フロントエンド |
| | Vue.js | ビュー | フロントエンド |
| | Angular | アンギュラー | フロントエンド |
| | Node.js | ノード | バックエンド |
| | Next.js | ネクスト | フルスタック |
| **Python** | Django | ジャンゴ | Webアプリ |
| | Flask | フラスク | Webアプリ |
| | FastAPI | ファストAPI | API開発 |
| **Java** | Spring | スプリング | 業務システム |
| **Ruby** | Ruby on Rails | レイルズ | Webアプリ |
| **PHP** | Laravel | ララベル | Webアプリ |
| **C#** | .NET | ドットネット | 業務システム |

**関連用語:** ライブラリ、SDK、プラットフォーム

---

#### プログラム（Program / プログラム）

**読み方:** プログラム  
**重要度:** ⭐⭐⭐

**意味:**
コンピューターに実行させる命令の集まり。人間が書いた指示書。

**プログラムの例:**

```python
# 簡単なプログラムの例
def greet(name):
    message = f"こんにちは、{name}さん！"
    return message

result = greet("太郎")
print(result)  # 出力: こんにちは、太郎さん！
```

**関連用語:** ソースコード、コーディング、プログラミング

---

#### 保守（Maintenance / ほしゅ）

**読み方:** ほしゅ  
**重要度:** ⭐⭐⭐

**意味:**
システムをリリースした後、修正や改善を行うこと。バグ修正、機能追加、性能改善など。

**保守の種類:**

```mermaid
graph TD
    A[保守の種類] --> B[是正保守<br/>Corrective]
    A --> C[予防保守<br/>Preventive]
    A --> D[適応保守<br/>Adaptive]
    A --> E[完全化保守<br/>Perfective]
    
    B --> B1[バグを修正する]
    C --> C1[バグを予防する]
    D --> D1[環境変化に対応する]
    E --> E1[性能や機能を改善する]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#ffcdd2,stroke:#c62828
    style C fill:#c8e6c9,stroke:#2e7d32
    style D fill:#fff9c4,stroke:#f57f17
    style E fill:#e1f5fe,stroke:#0277bd
```

**関連用語:** 運用、運用保守、メンテナンス

---

#### 本番環境（Production Environment / ほんばんかんきょう）

**読み方:** ほんばんかんきょう  
**重要度:** ⭐⭐⭐

**意味:**
実際のユーザーがシステムを使う環境。最も重要で、慎重に扱う必要がある。

**環境の比較:**

| 環境 | 誰が使う | 目的 | データ | 変更 |
|------|---------|------|--------|------|
| **開発環境** | 開発者 | 開発・テスト | テストデータ | 自由 |
| **ステージング環境** | QAチーム | 最終確認 | 本番に近い | 慎重 |
| **本番環境** | エンドユーザー | 実際の利用 | 本番データ | 最慎重 |

**英語:** Production、本番、プロダクション

**関連用語:** 開発環境、ステージング環境、リリース

---

### 【ま行】

#### マイクロサービス（Microservices / マイクロサービス）

**読み方:** マイクロサービス  
**重要度:** ⭐⭐

**意味:**
大きなシステムを小さな独立したサービスに分割して開発する手法。各サービスは独立して開発・デプロイできる。

**モノリスとの比較:**

```mermaid
graph TD
    A[アーキテクチャ] --> B[モノリス<br/>一枚岩]
    A --> C[マイクロサービス<br/>分散型]
    
    B --> B1[全機能が1つにまとまっている]
    B --> B2[シンプル]
    B --> B3[変更が困難]
    
    C --> C1[機能ごとに分割]
    C --> C2[複雑]
    C --> C3[変更が容易]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#c8e6c9,stroke:#2e7d32
```

**メリット:**

- 部分的な変更が容易
- 技術スタックを自由に選べる
- スケールしやすい
- 障害の影響範囲が限定的

**デメリット:**

- システムが複雑になる
- サービス間通信のオーバーヘッド
- 運用が難しい

**関連用語:** API、コンテナ、Docker、Kubernetes

---

#### モジュール（Module / モジュール）

**読み方:** モジュール  
**重要度:** ⭐⭐

**意味:**
プログラムを機能ごとに分割した部品。再利用可能な独立した単位。

**具体例:**

```python
# math_module.py（モジュール）
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

# main.py（モジュールを使う側）
import math_module

result = math_module.add(5, 3)  # モジュールの関数を使う
print(result)  # 8
```

**関連用語:** ライブラリ、パッケージ、コンポーネント

---

### 【や行】

#### 要件定義（Requirements Definition / ようけんていぎ）

**読み方:** ようけんていぎ  
**重要度:** ⭐⭐⭐

**意味:**
「何を作るか」を明確にする工程。システム開発で最も重要なフェーズ。

**要件定義で決めること:**

- 誰が使うのか（ユーザー）
- 何ができるようにするのか（機能）
- どれくらいの性能が必要か（非機能）
- いつまでに必要か（スケジュール）
- 予算はどれくらいか（コスト）

**成果物:**

- 要件定義書（RFP）
- 機能要件一覧
- 非機能要件一覧
- ユースケース図
- 画面遷移図

**関連用語:** RFP、要求仕様書、SRS、機能要件、非機能要件

---

### 【ら行】

#### ライブラリ（Library / ライブラリ）

**読み方:** ライブラリ  
**重要度:** ⭐⭐⭐

**意味:**
よく使う機能をまとめたプログラムの部品集。車輪の再発明をせずに済む。

**フレームワークとの違い:**

| | ライブラリ | フレームワーク |
|---|-----------|--------------|
| **制御の主導権** | 開発者が呼び出す | フレームワークが呼び出す |
| **自由度** | 高い | 低い（ルールに従う） |
| **例** | jQuery, Lodash | React, Django |

**主なライブラリ:**

- **JavaScript**: jQuery, Lodash, Moment.js
- **Python**: NumPy, Pandas, Requests
- **Java**: Apache Commons, Guava
- **C#**: Newtonsoft.Json

**関連用語:** フレームワーク、パッケージ、モジュール

---

#### リファクタリング（Refactoring / リファクタリング）

**読み方:** リファクタリング  
**重要度:** ⭐⭐

**意味:**
プログラムの動作を変えずに、コードの内部構造を改善すること。読みやすく、保守しやすくする。

**リファクタリングの例:**

```python
# リファクタリング前（読みにくい）
def calc(a, b, c):
    if c == 1:
        return a + b
    elif c == 2:
        return a - b
    elif c == 3:
        return a * b

# リファクタリング後（読みやすい）
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

def multiply(a, b):
    return a * b
```

**リファクタリングのタイミング:**

- 同じコードが3回出てきたら
- 関数が長くなりすぎたら
- コードレビューで指摘されたら
- テストを書く前に

**関連用語:** 技術的負債、コード品質、クリーンコード

---

#### リリース（Release / リリース）

**読み方:** リリース  
**重要度:** ⭐⭐⭐

**意味:**
開発したシステムを本番環境に公開して、ユーザーが使えるようにすること。

**リリースの流れ:**

```mermaid
graph LR
    A[開発完了] --> B[テスト完了]
    B --> C[ステージング<br/>デプロイ]
    C --> D[最終確認]
    D --> E[本番デプロイ]
    E --> F[リリース完了]
    F --> G[監視]
    
    style A fill:#c8e6c9,stroke:#2e7d32
    style B fill:#fff9c4,stroke:#f57f17
    style C fill:#e1f5fe,stroke:#0277bd
    style D fill:#fff3e0,stroke:#ef6c00
    style E fill:#ffcdd2,stroke:#c62828
    style F fill:#f3e5f5,stroke:#7b1fa2
    style G fill:#e0f2f1,stroke:#00695c
```

**リリースの種類:**

- **アルファ版**: 開発チーム内でのテスト版
- **ベータ版**: 限定ユーザーに公開するテスト版
- **正式版**: 全ユーザーに公開する完成版
- **パッチ版**: バグ修正版

**関連用語:** デプロイ、ローンチ、公開

---

#### レビュー（Review / レビュー）

**読み方:** レビュー  
**重要度:** ⭐⭐⭐

**意味:**
成果物（ドキュメントやコード）を他の人に確認してもらうこと。品質向上とバグの早期発見が目的。

**レビューの種類:**

| 種類 | 対象 | 実施者 | タイミング |
|------|------|--------|-----------|
| **仕様レビュー** | 要件定義書、設計書 | ステークホルダー | 各フェーズ完了時 |
| **設計レビュー** | 設計書 | アーキテクト、リード | 設計完了時 |
| **コードレビュー** | ソースコード | 他の開発者 | コミット前 |
| **テストレビュー** | テストケース | QAリード | テスト実行前 |

**レビューの方法:**

- **ウォークスルー**: 作成者が説明しながらレビュー
- **インスペクション**: 正式な手順に従った詳細レビュー
- **ペアプログラミング**: 2人で一緒に作業
- **プルリクエスト**: GitHubなどでのオンラインレビュー

**関連用語:** コードレビュー、ピアレビュー、インスペクション

---

#### ログ（Log / ログ）

**読み方:** ログ  
**重要度:** ⭐⭐⭐

**意味:**
システムの動作履歴を記録したもの。「何が起きたか」を後から確認できる。

**ログの種類:**

| 種類 | 内容 | 用途 |
|------|------|------|
| **エラーログ** | エラーや例外の記録 | 障害調査 |
| **アクセスログ** | アクセス履歴 | 利用状況の分析 |
| **アプリケーションログ** | アプリの動作記録 | デバッグ、監視 |
| **セキュリティログ** | 認証、認可の記録 | セキュリティ監査 |
| **監査ログ** | 操作履歴 | コンプライアンス |

**ログレベル:**

```mermaid
graph TD
    A[ログレベル] --> B[TRACE]
    A --> C[DEBUG]
    A --> D[INFO]
    A --> E[WARN]
    A --> F[ERROR]
    A --> G[FATAL]
    
    B --> B1[最も詳細<br/>開発時のみ]
    C --> C1[デバッグ情報]
    D --> D1[通常の動作情報]
    E --> E1[警告]
    F --> F1[エラー]
    G --> G1[致命的エラー]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#e0f2f1,stroke:#00695c
    style C fill:#c8e6c9,stroke:#2e7d32
    style D fill:#e1f5fe,stroke:#0277bd
    style E fill:#fff9c4,stroke:#f57f17
    style F fill:#fff3e0,stroke:#ef6c00
    style G fill:#ffcdd2,stroke:#c62828
```

**関連用語:** ロギング、監視、トレース

---

### 【わ行】

#### ワークフロー（Workflow / ワークフロー）

**読み方:** ワークフロー  
**重要度:** ⭐⭐

**意味:**
作業の流れ、手順のこと。業務プロセスを図や文章で表したもの。

**開発ワークフローの例:**

```mermaid
graph LR
    A[課題発見] --> B[チケット作成]
    B --> C[開発]
    C --> D[テスト]
    D --> E[コードレビュー]
    E --> F[マージ]
    F --> G[デプロイ]
    G --> H[完了]
    
    style A fill:#c8e6c9,stroke:#2e7d32
    style H fill:#ffcdd2,stroke:#c62828
```

**関連用語:** プロセス、手順、フロー

---

---

## 7.2 アルファベット用語

### 【A】

#### ADR（Architecture Decision Record / エーディーアール）

**読み方:** エーディーアール、アーキテクチャデシジョンレコード  
**重要度:** ⭐⭐

**意味:**
設計上の重要な決定とその理由を記録したドキュメント。「なぜこの設計にしたのか」を後から理解できるようにする。

**ADRに記録する内容:**

- **タイトル**: 決定の要約
- **ステータス**: 提案中/承認済み/非推奨
- **コンテキスト**: 背景、問題
- **決定**: 採用した解決策
- **結果**: その決定の影響、トレードオフ

**テンプレート例:**

```markdown
# ADR-001: データベースにPostgreSQLを採用

## ステータス
承認済み

## コンテキスト
ECサイトのデータベースを選定する必要がある。
トランザクション処理が多く、データ整合性が重要。

## 決定
PostgreSQLを採用する。

## 理由
- ACIDトランザクションに完全対応
- JSON型のサポート
- オープンソースで無料
- 豊富な実績

## 結果
- 信頼性の高いデータ管理が可能
- ライセンス費用がかからない
- ただし、運用には専門知識が必要
```

**関連用語:** 設計決定、ドキュメント、アーキテクチャ

---

#### Agile（アジャイル）

**読み方:** アジャイル  
**重要度:** ⭐⭐⭐

**意味:**
「素早い」「機敏な」という意味。短い期間で計画・開発・リリースを繰り返す開発手法。

**アジャイルの4つの価値観（アジャイルマニフェスト）:**

1. プロセスやツールよりも**個人と対話**を
2. 包括的なドキュメントよりも**動くソフトウェア**を
3. 契約交渉よりも**顧客との協調**を
4. 計画に従うことよりも**変化への対応**を

**主な手法:**

- スクラム（Scrum）
- カンバン（Kanban）
- XP（エクストリームプログラミング）

**関連用語:** スプリント、スクラム、イテレーション

➡️ **詳しくは**: 第2章2.2、第3章参照

---

#### API（Application Programming Interface / エーピーアイ）

**読み方:** エーピーアイ、アプリケーションプログラミングインターフェース  
**重要度:** ⭐⭐⭐

**意味:**
アプリケーション同士が連携するための「窓口」。他のシステムの機能を利用できるようにする仕組み。

**身近な例:**

- 天気予報アプリが天気情報を取得する
- Googleマップを自分のサイトに埋め込む
- SNSで「Googleでログイン」する
- 決済システムと連携する

**APIの種類:**

```mermaid
graph TD
    A[API の種類] --> B[REST API]
    A --> C[GraphQL]
    A --> D[SOAP]
    A --> E[gRPC]
    
    B --> B1[最も一般的<br/>HTTPベース<br/>JSON形式]
    C --> C1[必要なデータだけ取得<br/>Facebook開発]
    D --> D1[古い規格<br/>XML形式<br/>厳格]
    E --> E1[高速<br/>Googleが開発<br/>バイナリ形式]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#c8e6c9,stroke:#2e7d32
    style C fill:#fff3e0,stroke:#ef6c00
    style D fill:#f3e5f5,stroke:#7b1fa2
    style E fill:#fff9c4,stroke:#f57f17
```

**RESTful APIの例:**

```
GET    /api/users        # ユーザー一覧取得
GET    /api/users/123    # ID=123のユーザー取得
POST   /api/users        # ユーザー作成
PUT    /api/users/123    # ID=123のユーザー更新
DELETE /api/users/123    # ID=123のユーザー削除
```

**関連用語:** REST、JSON、エンドポイント、Webhook

---

#### AWS（Amazon Web Services / エーダブリューエス）

**読み方:** エーダブリューエス、アマゾンウェブサービシーズ  
**重要度:** ⭐⭐⭐

**意味:**
Amazonが提供する世界最大級のクラウドサービス。サーバー、ストレージ、データベースなど、200以上のサービスを提供。

**主なAWSサービス:**

| サービス名 | 読み方 | 用途 | 説明 |
|----------|--------|------|------|
| **EC2** | イーシーツー | 仮想サーバー | 自由に設定できるサーバー |
| **S3** | エススリー | ストレージ | ファイル保存 |
| **RDS** | アールディーエス | データベース | 管理不要のDB |
| **Lambda** | ラムダ | サーバーレス | コードだけ書けばOK |
| **CloudFront** | クラウドフロント | CDN | 高速配信 |
| **Route53** | ルート53 | DNS | ドメイン管理 |
| **ECS/EKS** | イーシーエス/イーケーエス | コンテナ | Docker運用 |
| **DynamoDB** | ダイナモDB | NoSQLDB | 高速なDB |

**AWSの特徴:**

- 従量課金（使った分だけ支払い）
- 世界中にデータセンター
- 自動スケーリング
- 豊富なサービス

**料金の例:**

- EC2 (t3.micro): 約$10/月〜
- S3: $0.023/GB/月
- Lambda: 100万リクエストまで無料

**関連用語:** クラウド、Azure、GCP、オンプレミス

---

### 【B】

#### Backend（バックエンド）

**読み方:** バックエンド  
**重要度:** ⭐⭐⭐

**意味:**
ユーザーから見えない裏側の処理。サーバー側の処理、データベース操作、ビジネスロジックなど。

**フロントエンドとの比較:**

```mermaid
graph LR
    A[ユーザー] -->|操作| B[フロントエンド<br/>見える部分]
    B -->|リクエスト| C[バックエンド<br/>見えない部分]
    C -->|データ取得| D[データベース]
    C -->|レスポンス| B
    B -->|表示| A
    
    style A fill:#e1f5fe,stroke:#0277bd
    style B fill:#c8e6c9,stroke:#2e7d32
    style C fill:#fff3e0,stroke:#ef6c00
    style D fill:#f3e5f5,stroke:#7b1fa2
```

**主なバックエンド技術:**

- **言語**: Java, Python, Ruby, Node.js, Go, PHP
- **フレームワーク**: Spring, Django, Rails, Express
- **データベース**: MySQL, PostgreSQL, MongoDB

**対義語:** フロントエンド

**関連用語:** サーバーサイド、API、データベース

---

#### Bug（バグ）

**読み方:** バグ  
**重要度:** ⭐⭐⭐

➡️ **「バグ」を参照**（7.1 日本語用語の「は行」）

---

### 【C】

#### CI/CD（Continuous Integration/Continuous Delivery / シーアイシーディー）

**読み方:** シーアイシーディー、継続的インテグレーション/継続的デリバリー  
**重要度:** ⭐⭐⭐

**意味:**
コードの変更を自動的にテスト・ビルド・デプロイする仕組み。手作業を減らし、品質を保ちながら素早くリリースできる。

**CI/CDの流れ:**

```mermaid
graph LR
    A[コードを書く] --> B[GitHubにプッシュ]
    B --> C[CI: 自動テスト]
    C --> D{テスト<br/>合格？}
    D -->|Yes| E[CD: 自動ビルド]
    D -->|No| F[開発者に通知]
    E --> G[ステージング<br/>デプロイ]
    G --> H[承認]
    H --> I[本番デプロイ]
    
    style A fill:#c8e6c9,stroke:#2e7d32
    style C fill:#e1f5fe,stroke:#0277bd
    style D fill:#fff9c4,stroke:#f57f17
    style E fill:#f3e5f5,stroke:#7b1fa2
    style I fill:#ffcdd2,stroke:#c62828
```

**CI (Continuous Integration - 継続的インテグレーション):**

- コードを頻繁にマージ
- 自動テストを実行
- 問題を早期発見

**CD (Continuous Delivery/Deployment - 継続的デリバリー/デプロイ):**

- 自動ビルド
- 自動デプロイ
- いつでもリリース可能な状態を維持

**主なCI/CDツール:**

- **GitHub Actions**: GitHubに統合
- **Jenkins**: オープンソースで最も有名
- **CircleCI**: クラウド型
- **GitLab CI/CD**: GitLabに統合
- **Travis CI**: オープンソースに人気

**関連用語:** DevOps、自動テスト、デプロイメント

---

#### Cloud（クラウド）

**読み方:** クラウド  
**重要度:** ⭐⭐⭐

➡️ **「クラウド」を参照**（7.1 日本語用語の「か行」）

---

#### CSS（Cascading Style Sheets / シーエスエス）

**読み方:** シーエスエス、カスケーディングスタイルシート  
**重要度:** ⭐⭐⭐

**意味:**
Webページの見た目（色、レイアウト、フォントなど）を定義する言語。HTMLが「構造」、CSSが「デザイン」を担当。

**CSSの例:**

```css
/* ボタンのスタイル */
.button {
    background-color: #007bff;  /* 背景色: 青 */
    color: white;               /* 文字色: 白 */
    padding: 10px 20px;         /* 余白 */
    border-radius: 5px;         /* 角を丸く */
    border: none;               /* 枠線なし */
}

/* ホバー時（マウスを乗せた時） */
.button:hover {
    background-color: #0056b3;  /* 濃い青に変更 */
}
```

**CSSでできること:**

- 色の指定
- レイアウト（配置）
- アニメーション
- レスポンシブデザイン（画面サイズに応じた調整）
- フォント、余白、枠線など

**関連技術:**

- **CSS Framework**: Bootstrap, Tailwind CSS
- **CSS Preprocessor**: Sass, Less
- **CSS-in-JS**: styled-components（React）

**関連用語:** HTML、JavaScript、スタイルシート、レスポンシブデザイン

---

### 【D】

#### Database（データベース）

**読み方:** データベース  
**重要度:** ⭐⭐⭐

➡️ **「データベース」を参照**（7.1 日本語用語の「た行」）

---

#### DevOps（Development and Operations / デブオプス）

**読み方:** デブオプス、開発と運用  
**重要度:** ⭐⭐⭐

**意味:**
開発チーム(Development)と運用チーム(Operations)が協力して、開発からリリース、運用までを効率化する文化・手法。

**従来 vs DevOps:**

```mermaid
graph TD
    A[従来の方法] --> A1[開発チーム]
    A --> A2[運用チーム]
    A1 -.壁.- A2
    A1 --> A3[作って終わり]
    A2 --> A4[問題が起きてから対応]
    
    B[DevOps] --> B1[開発+運用が協力]
    B1 --> B2[自動化]
    B1 --> B3[継続的改善]
    B1 --> B4[素早いリリース]
    
    style A fill:#ffcdd2,stroke:#c62828
    style B fill:#c8e6c9,stroke:#2e7d32
```

**DevOpsの主要な実践:**

- **CI/CD**: 自動テスト・デプロイ
- **Infrastructure as Code (IaC)**: インフラをコードで管理
- **監視とログ**: システムの状態を常に把握
- **アジャイル開発**: 短いサイクルでリリース
- **チーム間のコミュニケーション**: 壁を壊す

**DevOpsツール:**

| カテゴリ | ツール | 用途 |
|---------|--------|------|
| **バージョン管理** | Git, GitHub | コード管理 |
| **CI/CD** | Jenkins, GitHub Actions | 自動化 |
| **コンテナ** | Docker, Kubernetes | 環境の統一 |
| **IaC** | Terraform, Ansible | インフラ自動化 |
| **監視** | Prometheus, Datadog | システム監視 |

**関連用語:** CI/CD、SRE、アジャイル、自動化

---

#### Docker（ドッカー）

**読み方:** ドッカー  
**重要度:** ⭐⭐⭐

**意味:**
アプリケーションとその実行環境を「コンテナ」としてパッケージ化する技術。「どこでも同じように動く」を実現。

**従来の方法との違い:**

```mermaid
graph TD
    A[従来: 仮想マシン] --> A1[重い<br/>起動が遅い<br/>リソースを多く消費]
    
    B[Docker: コンテナ] --> B1[軽い<br/>起動が速い<br/>リソース効率的]
    
    style A fill:#ffcdd2,stroke:#c62828
    style B fill:#c8e6c9,stroke:#2e7d32
```

**Dockerの主な概念:**

| 用語 | 説明 |
|------|------|
| **Image (イメージ)** | アプリの設計図 |
| **Container (コンテナ)** | 実際に動いているアプリ |
| **Dockerfile** | イメージの作り方を記述したファイル |
| **Docker Hub** | イメージを共有するサービス |
| **Docker Compose** | 複数のコンテナをまとめて管理 |

**Dockerfileの例:**

```dockerfile
# ベースイメージ
FROM python:3.9

# 作業ディレクトリ
WORKDIR /app

# 依存関係をインストール
COPY requirements.txt .
RUN pip install -r requirements.txt

# アプリケーションをコピー
COPY . .

# 起動コマンド
CMD ["python", "app.py"]
```

**Dockerのメリット:**

- 環境の違いによる問題がなくなる
- 開発環境と本番環境を同じにできる
- 素早くデプロイできる
- スケールしやすい

**関連用語:** コンテナ、Kubernetes、仮想化、マイクロサービス

---

### 【E】

#### EC2（Elastic Compute Cloud / イーシーツー）

**読み方:** イーシーツー、エラスティックコンピュートクラウド  
**重要度:** ⭐⭐⭐

**意味:**
AWSが提供する仮想サーバーサービス。必要な時に必要なだけサーバーを借りられる。

**EC2の特徴:**

- 数分でサーバーを起動
- 使った分だけ課金
- スペックを自由に選べる
- 自動スケーリング可能

**インスタンスタイプの例:**

| タイプ | 用途 | スペック例 | 料金目安 |
|--------|------|-----------|---------|
| **t3.micro** | 小規模サイト | 2CPU, 1GB RAM | 約$10/月 |
| **t3.medium** | 中規模サイト | 2CPU, 4GB RAM | 約$40/月 |
| **m5.large** | 汎用 | 2CPU, 8GB RAM | 約$80/月 |
| **c5.xlarge** | CPU重視 | 4CPU, 8GB RAM | 約$150/月 |

**関連用語:** AWS、クラウド、仮想サーバー、インスタンス

---

### 【F】

#### Framework（フレームワーク）

**読み方:** フレームワーク  
**重要度:** ⭐⭐⭐

➡️ **「フレームワーク」を参照**（7.1 日本語用語の「は行」）

---

#### Frontend（フロントエンド）

**読み方:** フロントエンド  
**重要度:** ⭐⭐⭐

➡️ **「フロントエンド」を参照**（7.1 日本語用語の「は行」）

---

### 【G】

#### GCP（Google Cloud Platform / ジーシーピー）

**読み方:** ジーシーピー、グーグルクラウドプラットフォーム  
**重要度:** ⭐⭐⭐

**意味:**
Googleが提供するクラウドサービス。機械学習、ビッグデータ分析に強い。

**主なGCPサービス:**

| サービス名 | 読み方 | 用途 | AWS相当 |
|----------|--------|------|---------|
| **Compute Engine** | コンピュートエンジン | 仮想サーバー | EC2 |
| **Cloud Storage** | クラウドストレージ | ファイル保存 | S3 |
| **Cloud SQL** | クラウドSQL | データベース | RDS |
| **BigQuery** | ビッグクエリー | データ分析 | Redshift |
| **Cloud Functions** | クラウドファンクションズ | サーバーレス | Lambda |
| **Kubernetes Engine** | クーバネティスエンジン | コンテナ管理 | EKS |

**GCPの特徴:**

- Googleの技術を利用できる
- 機械学習ツールが充実
- ビッグデータ処理に強い
- Kubernetesの元祖

**関連用語:** クラウド、AWS、Azure、BigQuery

---

#### Git（ギット）

**読み方:** ギット  
**重要度:** ⭐⭐⭐

**意味:**
分散型バージョン管理システム。コードの変更履歴を記録し、複数人で開発する時に必須のツール。

**Gitの基本概念:**

```mermaid
graph LR
    A[ローカルリポジトリ<br/>自分のPC] -->|push| B[リモートリポジトリ<br/>GitHub/GitLab]
    B -->|pull| A
    
    A --> A1[作業ディレクトリ<br/>編集中のファイル]
    A1 -->|add| A2[ステージング<br/>コミット準備]
    A2 -->|commit| A3[ローカルリポジトリ<br/>変更を記録]
    
    style B fill:#e1f5fe,stroke:#0277bd
    style A fill:#c8e6c9,stroke:#2e7d32
```

**主なGitコマンド:**

```bash
# 初期化
git init                    # Gitリポジトリを作成

# 基本操作
git add .                   # 変更をステージング
git commit -m "メッセージ"   # コミット
git push                    # リモートに送信
git pull                    # リモートから取得

# ブランチ操作
git branch                  # ブランチ一覧
git branch feature-login    # 新しいブランチ作成
git checkout feature-login  # ブランチ切り替え
git merge feature-login     # ブランチをマージ

# 履歴確認
git log                     # コミット履歴
git status                  # 現在の状態
git diff                    # 変更内容の確認
```

**Gitの重要な概念:**

- **コミット (Commit)**: 変更の記録
- **ブランチ (Branch)**: 並行して開発できる分岐
- **マージ (Merge)**: ブランチを統合
- **プルリクエスト (Pull Request)**: コードレビュー依頼

**関連用語:** GitHub、GitLab、バージョン管理、コミット、ブランチ

---

#### GitHub（ギットハブ）

**読み方:** ギットハブ  
**重要度:** ⭐⭐⭐

**意味:**
Gitリポジトリをクラウド上で管理できるサービス。世界中の開発者がコードを共有・協力するプラットフォーム。

**GitHubの主な機能:**

| 機能 | 説明 |
|------|------|
| **リポジトリ** | コードを保存する場所 |
| **Pull Request** | コードレビュー依頼 |
| **Issues** | バグ報告、タスク管理 |
| **Actions** | CI/CDの自動化 |
| **Projects** | プロジェクト管理 |
| **Wiki** | ドキュメント |
| **Gist** | コードスニペット共有 |

**GitHubの使い方（基本）:**

```mermaid
graph TD
    A[リポジトリ作成] --> B[ローカルにクローン]
    B --> C[ブランチを作成]
    C --> D[コードを編集]
    D --> E[コミット]
    E --> F[プッシュ]
    F --> G[プルリクエスト作成]
    G --> H[コードレビュー]
    H --> I{OK?}
    I -->|Yes| J[マージ]
    I -->|No| D
    
    style A fill:#c8e6c9,stroke:#2e7d32
    style H fill:#fff9c4,stroke:#f57f17
    style J fill:#e1f5fe,stroke:#0277bd
```

**GitHubとGitの違い:**

- **Git**: バージョン管理システム（ツール）
- **GitHub**: Gitを使ったサービス（Webサービス）

**類似サービス:**

- **GitLab**: セルフホスト可能
- **Bitbucket**: Atlassian製品と統合
- **Azure Repos**: Microsoft製品と統合

**関連用語:** Git、バージョン管理、プルリクエスト、リポジトリ

---

### 【H】

#### HTML（HyperText Markup Language / エイチティーエムエル）

**読み方:** エイチティーエムエル、ハイパーテキストマークアップランゲージ  
**重要度:** ⭐⭐⭐

**意味:**
Webページの構造を記述する言語。見出し、段落、リンク、画像などを定義する。

**HTMLの例:**

```html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>私のページ</title>
</head>
<body>
    <h1>こんにちは！</h1>
    <p>これは段落です。</p>
    <a href="https://example.com">リンク</a>
    <img src="photo.jpg" alt="写真">
    
    <ul>
        <li>リスト項目1</li>
        <li>リスト項目2</li>
    </ul>
</body>
</html>
```

**主なHTMLタグ:**

| タグ | 用途 | 例 |
|------|------|-----|
| `<h1>〜<h6>` | 見出し | `<h1>大見出し</h1>` |
| `<p>` | 段落 | `<p>文章</p>` |
| `<a>` | リンク | `<a href="url">リンク</a>` |
| `<img>` | 画像 | `<img src="image.jpg">` |
| `<div>` | ブロック | `<div>まとまり</div>` |
| `<span>` | インライン | `<span>部分</span>` |
| `<ul><li>` | リスト | `<ul><li>項目</li></ul>` |
| `<form>` | フォーム | `<form>...</form>` |
| `<input>` | 入力欄 | `<input type="text">` |
| `<button>` | ボタン | `<button>クリック</button>` |

**関連用語:** CSS、JavaScript、DOM、タグ、マークアップ

---

#### HTTP/HTTPS（HyperText Transfer Protocol / エイチティーティーピー）

**読み方:** エイチティーティーピー / エイチティーティーピーエス  
**重要度:** ⭐⭐⭐

**意味:**
Webブラウザとサーバーが通信するためのルール（プロトコル）。HTTPSは暗号化されたHTTP。

**HTTPとHTTPSの違い:**

```mermaid
graph LR
    A[HTTP] --> A1[暗号化なし<br/>第三者に見られる可能性<br/>安全性: 低]
    B[HTTPS] --> B1[暗号化あり<br/>安全な通信<br/>安全性: 高]
    
    style A fill:#ffcdd2,stroke:#c62828
    style B fill:#c8e6c9,stroke:#2e7d32
```

**HTTPメソッド:**

| メソッド | 用途 | 説明 |
|---------|------|------|
| **GET** | 取得 | データを取得する |
| **POST** | 作成 | 新しいデータを送信 |
| **PUT** | 更新 | データを更新 |
| **DELETE** | 削除 | データを削除 |
| **PATCH** | 部分更新 | 一部だけ更新 |

**HTTPステータスコード:**

| コード | 意味 | 説明 |
|--------|------|------|
| **200** | OK | 成功 |
| **201** | Created | 作成成功 |
| **400** | Bad Request | リクエストが不正 |
| **401** | Unauthorized | 認証が必要 |
| **403** | Forbidden | アクセス禁止 |
| **404** | Not Found | ページが見つからない |
| **500** | Internal Server Error | サーバーエラー |
| **503** | Service Unavailable | サービス利用不可 |

**関連用語:** プロトコル、SSL/TLS、REST API、リクエスト、レスポンス

---

### 【I】

#### IDE（Integrated Development Environment / アイディーイー）

**読み方:** アイディーイー、統合開発環境  
**重要度:** ⭐⭐

**意味:**
プログラム開発に必要な機能を1つにまとめたソフトウェア。コード編集、デバッグ、テストなどが一箇所でできる。

**主なIDE:**

| IDE | 読み方 | 主な言語 | 提供元 |
|-----|--------|---------|--------|
| **Visual Studio Code** | ブイエスコード | 全般 | Microsoft |
| **IntelliJ IDEA** | インテリジェイアイディア | Java | JetBrains |
| **PyCharm** | パイチャーム | Python | JetBrains |
| **Eclipse** | エクリプス | Java | Eclipse Foundation |
| **Xcode** | エックスコード | Swift, Objective-C | Apple |
| **Android Studio** | アンドロイドスタジオ | Kotlin, Java | Google |

**IDEの主な機能:**

- コード補完（自動で候補を表示）
- シンタックスハイライト（色分け）
- デバッガー（バグを見つける）
- Git統合
- プラグイン/拡張機能

**VS Code（最も人気）の特徴:**

- 無料
- 軽量で高速
- 豊富な拡張機能
- 多言語対応

**関連用語:** エディタ、コンパイラ、デバッガー

---

#### IaC（Infrastructure as Code / アイエーシー）

**読み方:** アイエーシー、インフラストラクチャーアズコード  
**重要度:** ⭐⭐

**意味:**
インフラ（サーバー、ネットワークなど）の設定をコードで管理する手法。手作業ではなく、コードで自動化する。

**従来との比較:**

```mermaid
graph TD
    A[従来の方法] --> A1[手作業で設定<br/>ミスが起きやすい<br/>再現が困難<br/>時間がかかる]
    
    B[IaC] --> B1[コードで設定<br/>ミスが少ない<br/>再現可能<br/>自動化できる]
    
    style A fill:#ffcdd2,stroke:#c62828
    style B fill:#c8e6c9,stroke:#2e7d32
```

**主なIaCツール:**

| ツール | 読み方 | 用途 | 特徴 |
|--------|--------|------|------|
| **Terraform** | テラフォーム | インフラ構築 | マルチクラウド対応 |
| **Ansible** | アンシブル | 構成管理 | エージェントレス |
| **CloudFormation** | クラウドフォーメーション | AWS専用 | AWS公式 |
| **Pulumi** | プルミ | インフラ構築 | 汎用言語で書ける |

**Terraformの例:**

```hcl
# EC2インスタンスを作成
resource "aws_instance" "web" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t3.micro"

  tags = {
    Name = "WebServer"
  }
}
```

**IaCのメリット:**

- バージョン管理できる
- 同じ環境を簡単に再現できる
- レビューができる
- ドキュメントになる

**関連用語:** DevOps、Terraform、Ansible、自動化

---

#### ISO（International Organization for Standardization / アイエスオー）

**読み方:** アイエスオー、国際標準化機構  
**重要度:** ⭐⭐

**意味:**
国際的な標準規格を策定する組織。システム開発にも多くの規格がある。

**主なISO規格（システム開発関連）:**

| 規格番号 | 名称 | 内容 |
|---------|------|------|
| **ISO/IEC 29148** | 要求工学 | 要件定義の方法 |
| **ISO/IEC 42010** | アーキテクチャ記述 | 設計書の書き方 |
| **ISO/IEC 29119** | ソフトウェアテスト | テストの方法 |
| **ISO 9001** | 品質マネジメント | 品質管理の基準 |
| **ISO 27001** | 情報セキュリティ | セキュリティ管理 |
| **ISO 20000** | ITサービス管理 | 運用管理 |

➡️ **詳しくは**: 第6章参照

**関連用語:** 国際規格、標準、ベストプラクティス

---

### 【J】

#### JavaScript（ジャバスクリプト）

**読み方:** ジャバスクリプト  
**重要度:** ⭐⭐⭐

**意味:**
Webページに動きをつけるプログラミング言語。ブラウザ上で動作し、フロントエンドで最も重要な言語。

**JavaScriptの例:**

```javascript
// ボタンをクリックしたときの処理
document.getElementById('myButton').addEventListener('click', function() {
    alert('ボタンがクリックされました！');
});

// 配列の操作
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(n => n * 2);
console.log(doubled);  // [2, 4, 6, 8, 10]

// 非同期処理（API呼び出し）
fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => console.log(data));
```

**JavaScriptでできること:**

- ボタンクリックなどのイベント処理
- 画面の内容を動的に変更
- フォームのバリデーション
- アニメーション
- APIとの通信
- サーバーサイドプログラミング（Node.js）

**主なJavaScriptフレームワーク:**

- **React**: Meta (Facebook) 開発
- **Vue.js**: 個人開発者が作成
- **Angular**: Google開発
- **Node.js**: サーバーサイドで使える

**JavaとJavaScriptの違い:**

- 名前は似ているが、全く別の言語
- Java: サーバーサイド、静的型付け
- JavaScript: 主にフロントエンド、動的型付け

**関連用語:** HTML、CSS、DOM、React、Node.js

---

#### JSON（JavaScript Object Notation / ジェイソン）

**読み方:** ジェイソン、ジャバスクリプトオブジェクトノーテーション  
**重要度:** ⭐⭐⭐

**意味:**
データを軽量に表現するフォーマット。APIでのデータ交換で最も使われる。人間にも読みやすい。

**JSONの例:**

```json
{
  "name": "田中太郎",
  "age": 30,
  "email": "tanaka@example.com",
  "skills": ["JavaScript", "Python", "React"],
  "address": {
    "city": "東京",
    "zipcode": "100-0001"
  },
  "active": true
}
```

**JSONのデータ型:**

| 型 | 説明 | 例 |
|----|------|-----|
| **文字列** | ダブルクォートで囲む | `"Hello"` |
| **数値** | 整数または小数 | `123`, `3.14` |
| **真偽値** | true または false | `true`, `false` |
| **配列** | `[]`で囲む | `[1, 2, 3]` |
| **オブジェクト** | `{}`で囲む | `{"key": "value"}` |
| **null** | 値なし | `null` |

**JSONの用途:**

- REST APIのレスポンス
- 設定ファイル
- データの保存
- システム間のデータ交換

**XMLとの比較:**

```mermaid
graph TD
    A[データ形式] --> B[JSON]
    A --> C[XML]
    
    B --> B1[軽量<br/>読みやすい<br/>Web APIで人気]
    C --> C1[冗長<br/>厳格<br/>企業システムで使用]
    
    style B fill:#c8e6c9,stroke:#2e7d32
    style C fill:#fff3e0,stroke:#ef6c00
```

**関連用語:** API、REST、データフォーマット、XML

---

### 【K】

#### Kubernetes（クーバネティス / クーベネティス）

**読み方:** クーバネティス、クーベネティス、ケーエイトス(K8s)  
**重要度:** ⭐⭐⭐

**意味:**
Dockerコンテナを大規模に管理・運用するためのオーケストレーションツール。Googleが開発し、オープンソース化。

**Kubernetesが解決する問題:**

```mermaid
graph TD
    A[コンテナの課題] --> B[数が増えると管理が大変]
    A --> C[障害時の自動復旧]
    A --> D[負荷分散]
    A --> E[ローリングアップデート]
    
    F[Kubernetes] --> G[自動でコンテナを管理]
    F --> H[障害を検知して自動復旧]
    F --> I[自動でスケーリング]
    F --> J[無停止でアップデート]
    
    style A fill:#ffcdd2,stroke:#c62828
    style F fill:#c8e6c9,stroke:#2e7d32
```

**Kubernetesの主な概念:**

| 用語 | 読み方 | 説明 |
|------|--------|------|
| **Pod** | ポッド | コンテナの最小単位 |
| **Node** | ノード | Podが動くサーバー |
| **Cluster** | クラスター | 複数のNodeのまとまり |
| **Deployment** | デプロイメント | Podの管理設定 |
| **Service** | サービス | Podへのアクセス方法 |
| **Ingress** | イングレス | 外部からのアクセス |

**Kubernetesの略称:**

- **K8s**: "K"と"s"の間に8文字あるため

**主なKubernetesサービス:**

- **GKE (Google Kubernetes Engine)**: GCPのマネージドK8s
- **EKS (Amazon Elastic Kubernetes Service)**: AWSのマネージドK8s
- **AKS (Azure Kubernetes Service)**: AzureのマネージドK8s

**関連用語:** Docker、コンテナ、オーケストレーション、マイクロサービス

---

### 【L】

#### Lambda（ラムダ / AWS Lambda）

**読み方:** ラムダ  
**重要度:** ⭐⭐⭐

**意味:**
AWSが提供するサーバーレスコンピューティングサービス。サーバーを管理せずに、コードだけ書けば実行できる。

**従来のサーバーとの違い:**

```mermaid
graph TD
    A[従来のサーバー] --> A1[サーバーを管理<br/>常時起動<br/>固定費用<br/>スケール調整が必要]
    
    B[Lambda] --> B1[サーバー管理不要<br/>必要な時だけ実行<br/>実行時間だけ課金<br/>自動スケール]
    
    style A fill:#ffcdd2,stroke:#c62828
    style B fill:#c8e6c9,stroke:#2e7d32
```

**Lambdaの使い方:**

```python
# Lambda関数の例（Python）
def lambda_handler(event, context):
    # イベントデータを取得
    name = event.get('name', 'Guest')
    
    # 処理を実行
    message = f'Hello, {name}!'
    
    # 結果を返す
    return {
        'statusCode': 200,
        'body': message
    }
```

**Lambdaの特徴:**

- サーバーレス（サーバー管理不要）
- イベント駆動（何かが起きたら実行）
- 自動スケーリング
- 実行時間に応じた課金

**Lambdaの用途:**

- API Gatewayと組み合わせてREST API
- S3にファイルアップロードされたら処理
- 定期的なバッチ処理
- リアルタイムデータ処理

**Lambdaの料金:**

- 最初の100万リクエスト: 無料
- それ以降: $0.20 / 100万リクエスト
- 実行時間: $0.0000166667 / GB秒

**対応言語:**

- Python
- Node.js
- Java
- C# (.NET)
- Go
- Ruby
- カスタムランタイム

**関連用語:** サーバーレス、AWS、FaaS、イベント駆動

---

#### Linux（リナックス）

**読み方:** リナックス、リヌックス  
**重要度:** ⭐⭐⭐

**意味:**
オープンソースのオペレーティングシステム（OS）。サーバーで最も使われているOS。

**主なLinuxディストリビューション:**

| ディストリビューション | 読み方 | 特徴 | 用途 |
|-------------------|--------|------|------|
| **Ubuntu** | ウブントゥ | 初心者向け | デスクトップ、サーバー |
| **CentOS** | セントオーエス | 安定性重視 | 企業サーバー |
| **Red Hat Enterprise Linux** | レッドハット | 商用サポート | 企業システム |
| **Debian** | デビアン | 安定版 | サーバー |
| **Amazon Linux** | アマゾンリナックス | AWS最適化 | AWSサーバー |

**基本的なLinuxコマンド:**

```bash
# ディレクトリ操作
ls              # ファイル一覧
cd /path/       # ディレクトリ移動
pwd             # 現在のディレクトリ
mkdir mydir     # ディレクトリ作成

# ファイル操作
cp file1 file2  # ファイルをコピー
mv file1 file2  # ファイルを移動・名前変更
rm file         # ファイルを削除
cat file        # ファイルの内容を表示

# 権限管理
chmod 755 file  # 権限変更
chown user file # 所有者変更

# プロセス管理
ps              # プロセス一覧
kill PID        # プロセスを終了
top             # リソース使用状況

# ネットワーク
ping host       # 疎通確認
curl URL        # HTTPリクエスト
wget URL        # ファイルダウンロード
```

**Linuxが使われる場所:**

- Webサーバー（世界の約70%）
- クラウドサービス
- 組み込みシステム
- Android（Linuxベース）
- スーパーコンピューター

**関連用語:** OS、UNIX、シェル、コマンドライン、ターミナル

---

### 【M】

#### Microservices（マイクロサービス）

**読み方:** マイクロサービス  
**重要度:** ⭐⭐

➡️ **「マイクロサービス」を参照**（7.1 日本語用語の「ま行」）

---

#### MongoDB（モンゴDB / モンゴディービー）

**読み方:** モンゴディービー  
**重要度:** ⭐⭐

**意味:**
NoSQLデータベースの一種。JSONのような形式でデータを保存する。柔軟な構造で大量データに強い。

**RDB vs MongoDB:**

```mermaid
graph TD
    A[データベース] --> B[RDB<br/>リレーショナル]
    A --> C[MongoDB<br/>NoSQL]
    
    B --> B1[表形式<br/>固定スキーマ<br/>SQL使用<br/>厳密なデータ整合性]
    
    C --> C1[ドキュメント形式<br/>柔軟なスキーマ<br/>独自のクエリ言語<br/>水平スケール]
    
    style B fill:#e1f5fe,stroke:#0277bd
    style C fill:#c8e6c9,stroke:#2e7d32
```

**MongoDBのデータ構造:**

```javascript
// ドキュメント（1つのレコードに相当）
{
  "_id": "507f1f77bcf86cd799439011",
  "name": "田中太郎",
  "age": 30,
  "email": "tanaka@example.com",
  "skills": ["JavaScript", "Python", "React"],
  "address": {
    "city": "東京",
    "zipcode": "100-0001"
  }
}
```

**MongoDBの主な用語:**

| MongoDB用語 | RDB用語 | 説明 |
|-----------|---------|------|
| **Database** | Database | データベース |
| **Collection** | Table | コレクション（表） |
| **Document** | Row/Record | ドキュメント（行） |
| **Field** | Column | フィールド（列） |

**MongoDBの特徴:**

- スキーマレス（柔軟な構造）
- JSON形式で直感的
- 水平スケーリングが容易
- 大量データに強い
- 地理空間データのサポート

**MongoDBの用途:**

- コンテンツ管理システム
- リアルタイムデータ分析
- IoTデータの保存
- ログ管理
- ユーザープロファイル

**関連用語:** NoSQL、ドキュメント指向DB、JSON、スキーマレス

---

#### MVP（Minimum Viable Product / エムブイピー）

**読み方:** エムブイピー、最小実用製品  
**重要度:** ⭐⭐

**意味:**
最小限の機能だけを持つ製品。市場で検証するために、まず小さく作ってリリースする。

**MVPの考え方:**

```mermaid
graph LR
    A[❌ 従来の考え方] --> A1[完璧な製品を<br/>時間をかけて開発]
    A1 --> A2[リリース]
    A2 --> A3[市場に合わず<br/>大失敗]
    
    B[✅ MVP] --> B1[最小限の機能で<br/>素早くリリース]
    B1 --> B2[フィードバック<br/>収集]
    B2 --> B3[改善を繰り返す]
    B3 --> B4[成功する製品]
    
    style A fill:#ffcdd2,stroke:#c62828
    style B fill:#c8e6c9,stroke:#2e7d32
```

**MVPの例:**

```mermaid
graph TD
    A[Instagram の MVP] --> A1[写真投稿]
    A1 --> A2[フィルター加工]
    A2 --> A3[シェア機能]
    
    B[後から追加] --> B1[ストーリーズ]
    B --> B2[リール]
    B --> B3[ショッピング]
    B --> B4[DM]
    
    style A fill:#c8e6c9,stroke:#2e7d32
    style B fill:#fff9c4,stroke:#f57f17
```

**MVPのメリット:**

- 早く市場に出せる
- 開発コストが低い
- 実際のユーザーの声が聞ける
- 失敗してもダメージが小さい
- ピボット（方向転換）しやすい

**MVPを作るステップ:**

1. コア機能を特定
2. 最小限の機能だけ実装
3. 早くリリース
4. フィードバック収集
5. 改善・追加開発

**関連用語:** リーンスタートアップ、プロトタイプ、アジャイル開発

---

#### MySQL（マイエスキューエル）

**読み方:** マイエスキューエル  
**重要度:** ⭐⭐⭐

**意味:**
世界で最も人気のあるオープンソースのリレーショナルデータベース。無料で使え、Webアプリケーションで広く採用。

**主なRDBMS:**

| データベース | 読み方 | 特徴 | ライセンス |
|------------|--------|------|-----------|
| **MySQL** | マイエスキューエル | 速い、人気 | オープンソース |
| **PostgreSQL** | ポストグレスキューエル | 高機能、厳密 | オープンソース |
| **Oracle** | オラクル | 大規模、高機能 | 商用 |
| **SQL Server** | エスキューエルサーバー | Microsoft製 | 商用 |
| **SQLite** | エスキューライト | 軽量、組み込み | オープンソース |

**SQLの基本:**

```sql
-- データベース作成
CREATE DATABASE mydb;
USE mydb;

-- テーブル作成
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    email VARCHAR(100) UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- データ挿入
INSERT INTO users (name, email) 
VALUES ('田中太郎', 'tanaka@example.com');

-- データ取得
SELECT * FROM users;
SELECT name, email FROM users WHERE id = 1;

-- データ更新
UPDATE users SET name = '田中次郎' WHERE id = 1;

-- データ削除
DELETE FROM users WHERE id = 1;
```

**MySQLの特徴:**

- 高速
- 無料（オープンソース）
- 大規模サイトでも使われる
- 豊富なツール
- レプリケーション対応

**MySQLが使われている有名サービス:**

- Facebook
- Twitter
- YouTube
- Wikipedia
- WordPress

**関連用語:** SQL、RDB、データベース、PostgreSQL

---

### 【N】

#### Node.js（ノードジェーエス / ノードJS）

**読み方:** ノードジェーエス、ノードJS  
**重要度:** ⭐⭐⭐

**意味:**
JavaScriptをサーバーサイドで実行できる環境。フロントエンドとバックエンドを同じ言語で開発できる。

**Node.jsの特徴:**

```mermaid
graph TD
    A[Node.js の特徴] --> B[非同期I/O]
    A --> C[高速]
    A --> D[npm]
    A --> E[フロントエンド/バックエンド<br/>同じ言語]
    
    B --> B1[多くのリクエストを<br/>効率的に処理]
    C --> C1[V8エンジン<br/>Chromeと同じ]
    D --> D1[世界最大の<br/>パッケージ管理]
    E --> E1[JavaScriptだけで<br/>開発できる]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#c8e6c9,stroke:#2e7d32
    style C fill:#fff9c4,stroke:#f57f17
    style D fill:#f3e5f5,stroke:#7b1fa2
    style E fill:#fff3e0,stroke:#ef6c00
```

**Node.jsの例:**

```javascript
// 簡単なWebサーバー
const http = require('http');

const server = http.createServer((req, res) => {
    res.writeHead(200, {'Content-Type': 'text/plain'});
    res.end('Hello, World!');
});

server.listen(3000, () => {
    console.log('Server running at http://localhost:3000/');
});
```

**Node.jsの用途:**

- REST API
- リアルタイム通信（チャット）
- マイクロサービス
- ビルドツール
- CLI（コマンドラインツール）

**主なNode.jsフレームワーク:**

- **Express.js**: 最も人気のフレームワーク
- **NestJS**: TypeScript対応、大規模向け
- **Fastify**: 高速重視
- **Koa**: Express後継

**npm (Node Package Manager):**

- 世界最大のパッケージレジストリ
- 200万以上のパッケージ
- `npm install` でパッケージをインストール

**関連用語:** JavaScript、npm、Express、フロントエンド、バックエンド

---

#### NoSQL（ノーエスキューエル）

**読み方:** ノーエスキューエル  
**重要度:** ⭐⭐

**意味:**
SQLを使わないデータベースの総称。従来のRDB（リレーショナルデータベース）とは異なる柔軟な構造。

**NoSQLの種類:**

```mermaid
graph TD
    A[NoSQL の種類] --> B[ドキュメント指向]
    A --> C[キーバリュー]
    A --> D[カラム指向]
    A --> E[グラフ]
    
    B --> B1[MongoDB<br/>CouchDB]
    C --> C1[Redis<br/>DynamoDB]
    D --> D1[Cassandra<br/>HBase]
    E --> E1[Neo4j<br/>Amazon Neptune]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#c8e6c9,stroke:#2e7d32
    style C fill:#fff3e0,stroke:#ef6c00
    style D fill:#f3e5f5,stroke:#7b1fa2
    style E fill:#fff9c4,stroke:#f57f17
```

**RDB vs NoSQL:**

| 特徴 | RDB | NoSQL |
|------|-----|-------|
| **構造** | 固定スキーマ | 柔軟なスキーマ |
| **データ形式** | 表形式 | JSON、キーバリューなど |
| **スケール** | 垂直スケール | 水平スケール |
| **整合性** | ACID保証 | 結果整合性 |
| **用途** | トランザクション | 大量データ、高速読み書き |
| **例** | MySQL, PostgreSQL | MongoDB, Redis |

**NoSQLの用途:**

- ソーシャルメディア
- IoTデータ
- リアルタイム分析
- キャッシュ
- セッション管理

**関連用語:** MongoDB、Redis、DynamoDB、ドキュメント指向

---

### 【O】

#### OAuth（オーオース / Open Authorization）

**読み方:** オーオース、オープンオーソライゼーション  
**重要度:** ⭐⭐⭐

**意味:**
パスワードを渡さずに、他のサービスの認証を利用できる仕組み。「Googleでログイン」「Facebookでログイン」などで使われる。

**OAuthの仕組み:**

```mermaid
sequenceDiagram
    participant U as ユーザー
    participant A as あなたのアプリ
    participant G as Google
    
    U->>A: ログインボタンをクリック
    A->>G: 認証リクエスト
    G->>U: Googleのログイン画面
    U->>G: ログイン+許可
    G->>A: アクセストークン
    A->>G: トークンでユーザー情報取得
    G->>A: ユーザー情報
    A->>U: ログイン完了
```

**OAuthのメリット:**

- パスワードを渡さなくていい
- 実装が簡単
- ユーザーが信頼できるサービスでログイン
- 権限を細かく制御できる

**OAuth 2.0 の主な認可フロー:**

| フロー | 用途 | 説明 |
|--------|------|------|
| **Authorization Code** | Webアプリ | 最も安全 |
| **Implicit** | SPAアプリ | クライアント側のみ |
| **Resource Owner Password** | 信頼できるアプリ | ユーザー名/パスワード |
| **Client Credentials** | サーバー間通信 | アプリ自体の認証 |

**主要なOAuthプロバイダー:**

- Google
- Facebook
- GitHub
- Twitter
- Microsoft

**関連用語:** 認証、認可、SSO、OpenID Connect、JWT

---

#### OpenAPI（オープンAPI / OpenAPI Specification）

**読み方:** オープンAPI、オープンエーピーアイスペシフィケーション  
**重要度:** ⭐⭐

**意味:**
REST APIの仕様を記述するための標準フォーマット。APIの「設計図」を書くルール。

**OpenAPIの例:**

```yaml
openapi: 3.0.0
info:
  title: User API
  version: 1.0.0
paths:
  /users:
    get:
      summary: ユーザー一覧取得
      responses:
        '200':
          description: 成功
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/User'
  /users/{id}:
    get:
      summary: ユーザー詳細取得
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        '200':
          description: 成功
components:
  schemas:
    User:
      type: object
      properties:
        id:
          type: integer
        name:
          type: string
        email:
          type: string
```

**OpenAPIのメリット:**

- API仕様を標準化
- ドキュメントが自動生成できる
- クライアントコードを自動生成できる
- テストツールが使える

**OpenAPIツール:**

- **Swagger UI**: API仕様をブラウザで確認
- **Swagger Editor**: OpenAPIを編集
- **Swagger Codegen**: コード自動生成
- **Postman**: APIテスト

**旧名:** Swagger

**関連用語:** API、REST、Swagger、API設計

---

### 【P】

#### PostgreSQL（ポストグレスキューエル / ポストグレSQL）

**読み方:** ポストグレスキューエル、ポストグレSQL  
**重要度:** ⭐⭐⭐

**意味:**
高機能で信頼性の高いオープンソースのリレーショナルデータベース。エンタープライズ用途にも耐える品質。

**PostgreSQL vs MySQL:**

| 特徴 | PostgreSQL | MySQL |
|------|-----------|-------|
| **準拠** | SQL標準に忠実 | やや独自路線 |
| **機能** | 非常に豊富 | シンプル |
| **パフォーマンス** | 複雑な処理に強い | シンプルな処理に強い |
| **拡張性** | 高い | 中程度 |
| **JSON対応** | 優れている | 基本的 |
| **地理空間** | PostGIS拡張 | 標準サポート |

**PostgreSQLの特徴:**

- ACID準拠
- トランザクション処理に強い
- JSON/JSONBサポート
- 豊富なデータ型
- 拡張機能（PostGIS、pg_trgmなど）
- 高度なインデックス

**PostgreSQLが使われている有名サービス:**

- Instagram
- Spotify
- Uber
- Netflix
- Reddit

**PostG reSQL独自の機能:**

- **JSONB**: 効率的なJSON保存
- **配列型**: 配列をそのまま保存
- **全文検索**: 高度な検索機能
- **PostGIS**: 地理空間データ

**関連用語:** SQL、RDB、MySQL、データベース

---

#### Python（パイソン）

**読み方:** パイソン  
**重要度:** ⭐⭐⭐

**意味:**
読みやすく書きやすいプログラミング言語。機械学習、データ分析、Web開発など幅広く使われる。

**Pythonの特徴:**

```mermaid
graph TD
    A[Python の特徴] --> B[読みやすい]
    A --> C[豊富なライブラリ]
    A --> D[マルチパラダイム]
    A --> E[インタープリタ言語]
    
    B --> B1[インデントで構造を表現<br/>シンプルな文法]
    C --> C1[データ分析: Pandas<br/>機械学習: TensorFlow<br/>Web: Django, Flask]
    D --> D1[手続き型<br/>オブジェクト指向<br/>関数型]
    E --> E1[コンパイル不要<br/>すぐ実行できる]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
```

**Pythonの例:**

```python
# リスト操作
numbers = [1, 2, 3, 4, 5]
squared = [n ** 2 for n in numbers]
print(squared)  # [1, 4, 9, 16, 25]

# 関数定義
def greet(name):
    return f"Hello, {name}!"

print(greet("太郎"))  # Hello, 太郎!

# クラス定義
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def introduce(self):
        return f"私は{self.name}、{self.age}歳です"

person = Person("田中", 30)
print(person.introduce())
```

**Pythonの主な用途:**

- **機械学習・AI**: TensorFlow, PyTorch
- **データ分析**: Pandas, NumPy, Matplotlib
- **Web開発**: Django, Flask, FastAPI
- **自動化**: スクリプト、スクレイピング
- **科学計算**: SciPy

**主なPythonフレームワーク:**

- **Django**: フルスタックWebフレームワーク
- **Flask**: 軽量Webフレームワーク
- **FastAPI**: 高速API開発
- **Pandas**: データ分析
- **TensorFlow/PyTorch**: 機械学習

**Pythonのバージョン:**

- Python 2.x: 2020年サポート終了
- **Python 3.x**: 現在の主流（Python 3.9, 3.10, 3.11など）

**関連用語:** プログラミング言語、Django、Flask、機械学習

---

### 【Q】

#### QA（Quality Assurance / キューエー）

**読み方:** キューエー、品質保証  
**重要度:** ⭐⭐⭐

**意味:**
品質保証。ソフトウェアの品質を確保する活動全般。テストだけでなく、プロセス全体の品質を保証する。

**QAとテストの違い:**

```mermaid
graph TD
    A[QA vs テスト] --> B[QA<br/>品質保証]
    A --> C[テスト<br/>品質管理]
    
    B --> B1[プロセス全体<br/>予防的<br/>品質を作り込む]
    C --> C1[成果物の検証<br/>発見的<br/>不具合を見つける]
    
    style B fill:#c8e6c9,stroke:#2e7d32
    style C fill:#fff3e0,stroke:#ef6c00
```

**QAの活動:**

- プロセスの定義・改善
- 品質基準の策定
- レビューの実施
- テストの計画・実行
- メトリクスの収集・分析
- 継続的な改善

**品質保証のレベル:**

| レベル | 内容 | 活動例 |
|--------|------|--------|
| **予防** | バグを作らない | コーディング規約、設計レビュー |
| **検出** | バグを見つける | テスト、静的解析 |
| **修正** | バグを直す | デバッグ、パッチ適用 |

**QAエンジニアの役割:**

- テスト計画の作成
- テストケース設計
- テストの実行
- バグ報告
- 品質レポート作成

**関連用語:** テスト、品質管理、QC、バグ

---

### 【R】

#### React（リアクト）

**読み方:** リアクト  
**重要度:** ⭐⭐⭐

**意味:**
Meta (旧Facebook) が開発したJavaScriptライブラリ。Webアプリケーションのユーザーインターフェースを構築するために使われる。

**Reactの特徴:**

```mermaid
graph TD
    A[React の特徴] --> B[コンポーネントベース]
    A --> C[仮想DOM]
    A --> D[宣言的]
    A --> E[豊富なエコシステム]
    
    B --> B1[再利用可能な部品]
    C --> C1[高速な画面更新]
    D --> D1[読みやすいコード]
    E --> E1[Redux, Next.js など]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
```

**Reactの例:**

```jsx
// シンプルなコンポーネント
function Welcome({ name }) {
    return <h1>Hello, {name}!</h1>;
}

// ステート管理
import { useState } from 'react';

function Counter() {
    const [count, setCount] = useState(0);
    
    return (
        <div>
            <p>Count: {count}</p>
            <button onClick={() => setCount(count + 1)}>
                +1
            </button>
        </div>
    );
}

// リスト表示
function TodoList() {
    const todos = ['買い物', '掃除', '勉強'];
    
    return (
        <ul>
            {todos.map((todo, index) => (
                <li key={index}>{todo}</li>
            ))}
        </ul>
    );
}
```

**Reactの主な概念:**

- **コンポーネント**: 再利用可能なUI部品
- **JSX**: HTMLのような構文
- **State**: コンポーネントの状態
- **Props**: コンポーネントへの入力
- **Hooks**: 関数コンポーネントで状態管理

**Reactのエコシステム:**

- **Next.js**: SSR対応のReactフレームワーク
- **Redux**: 状態管理ライブラリ
- **React Router**: ルーティング
- **React Native**: モバイルアプリ開発

**Reactが使われているサービス:**

- Facebook
- Instagram
- Netflix
- Airbnb
- Uber

**関連用語:** JavaScript、JSX、コンポーネント、Next.js、Redux

---

#### Redis（レディス）

**読み方:** レディス  
**重要度:** ⭐⭐

**意味:**
高速なインメモリ型のキーバリューストア（KVS）。主にキャッシュやセッション管理に使われる。

**Redisの特徴:**

```mermaid
graph TD
    A[Redis の特徴] --> B[超高速]
    A --> C[メモリベース]
    A --> D[豊富なデータ型]
    A --> E[永続化可能]
    
    B --> B1[数十万ops/秒]
    C --> C1[全データをメモリに保存]
    D --> D1[String, List, Set<br/>Hash, Sorted Set]
    E --> E1[ディスクに保存可能]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
```

**Redisの例:**

```bash
# 文字列
SET user:1:name "田中太郎"
GET user:1:name

# リスト
LPUSH tasks "買い物"
LPUSH tasks "掃除"
LRANGE tasks 0 -1

# セット
SADD tags "Python"
SADD tags "Redis"
SMEMBERS tags

# ハッシュ
HSET user:1 name "田中太郎" age 30
HGET user:1 name

# 有効期限付き
SETEX session:abc 3600 "session_data"
```

**Redisの用途:**

- **キャッシュ**: データベースの負荷軽減
- **セッション管理**: ログイン状態の保存
- **リアルタイムランキング**: ゲームのスコアなど
- **Pub/Sub**: メッセージング
- **分散ロック**: 同時実行制御

**Redisのデータ型:**

| データ型 | 説明 | 用途 |
|---------|------|------|
| **String** | 文字列 | キャッシュ、カウンター |
| **List** | リスト | キュー、タイムライン |
| **Set** | 集合 | タグ、ユニーク値 |
| **Hash** | ハッシュ | オブジェクト保存 |
| **Sorted Set** | ソート済み集合 | ランキング、スコア |

**関連用語:** NoSQL、KVS、キャッシュ、インメモリDB

---

#### REST（Representational State Transfer / レスト）

**読み方:** レスト、表現状態転送  
**重要度:** ⭐⭐⭐

**意味:**
Web APIを設計する時の考え方・ルール。シンプルで分かりやすいAPIを作るための原則。

**RESTの6つの制約:**

1. **クライアント・サーバー**: 役割を分離
2. **ステートレス**: 状態を保持しない
3. **キャッシュ可能**: キャッシュできる
4. **統一インターフェース**: 一貫したルール
5. **階層化システム**: 中間層を挟める
6. **コードオンデマンド**: (オプション)

**RESTful APIの例:**

```
# ユーザー管理API
GET    /api/users         # ユーザー一覧取得
GET    /api/users/123     # ID=123のユーザー取得
POST   /api/users         # ユーザー作成
PUT    /api/users/123     # ID=123のユーザー更新
DELETE /api/users/123     # ID=123のユーザー削除

# 商品管理API
GET    /api/products      # 商品一覧取得
GET    /api/products/456  # ID=456の商品取得
POST   /api/products      # 商品作成
```

**HTTPメソッドの使い分け:**

| メソッド | 意味 | 冪等性 | 安全性 |
|---------|------|--------|--------|
| **GET** | 取得 | ✅ | ✅ |
| **POST** | 作成 | ❌ | ❌ |
| **PUT** | 更新(全体) | ✅ | ❌ |
| **PATCH** | 更新(一部) | ❌ | ❌ |
| **DELETE** | 削除 | ✅ | ❌ |

**良いREST APIの特徴:**

- 名詞を使う（動詞は使わない）
- 複数形を使う（/users ○、/user ✗）
- 階層構造を表現（/users/123/posts）
- HTTPステータスコードを適切に使う
- JSON形式でレスポンス

**関連用語:** API、HTTP、JSON、RESTful、GraphQL

---

#### RTM（Requirements Traceability Matrix / アールティーエム）

**読み方:** アールティーエム、要求トレーサビリティマトリクス  
**重要度:** ⭐⭐

**意味:**
要求から設計、実装、テストまでの対応関係を表にしたもの。「この要件はちゃんと実装されて、テストされているか」を追跡できる。

**RTMの例:**

| 要求ID | 要求名 | 設計書 | 実装 | テストケース | ステータス |
|--------|--------|--------|------|------------|-----------|
| REQ-001 | ユーザー登録 | DD-001 | User.java | TC-001, TC-002 | ✅完了 |
| REQ-002 | ログイン | DD-002 | Auth.java | TC-003, TC-004 | ✅完了 |
| REQ-003 | パスワードリセット | DD-003 | Reset.java | TC-005 | 🔄実装中 |
| REQ-004 | プロフィール編集 | DD-004 | Profile.java | TC-006, TC-007 | ⏸保留 |

**RTMの目的:**

- **完全性の確認**: 全ての要件が実装されているか
- **影響範囲の把握**: 変更の影響を追跡
- **監査証跡**: 規制対応のための記録
- **進捗管理**: 何ができていて何が残っているか

**RTMの種類:**

```mermaid
graph LR
    A[要求] --> B[設計]
    B --> C[実装]
    C --> D[テスト]
    
    A -.Forward Trace.-> D
    D -.Backward Trace.-> A
    
    style A fill:#c8e6c9,stroke:#2e7d32
    style D fill:#e1f5fe,stroke:#0277bd
```

**Forward Traceability（前方追跡）:**

- 要求 → 設計 → 実装 → テスト
- 「この要件は実装されているか？」

**Backward Traceability（後方追跡）:**

- テスト → 実装 → 設計 → 要求
- 「このテストはどの要件に対応しているか？」

➡️ **詳しくは**: 第4章4.5参照

**関連用語:** トレーサビリティ、要件管理、テスト管理

---

### 【S】

#### SaaS（Software as a Service / サース）

**読み方:** サース、ソフトウェアアズアサービス  
**重要度:** ⭐⭐⭐

**意味:**
インターネット経由でソフトウェアを提供するサービス。自分でインストールせずに、ブラウザで使える。

**クラウドサービスの分類:**

```mermaid
graph TD
    A[クラウドサービス] --> B[SaaS<br/>Software as a Service]
    A --> C[PaaS<br/>Platform as a Service]
    A --> D[IaaS<br/>Infrastructure as a Service]
    
    B --> B1[アプリケーションを提供<br/>Gmail, Salesforce, Slack]
    C --> C1[開発環境を提供<br/>Heroku, Google App Engine]
    D --> D1[インフラを提供<br/>AWS EC2, Azure]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#c8e6c9,stroke:#2e7d32
    style C fill:#fff9c4,stroke:#f57f17
    style D fill:#fff3e0,stroke:#ef6c00
```

**有名なSaaSサービス:**

| カテゴリ | サービス | 用途 |
|---------|---------|------|
| **メール** | Gmail | メール |
| **コミュニケーション** | Slack, Microsoft Teams | チャット |
| **CRM** | Salesforce | 顧客管理 |
| **ストレージ** | Dropbox, Google Drive | ファイル保存 |
| **プロジェクト管理** | Jira, Asana, Trello | タスク管理 |
| **会計** | freee, MFクラウド | 経理・会計 |
| **グループウェア** | Google Workspace | 業務ツール |

**SaaSのメリット:**

- インストール不要
- どこからでもアクセス
- 自動アップデート
- 初期費用が安い
- スケールしやすい

**SaaSのデメリット:**

- インターネット必須
- カスタマイズに制限
- データの所在
- ベンダーロックイン

**関連用語:** クラウド、PaaS、IaaS、サブスクリプション

---

#### SQL（Structured Query Language / エスキューエル）

**読み方:** エスキューエル、シーケル、構造化問い合わせ言語  
**重要度:** ⭐⭐⭐

**意味:**
データベースを操作するための言語。データの取得、追加、更新、削除を行う。

**SQLの基本操作（CRUD）:**

```sql
-- Create（作成）
INSERT INTO users (name, email) 
VALUES ('田中太郎', 'tanaka@example.com');

-- Read（読み取り）
SELECT * FROM users;
SELECT name, email FROM users WHERE age >= 20;
SELECT * FROM users ORDER BY age DESC LIMIT 10;

-- Update（更新）
UPDATE users SET age = 31 WHERE id = 1;

-- Delete（削除）
DELETE FROM users WHERE id = 1;
```

**SQLの主な機能:**

| 機能 | コマンド | 説明 |
|------|---------|------|
| **データ定義** | CREATE, ALTER, DROP | テーブル作成・変更・削除 |
| **データ操作** | SELECT, INSERT, UPDATE, DELETE | データの取得・追加・更新・削除 |
| **データ制御** | GRANT, REVOKE | 権限管理 |
| **トランザクション** | BEGIN, COMMIT, ROLLBACK | 一貫性の保証 |

**便利なSQL機能:**

```sql
-- 集計
SELECT COUNT(*) FROM users;
SELECT AVG(age) FROM users;
SELECT MAX(age), MIN(age) FROM users;

-- グループ化
SELECT department, COUNT(*) 
FROM users 
GROUP BY department;

-- 結合
SELECT u.name, o.product
FROM users u
INNER JOIN orders o ON u.id = o.user_id;

-- サブクエリ
SELECT name 
FROM users 
WHERE age > (SELECT AVG(age) FROM users);
```

**主なSQLデータベース:**

- MySQL
- PostgreSQL
- Oracle Database
- SQL Server
- SQLite

**関連用語:** データベース、RDB、クエリ、テーブル

---

#### SRS（Software Requirements Specification / エスアールエス）

**読み方:** エスアールエス、ソフトウェア要求仕様書  
**重要度:** ⭐⭐⭐

**意味:**
システムが「何をするべきか」を詳しく書いた文書。開発の設計図となる最重要ドキュメント。

**SRSの主な内容:**

1. **はじめに**
   - 目的、スコープ、定義、参照文書

2. **全体説明**
   - 製品の視点、機能、ユーザー特性、制約条件

3. **機能要件**
   - 各機能の詳細仕様

4. **非機能要件**
   - 性能、セキュリティ、信頼性など

5. **インターフェース要件**
   - ユーザーIF、ハードウェアIF、ソフトウェアIF

**良いSRSの特性（IEEE 29148）:**

| 特性 | 説明 |
|------|------|
| **明確性** | 1つの解釈のみ可能 |
| **完全性** | 全ての要件を含む |
| **一貫性** | 矛盾がない |
| **検証可能性** | テストで確認できる |
| **追跡可能性** | 要件の出所が分かる |
| **優先順位付け** | 重要度が明確 |

**SRSの例（抜粋）:**

```markdown
## 3.1 ユーザー登録機能

### 3.1.1 機能要件
FR-001: システムは、ユーザーが以下の情報を入力して
        アカウントを作成できなければならない：
        - メールアドレス（必須）
        - パスワード（必須、8文字以上）
        - 氏名（必須）
        - 電話番号（任意）

### 3.1.2 非機能要件
NFR-001: ユーザー登録処理は3秒以内に完了しなければならない。
NFR-002: パスワードは暗号化して保存しなければならない。

### 3.1.3 制約条件
CON-001: メールアドレスは一意でなければならない。
```

➡️ **詳しくは**: 第4章4.1参照

**関連用語:** 要件定義、機能要件、非機能要件、要求仕様書

---

#### SSL/TLS（Secure Sockets Layer / Transport Layer Security）

**読み方:** エスエスエル / ティーエルエス  
**重要度:** ⭐⭐⭐

**意味:**
インターネット通信を暗号化するプロトコル。HTTPSの「S」がこれに当たる。

**SSL/TLSの役割:**

```mermaid
graph LR
    A[ブラウザ] -->|暗号化された通信| B[サーバー]
    
    A --> A1[🔒データを暗号化<br/>盗聴防止]
    B --> B1[🔒データを復号化<br/>安全な通信]
    
    style A fill:#c8e6c9,stroke:#2e7d32
    style B fill:#e1f5fe,stroke:#0277bd
```

**SSL vs TLS:**

- **SSL**: 古い規格（SSL 3.0まで、現在は非推奨）
- **TLS**: 新しい規格（TLS 1.2, TLS 1.3が現在の主流）

**HTTPS通信の流れ:**

1. クライアントがサーバーに接続
2. サーバーが証明書を送信
3. クライアントが証明書を検証
4. 暗号化キーを交換
5. 暗号化通信開始

**SSL/TLS証明書:**

| 種類 | 検証レベル | 用途 | 取得時間 |
|------|----------|------|---------|
| **DV証明書** | ドメイン所有確認のみ | 個人サイト | 数分 |
| **OV証明書** | 組織の実在確認 | 企業サイト | 数日 |
| **EV証明書** | 厳格な審査 | 金融機関 | 数週間 |

**無料のSSL証明書:**

- **Let's Encrypt**: 最も有名な無料SSL
- **Cloudflare SSL**: Cloudflareユーザー向け

**関連用語:** HTTPS、暗号化、証明書、セキュリティ

---

### 【T】

#### TCP/IP（Transmission Control Protocol / Internet Protocol）

**読み方:** ティーシーピーアイピー  
**重要度:** ⭐⭐

**意味:**
インターネットで使われる通信プロトコルの集まり。データを確実に送受信するための仕組み。

**TCP/IPの階層:**

```mermaid
graph TD
    A[アプリケーション層] --> A1[HTTP, FTP, SMTP]
    B[トランスポート層] --> B1[TCP, UDP]
    C[インターネット層] --> C1[IP, ICMP]
    D[ネットワーク<br/>インターフェース層] --> D1[Ethernet, Wi-Fi]
    
    A --> B
    B --> C
    C --> D
    
    style A fill:#c8e6c9,stroke:#2e7d32
    style B fill:#fff9c4,stroke:#f57f17
    style C fill:#e1f5fe,stroke:#0277bd
    style D fill:#f3e5f5,stroke:#7b1fa2
```

**TCP vs UDP:**

| 特徴 | TCP | UDP |
|------|-----|-----|
| **信頼性** | 高い（再送あり） | 低い（再送なし） |
| **速度** | 遅い | 速い |
| **用途** | Webブラウジング、メール | 動画配信、ゲーム |
| **接続** | コネクション型 | コネクションレス |

**IPアドレス:**

- **IPv4**: 192.168.1.1（32ビット、約43億個）
- **IPv6**: 2001:0db8:85a3::8a2e:0370:7334（128ビット、事実上無限）

**関連用語:** プロトコル、IP、HTTP、ネットワーク

---

#### TypeScript（タイプスクリプト）

**読み方:** タイプスクリプト  
**重要度:** ⭐⭐⭐

**意味:**
JavaScriptに型システムを追加したプログラミング言語。Microsoftが開発。大規模開発で人気。

**JavaScriptとTypeScriptの違い:**

```mermaid
graph TD
    A[JavaScript] --> A1[動的型付け<br/>実行時にエラー<br/>小規模向き]
    
    B[TypeScript] --> B1[静的型付け<br/>コンパイル時にエラー<br/>大規模向き]
    
    style A fill:#fff9c4,stroke:#f57f17
    style B fill:#c8e6c9,stroke:#2e7d32
```

**TypeScriptの例:**

```typescript
// 型を指定
let name: string = "田中太郎";
let age: number = 30;
let isActive: boolean = true;

// 関数の型
function greet(name: string): string {
    return `Hello, ${name}!`;
}

// インターフェース
interface User {
    id: number;
    name: string;
    email: string;
    age?: number;  // オプショナル
}

const user: User = {
    id: 1,
    name: "田中太郎",
    email: "tanaka@example.com"
};

// ジェネリクス
function getArray<T>(items: T[]): T[] {
    return items;
}

const numbers = getArray<number>([1, 2, 3]);
const strings = getArray<string>(["a", "b", "c"]);
```

**TypeScriptのメリット:**

- バグを早期に発見
- IDEの補完機能が強力
- リファクタリングが安全
- 大規模開発に向いている
- ドキュメントとしても機能

**TypeScriptの使用例:**

- **Angular**: TypeScriptで書かれている
- **React**: TypeScript対応
- **Vue.js**: TypeScript対応
- **Node.js**: TypeScript対応

**関連用語:** JavaScript、静的型付け、コンパイル、型システム

---

### 【U】

#### UI（User Interface / ユーアイ）

**読み方:** ユーアイ、ユーザーインターフェース  
**重要度:** ⭐⭐⭐

**意味:**
ユーザーとシステムの接点。画面、ボタン、メニューなど、ユーザーが見て操作する部分。

**UIの種類:**

```mermaid
graph TD
    A[UI の種類] --> B[GUI<br/>Graphical UI]
    A --> C[CUI<br/>Command UI]
    A --> D[VUI<br/>Voice UI]
    A --> E[TUI<br/>Touch UI]
    
    B --> B1[グラフィカルな画面<br/>Windows, macOS]
    C --> C1[コマンドライン<br/>ターミナル]
    D --> D1[音声操作<br/>Alexa, Siri]
    E --> E1[タッチ操作<br/>スマホ、タブレット]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
```

**良いUIの特徴:**

| 原則 | 説明 | 例 |
|------|------|-----|
| **明確性** | 何ができるか分かりやすい | ボタンにラベル |
| **一貫性** | 同じ操作で同じ結果 | 統一されたデザイン |
| **フィードバック** | 操作の結果を示す | ローディング表示 |
| **効率性** | 少ない操作で目的達成 | ショートカット |
| **エラー防止** | ミスを防ぐ | 確認ダイアログ |
| **柔軟性** | 初心者も上級者も使える | デフォルト値 |

**UIとUXの違い:**

- **UI (User Interface)**: 見た目、操作方法
- **UX (User Experience)**: 使った時の体験全体

**関連用語:** UX、デザイン、フロントエンド、ユーザビリティ

---

#### UML（Unified Modeling Language / ユーエムエル）

**読み方:** ユーエムエル、統一モデリング言語  
**重要度:** ⭐⭐

**意味:**
システムの設計を図で表現するための標準的な記法。クラス図、シーケンス図など様々な図がある。

**主なUML図:**

| 図の種類 | 用途 | 説明 |
|---------|------|------|
| **クラス図** | 構造 | クラスの関係を表現 |
| **シーケンス図** | 振る舞い | 処理の流れを時系列で表現 |
| **ユースケース図** | 要件 | 機能とユーザーの関係 |
| **アクティビティ図** | 振る舞い | 処理のフローチャート |
| **状態遷移図** | 振る舞い | 状態の変化を表現 |
| **コンポーネント図** | 構造 | システムの構成要素 |
| **配置図** | 構造 | 物理的な配置 |

**クラス図の例:**

```
┌─────────────────┐
│     User        │
├─────────────────┤
│ - id: int       │
│ - name: string  │
│ - email: string │
├─────────────────┤
│ + login()       │
│ + logout()      │
└─────────────────┘
```

**シーケンス図の例:**

```
ユーザー  →  システム  →  データベース
   │          │            │
   │ ログイン  │            │
   ├─────────>│            │
   │          │ ユーザー確認│
   │          ├───────────>│
   │          │            │
   │          │<───────────┤
   │ 結果表示  │            │
   │<─────────┤            │
```

**UMLツール:**

- **PlantUML**: テキストから図を生成
- **Lucidchart**: オンラインで図を作成
- **draw.io**: 無料の図作成ツール
- **Enterprise Architect**: プロ向けツール

➡️ **詳しくは**: 第5章5.2参照

**関連用語:** 設計、モデリング、図、ダイアグラム

---

#### URL（Uniform Resource Locator / ユーアールエル）

**読み方:** ユーアールエル、ユニフォームリソースロケーター  
**重要度:** ⭐⭐⭐

**意味:**
インターネット上のリソース（Webページ、画像など）の場所を示す文字列。「住所」のようなもの。

**URLの構造:**

```
https://www.example.com:443/path/to/page?key=value#section
  │      │       │         │     │         │         │
  │      │       │         │     │         │         └─ フラグメント（ページ内の位置）
  │      │       │         │     │         └─ クエリパラメータ
  │      │       │         │     └─ パス（どのページか）
  │      │       │         └─ ポート番号
  │      │       └─ ドメイン
  │      └─ サブドメイン
  └─ スキーム（プロトコル）
```

**主なスキーム:**

| スキーム | 用途 | 例 |
|---------|------|-----|
| **http://** | Web（暗号化なし） | <http://example.com> |
| **https://** | Web（暗号化あり） | <https://example.com> |
| **ftp://** | ファイル転送 | ftp://ftp.example.com |
| **mailto:** | メール | mailto:info@example.com |
| **file://** | ローカルファイル | file:///C:/Users/file.txt |

**クエリパラメータの例:**

```
https://search.example.com/search?q=検索ワード&page=2&lang=ja
                                  │                      │
                                  └─ 検索ワード          └─ 言語設定
```

**URLエンコーディング:**

- 日本語などの特殊文字は`%`で始まる形式に変換
- 例: `検索` → `%E6%A4%9C%E7%B4%A2`

**関連用語:** URI、HTTP、ドメイン、パス

---

#### UX（User Experience / ユーエックス）

**読み方:** ユーエックス、ユーザーエクスペリエンス  
**重要度:** ⭐⭐⭐

**意味:**
ユーザーが製品やサービスを使う時の体験全体。使いやすさ、満足度、感情なども含む。

**UIとUXの違い:**

```mermaid
graph TD
    A[製品] --> B[UI<br/>User Interface]
    A --> C[UX<br/>User Experience]
    
    B --> B1[見た目<br/>操作方法<br/>ボタン、色、レイアウト]
    
    C --> C1[体験全体<br/>使いやすさ<br/>満足度、感情]
    
    style B fill:#e1f5fe,stroke:#0277bd
    style C fill:#c8e6c9,stroke:#2e7d32
```

**UXの5つの要素:**

```mermaid
graph TD
    A[UX の5要素] --> B[戦略<br/>Strategy]
    B --> C[範囲<br/>Scope]
    C --> D[構造<br/>Structure]
    D --> E[骨格<br/>Skeleton]
    E --> F[表層<br/>Surface]
    
    B --> B1[目的、ユーザーニーズ]
    C --> C1[機能要件、コンテンツ]
    D --> D1[情報設計、ナビゲーション]
    E --> E1[ワイヤーフレーム]
    F --> F1[ビジュアルデザイン]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
```

**良いUXの例:**

- **Amazon 1-Click**: 1クリックで注文完了
- **Google検索**: シンプルで速い
- **Netflix**: おすすめが的確
- **Uber**: 直感的な配車

**悪いUXの例:**

- 複雑な登録フォーム
- 遅いローディング
- 分かりにくいナビゲーション
- エラーメッセージが不親切

**UXデザインのプロセス:**

1. **調査**: ユーザーを理解する
2. **分析**: 課題を見つける
3. **設計**: 解決策を考える
4. **プロトタイプ**: 試作品を作る
5. **テスト**: ユーザーに試してもらう
6. **改善**: フィードバックを反映

**関連用語:** UI、ユーザビリティ、デザイン思考、ペルソナ

---

### 【V】

#### VPN（Virtual Private Network / ブイピーエヌ）

**読み方:** ブイピーエヌ、仮想プライベートネットワーク  
**重要度:** ⭐⭐

**意味:**
インターネット上に仮想的な専用回線を作る技術。安全に通信できる。

**VPNの仕組み:**

```mermaid
graph LR
    A[自宅PC] -->|暗号化| B[VPNサーバー]
    B -->|復号化| C[会社のネットワーク]
    
    A --> A1[🔒 通信を暗号化]
    C --> C1[🔓 安全にアクセス]
    
    style A fill:#c8e6c9,stroke:#2e7d32
    style B fill:#fff9c4,stroke:#f57f17
    style C fill:#e1f5fe,stroke:#0277bd
```

**VPNの用途:**

- リモートワーク（会社のネットワークに安全にアクセス）
- セキュリティ強化（公衆Wi-Fiでも安全）
- 地域制限の回避（海外のサービスにアクセス）

**主なVPNプロトコル:**

- **IPsec**: 最も安全
- **OpenVPN**: オープンソース
- **L2TP**: 広く使われる
- **WireGuard**: 新しく高速

**関連用語:** ネットワーク、セキュリティ、リモートアクセス

---

---

## 7.3 略語一覧

システム開発でよく使われる略語をまとめました。

| 略語 | 正式名称 | 読み方 | 意味 |
|------|---------|--------|------|
| **AD** | Architecture Description | アーキテクチャデスクリプション | アーキテクチャ記述書 |
| **ADR** | Architecture Decision Record | アーキテクチャデシジョンレコード | 設計決定記録 |
| **AI** | Artificial Intelligence | エーアイ | 人工知能 |
| **API** | Application Programming Interface | エーピーアイ | アプリケーションプログラミングインターフェース |
| **AWS** | Amazon Web Services | エーダブリューエス | アマゾンウェブサービス |
| **BPMN** | Business Process Model and Notation | ビーピーエムエヌ | ビジネスプロセスモデリング記法 |
| **CDN** | Content Delivery Network | シーディーエヌ | コンテンツデリバリーネットワーク |
| **CI/CD** | Continuous Integration/Continuous Delivery | シーアイシーディー | 継続的インテグレーション/継続的デリバリー |
| **CLI** | Command Line Interface | シーエルアイ | コマンドラインインターフェース |
| **CMS** | Content Management System | シーエムエス | コンテンツ管理システム |
| **CORS** | Cross-Origin Resource Sharing | コルス | オリジン間リソース共有 |
| **CRUD** | Create, Read, Update, Delete | クラッド | 作成、読み取り、更新、削除 |
| **CSS** | Cascading Style Sheets | シーエスエス | カスケーディングスタイルシート |
| **CSV** | Comma-Separated Values | シーエスブイ | カンマ区切り値 |
| **DB** | Database | ディービー | データベース |
| **DBMS** | Database Management System | ディービーエムエス | データベース管理システム |
| **DDD** | Domain-Driven Design | ディーディーディー | ドメイン駆動設計 |
| **DNS** | Domain Name System | ディーエヌエス | ドメインネームシステム |
| **DOM** | Document Object Model | ディーオーエム | ドキュメントオブジェクトモデル |
| **EC2** | Elastic Compute Cloud | イーシーツー | エラスティックコンピュートクラウド |
| **FTP** | File Transfer Protocol | エフティーピー | ファイル転送プロトコル |
| **GCP** | Google Cloud Platform | ジーシーピー | グーグルクラウドプラットフォーム |
| **GUI** | Graphical User Interface | ジーユーアイ | グラフィカルユーザーインターフェース |
| **HTML** | HyperText Markup Language | エイチティーエムエル | ハイパーテキストマークアップ言語 |
| **HTTP** | HyperText Transfer Protocol | エイチティーティーピー | ハイパーテキスト転送プロトコル |
| **HTTPS** | HTTP Secure | エイチティーティーピーエス | セキュアHTTP |
| **IaaS** | Infrastructure as a Service | イアース | サービスとしてのインフラ |
| **IDE** | Integrated Development Environment | アイディーイー | 統合開発環境 |
| **IoT** | Internet of Things | アイオーティー | モノのインターネット |
| **IP** | Internet Protocol | アイピー | インターネットプロトコル |
| **ISO** | International Organization for Standardization | アイエスオー | 国際標準化機構 |
| **JSON** | JavaScript Object Notation | ジェイソン | ジャバスクリプトオブジェクト記法 |
| **JWT** | JSON Web Token | ジェイダブリュティー | JSON ウェブトークン |
| **K8s** | Kubernetes | ケーエイトス | クーバネティス |
| **KPI** | Key Performance Indicator | ケーピーアイ | 重要業績評価指標 |
| **KVS** | Key-Value Store | ケーブイエス | キーバリューストア |
| **ML** | Machine Learning | エムエル | 機械学習 |
| **MVC** | Model-View-Controller | エムブイシー | モデル・ビュー・コントローラ |
| **MVP** | Minimum Viable Product | エムブイピー | 最小実用製品 |
| **NoSQL** | Not only SQL | ノーエスキューエル | SQLだけではない |
| **ORM** | Object-Relational Mapping | オーアールエム | オブジェクトリレーショナルマッピング |
| **OS** | Operating System | オーエス | オペレーティングシステム |
| **PaaS** | Platform as a Service | パース | サービスとしてのプラットフォーム |
| **QA** | Quality Assurance | キューエー | 品質保証 |
| **RDBMS** | Relational Database Management System | アールディービーエムエス | リレーショナルデータベース管理システム |
| **REST** | Representational State Transfer | レスト | 表現状態転送 |
| **RFP** | Request for Proposal | アールエフピー | 提案依頼書 |
| **RTM** | Requirements Traceability Matrix | アールティーエム | 要求トレーサビリティマトリクス |
| **S3** | Simple Storage Service | エススリー | シンプルストレージサービス |
| **SaaS** | Software as a Service | サース | サービスとしてのソフトウェア |
| **SDK** | Software Development Kit | エスディーケー | ソフトウェア開発キット |
| **SEO** | Search Engine Optimization | エスイーオー | 検索エンジン最適化 |
| **SLA** | Service Level Agreement | エスエルエー | サービスレベル合意 |
| **SLI** | Service Level Indicator | エスエルアイ | サービスレベル指標 |
| **SLO** | Service Level Objective | エスエルオー | サービスレベル目標 |
| **SMTP** | Simple Mail Transfer Protocol | エスエムティーピー | シンプルメール転送プロトコル |
| **SPA** | Single Page Application | エスピーエー | シングルページアプリケーション |
| **SQL** | Structured Query Language | エスキューエル | 構造化問い合わせ言語 |
| **SRE** | Site Reliability Engineering | エスアールイー | サイト信頼性エンジニアリング |
| **SRS** | Software Requirements Specification | エスアールエス | ソフトウェア要求仕様書 |
| **SSH** | Secure Shell | エスエスエイチ | セキュアシェル |
| **SSL** | Secure Sockets Layer | エスエスエル | セキュアソケットレイヤー |
| **TCP** | Transmission Control Protocol | ティーシーピー | 伝送制御プロトコル |
| **TDD** | Test-Driven Development | ティーディーディー | テスト駆動開発 |
| **TLS** | Transport Layer Security | ティーエルエス | トランスポートレイヤーセキュリティ |
| **UAT** | User Acceptance Test | ユーエーティー | ユーザー受入テスト |
| **UDP** | User Datagram Protocol | ユーディーピー | ユーザーデータグラムプロトコル |
| **UI** | User Interface | ユーアイ | ユーザーインターフェース |
| **UML** | Unified Modeling Language | ユーエムエル | 統一モデリング言語 |
| **URI** | Uniform Resource Identifier | ユーアールアイ | 統一資源識別子 |
| **URL** | Uniform Resource Locator | ユーアールエル | 統一資源位置指定子 |
| **UX** | User Experience | ユーエックス | ユーザーエクスペリエンス |
| **VM** | Virtual Machine | ブイエム | 仮想マシン |
| **VPN** | Virtual Private Network | ブイピーエヌ | 仮想プライベートネットワーク |
| **WYSIWYG** | What You See Is What You Get | ウィジウィグ | 見たままが得られる |
| **XML** | Extensible Markup Language | エックスエムエル | 拡張可能マークアップ言語 |
| **XP** | Extreme Programming | エクストリームプログラミング | エクストリーム・プログラミング |
| **YAML** | YAML Ain't Markup Language | ヤムル | YAMLはマークアップ言語ではない |

---

## 第7章のまとめ

本章では、システム開発で使用される**完全用語集**を提供しました。

### 7.1 日本語用語（あいうえお順）

- システム開発の基礎用語から実務で使う専門用語まで網羅
- 具体例と関連用語で理解を深められる構成
- 重要度を★マークで表示

### 7.2 アルファベット用語

- A〜Vまでの主要な技術用語を詳細に解説
- AWS、GCP、Dockerなどの固有名詞も詳しく説明
- 英語表記にはカタカナの読み方を併記

### 7.3 略語一覧

- システム開発でよく使われる略語を網羅
- 正式名称、読み方、意味を一覧表で整理
- 辞書として活用できる

**この用語集の使い方:**

- 📖 分からない用語が出てきたら、すぐにこの章を参照
- 🔍 Ctrl+F (Cmd+F) で検索すると便利
- 💡 関連用語も一緒に読むと理解が深まる
- 📚 定期的に読み返すことで知識が定着

次の第8章では、**実践テンプレート集**を提供します。実際の業務で使えるドキュメントのテンプレートを多数用意していますので、ぜひ活用してください！

---

# 第8章:実践テンプレート集

この章では、**実際の業務ですぐに使える**ドキュメントテンプレートを提供します。各テンプレートは実務での使用を想定し、必要な項目を網羅しています。

## 📋 第8章の構成

```mermaid
graph TD
    A[第8章<br/>実践テンプレート集] --> B[8.1 SRSテンプレート]
    A --> C[8.2 基本設計書テンプレート]
    A --> D[8.3 詳細設計書テンプレート]
    A --> E[8.4 テスト仕様書テンプレート]
    A --> F[8.5 その他のテンプレート]
    
    B --> B1[要求仕様書の<br/>完全フォーム]
    C --> C1[アーキテクチャ<br/>設計書]
    D --> D1[機能詳細<br/>設計書]
    E --> E1[テスト計画・<br/>ケース]
    F --> F1[各種ドキュメント<br/>テンプレート]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#f3e5f5,stroke:#7b1fa2
    style D fill:#e8f5e9,stroke:#2e7d32
    style E fill:#fff9c4,stroke:#f57f17
    style F fill:#fce4ec,stroke:#c2185b
```

### 🎯 この章で得られること

| 項目 | 内容 |
|------|------|
| **即座に使える** | コピー&ペーストで利用可能なテンプレート |
| **実務準拠** | 実際のプロジェクトで使用されている形式 |
| **カスタマイズ可能** | プロジェクトに応じて柔軟に変更可能 |
| **充実した記入例** | 具体的な記入例で理解を促進 |
| **チェックリスト付き** | 記入漏れを防ぐためのチェック機能 |

---

## 8.1 SRSテンプレート(空フォーム)

**重要度:** ★★★★★ (最重要)

SRS(Software Requirements Specification: ソフトウェア要求仕様書)は、システム開発における最も重要なドキュメントです。

### 📄 SRSテンプレートの全体構成

```mermaid
graph TD
    A[SRS<br/>要求仕様書] --> B[1. 概要セクション]
    A --> C[2. 機能要件セクション]
    A --> D[3. 非機能要件セクション]
    A --> E[4. 外部インターフェース]
    A --> F[5. 制約条件]
    
    B --> B1[目的・スコープ・<br/>用語定義]
    C --> C1[ユースケース・<br/>機能一覧]
    D --> D1[性能・信頼性・<br/>セキュリティ]
    E --> E1[UI・API・<br/>外部システム]
    F --> F1[技術制約・<br/>ビジネス制約]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#f3e5f5,stroke:#7b1fa2
    style D fill:#e8f5e9,stroke:#2e7d32
    style E fill:#fff9c4,stroke:#f57f17
    style F fill:#fce4ec,stroke:#c2185b
```

---

### 📋 SRSテンプレート(完全版)

以下は、実際の業務で使用できるSRSの完全なテンプレートです。プロジェクトに合わせてカスタマイズしてください。

```markdown
# ソフトウェア要求仕様書(SRS)
# Software Requirements Specification

---

## ドキュメント管理情報

| 項目 | 内容 |
|------|------|
| **文書番号** | SRS-[プロジェクト名]-001 |
| **文書名** | [システム名] ソフトウェア要求仕様書 |
| **バージョン** | 1.0 |
| **作成日** | YYYY/MM/DD |
| **最終更新日** | YYYY/MM/DD |
| **作成者** | [氏名・所属] |
| **承認者** | [氏名・所属] |
| **配布先** | [配布先リスト] |
| **機密区分** | [社外秘/部外秘/公開] |

### 変更履歴

| バージョン | 日付 | 変更者 | 変更内容 |
|-----------|------|--------|----------|
| 0.1 | YYYY/MM/DD | [氏名] | 初版作成 |
| 0.2 | YYYY/MM/DD | [氏名] | レビュー指摘事項反映 |
| 1.0 | YYYY/MM/DD | [氏名] | 正式版リリース |

---

## 1. 概要

### 1.1 目的

#### 1.1.1 文書の目的
本文書は、[システム名]の開発に必要なソフトウェア要求を定義し、以下の関係者間で合意を形成することを目的とする。

**対象読者:**
- 👥 プロジェクトマネージャー
- 💻 開発チーム(設計者・プログラマー)
- 🧪 テストチーム
- 💼 ビジネスステークホルダー
- 📊 システム運用チーム

#### 1.1.2 システムの目的
[このシステムが解決する課題や達成する目標を記述]

**現状の課題:**
- [課題1の説明]
- [課題2の説明]
- [課題3の説明]

**システム導入後の期待効果:**
- [効果1の説明]
- [効果2の説明]
- [効果3の説明]

### 1.2 スコープ

#### 1.2.1 システムのスコープ(範囲)
[このシステムが対象とする範囲を明確に定義]

**含まれる機能:**
- [機能1]
- [機能2]
- [機能3]

**含まれない機能(対象外):**
- [対象外の機能1]
- [対象外の機能2]
- [対象外の機能3]

#### 1.2.2 プロジェクトのスコープ
- **フェーズ1:** [内容と期間]
- **フェーズ2:** [内容と期間]
- **フェーズ3:** [内容と期間]

### 1.3 用語定義・略語

| 用語/略語 | 正式名称 | 定義 |
|----------|---------|------|
| [用語1] | [正式名称] | [定義の説明] |
| [用語2] | [正式名称] | [定義の説明] |
| [略語1] | [正式名称] | [定義の説明] |

### 1.4 参照文書

| 文書名 | 文書番号 | バージョン | 備考 |
|--------|---------|-----------|------|
| [文書名1] | [番号] | [Ver] | [備考] |
| [文書名2] | [番号] | [Ver] | [備考] |

### 1.5 概要

#### 1.5.1 システム概要
[システム全体の概要を2-3段落で記述]

#### 1.5.2 システム構成図
```

[システムの構成図をここに挿入]

- ユーザー層
- アプリケーション層
- データ層
- 外部システム連携

```

---

## 2. 全体記述

### 2.1 製品の展望

#### 2.1.1 製品の視点
[このシステムが全体の中でどのような位置づけにあるか]

#### 2.1.2 製品の機能
[主要な機能を簡潔に列挙]
1. [機能1の概要]
2. [機能2の概要]
3. [機能3の概要]

#### 2.1.3 ユーザークラスと特性

| ユーザークラス | 説明 | 技術レベル | 利用頻度 |
|--------------|------|-----------|---------|
| [ユーザー種別1] | [説明] | [高/中/低] | [毎日/週数回/月数回] |
| [ユーザー種別2] | [説明] | [高/中/低] | [毎日/週数回/月数回] |

#### 2.1.4 動作環境
**サーバー環境:**
- OS: [OS名とバージョン]
- CPU: [スペック]
- メモリ: [容量]
- ストレージ: [容量]

**クライアント環境:**
- OS: [対応OS]
- ブラウザ: [対応ブラウザとバージョン]
- 画面解像度: [推奨解像度]
- ネットワーク: [要件]

#### 2.1.5 設計と実装の制約
**技術的制約:**
- [制約1]
- [制約2]
- [制約3]

**ビジネス制約:**
- [制約1]
- [制約2]
- [制約3]

#### 2.1.6 前提条件と依存関係
**前提条件:**
- [前提1]
- [前提2]

**依存関係:**
- [依存システム1]
- [依存システム2]

---

## 3. 機能要件

### 3.1 ユースケース図
```

[ユースケース図をここに挿入]

- アクター(利用者)
- ユースケース(機能)
- 関係性

```

### 3.2 機能要件一覧

| 要件ID | 機能名 | 優先度 | 概要 |
|--------|--------|--------|------|
| FR-001 | [機能名1] | 高 | [概要] |
| FR-002 | [機能名2] | 高 | [概要] |
| FR-003 | [機能名3] | 中 | [概要] |
| FR-004 | [機能名4] | 低 | [概要] |

### 3.3 機能詳細仕様

#### FR-001: [機能名1]

**優先度:** 高 ★★★

**概要:**
[この機能の目的と概要を記述]

**前提条件:**
- [前提条件1]
- [前提条件2]

**入力:**
| 項目名 | データ型 | 必須 | 制約条件 | 備考 |
|--------|---------|------|---------|------|
| [項目1] | [型] | ○ | [制約] | [備考] |
| [項目2] | [型] | - | [制約] | [備考] |

**処理:**
1. [処理ステップ1]
2. [処理ステップ2]
3. [処理ステップ3]

**出力:**
| 項目名 | データ型 | 説明 |
|--------|---------|------|
| [項目1] | [型] | [説明] |
| [項目2] | [型] | [説明] |

**事後条件:**
- [事後条件1]
- [事後条件2]

**例外処理:**
| エラーコード | 発生条件 | 処理内容 |
|------------|---------|---------|
| E001 | [条件] | [処理] |
| E002 | [条件] | [処理] |

**ビジネスルール:**
- [ルール1]
- [ルール2]

**備考:**
[その他の特記事項]

---

[FR-002以降も同様の形式で記述]

---

## 4. 非機能要件

### 4.1 性能要件

| 要件ID | 項目 | 目標値 | 測定方法 |
|--------|------|--------|---------|
| NFR-P-001 | レスポンスタイム | 平均1秒以内 | [測定方法] |
| NFR-P-002 | スループット | 1000TPS | [測定方法] |
| NFR-P-003 | 同時接続ユーザー数 | 10,000ユーザー | [測定方法] |
| NFR-P-004 | データ処理量 | 100万件/日 | [測定方法] |

### 4.2 信頼性要件

| 要件ID | 項目 | 目標値 | 備考 |
|--------|------|--------|------|
| NFR-R-001 | 稼働率 | 99.9% | 月間ダウンタイム43分以内 |
| NFR-R-002 | MTBF | 720時間以上 | 平均故障間隔 |
| NFR-R-003 | MTTR | 1時間以内 | 平均修復時間 |
| NFR-R-004 | データ整合性 | 100% | データ不整合ゼロ |

### 4.3 セキュリティ要件

| 要件ID | 項目 | 要件内容 |
|--------|------|---------|
| NFR-S-001 | 認証 | [認証方式の詳細] |
| NFR-S-002 | 認可 | [権限管理の詳細] |
| NFR-S-003 | 暗号化 | [暗号化方式の詳細] |
| NFR-S-004 | 監査ログ | [ログ取得の詳細] |
| NFR-S-005 | 脆弱性対策 | [対策の詳細] |

### 4.4 可用性要件

| 要件ID | 項目 | 要件内容 |
|--------|------|---------|
| NFR-A-001 | バックアップ | [バックアップ方式と頻度] |
| NFR-A-002 | 冗長化 | [冗長化構成の詳細] |
| NFR-A-003 | 災害対策 | [DR対策の詳細] |
| NFR-A-004 | フェイルオーバー | [切り替え方式の詳細] |

### 4.5 保守性要件

| 要件ID | 項目 | 要件内容 |
|--------|------|---------|
| NFR-M-001 | ログ出力 | [ログ要件の詳細] |
| NFR-M-002 | モニタリング | [監視項目の詳細] |
| NFR-M-003 | エラー通知 | [通知方式の詳細] |
| NFR-M-004 | ドキュメント | [保守ドキュメント要件] |

### 4.6 移植性要件

| 要件ID | 項目 | 要件内容 |
|--------|------|---------|
| NFR-T-001 | プラットフォーム独立性 | [詳細] |
| NFR-T-002 | データ移行 | [詳細] |
| NFR-T-003 | インポート/エクスポート | [詳細] |

### 4.7 使用性(ユーザビリティ)要件

| 要件ID | 項目 | 要件内容 |
|--------|------|---------|
| NFR-U-001 | 学習容易性 | [詳細] |
| NFR-U-002 | 操作効率 | [詳細] |
| NFR-U-003 | アクセシビリティ | [詳細] |
| NFR-U-004 | 多言語対応 | [詳細] |

### 4.8 拡張性要件

| 要件ID | 項目 | 要件内容 |
|--------|------|---------|
| NFR-E-001 | ユーザー数拡張 | [拡張方針] |
| NFR-E-002 | 機能拡張 | [拡張方針] |
| NFR-E-003 | データ量拡張 | [拡張方針] |

---

## 5. 外部インターフェース要件

### 5.1 ユーザーインターフェース(UI)

#### 5.1.1 画面一覧
| 画面ID | 画面名 | 概要 | 優先度 |
|--------|--------|------|--------|
| UI-001 | [画面名1] | [概要] | 高 |
| UI-002 | [画面名2] | [概要] | 高 |
| UI-003 | [画面名3] | [概要] | 中 |

#### 5.1.2 画面遷移図
```

[画面遷移図をここに挿入]

```

#### 5.1.3 画面詳細仕様

**UI-001: [画面名1]**
- **目的:** [画面の目的]
- **表示条件:** [条件]
- **画面要素:**
  - [要素1の説明]
  - [要素2の説明]
- **操作:**
  - [操作1の説明]
  - [操作2の説明]
- **バリデーション:**
  - [検証ルール1]
  - [検証ルール2]

### 5.2 ハードウェアインターフェース
[ハードウェアとの接続仕様を記述]

### 5.3 ソフトウェアインターフェース

#### 5.3.1 外部システム連携一覧
| システム名 | 連携方式 | データ形式 | 頻度 |
|-----------|---------|----------|------|
| [システム1] | [方式] | [形式] | [頻度] |
| [システム2] | [方式] | [形式] | [頻度] |

#### 5.3.2 API仕様
**API-001: [API名]**
- **エンドポイント:** `[HTTPメソッド] /api/v1/[パス]`
- **認証方式:** [認証方式]
- **リクエスト:**
```json
{
  "field1": "value1",
  "field2": "value2"
}
```

- **レスポンス:**

```json
{
  "status": "success",
  "data": {
    "result": "value"
  }
}
```

- **エラーコード:**
  - 400: [説明]
  - 401: [説明]
  - 500: [説明]

### 5.4 通信インターフェース

- **プロトコル:** [使用プロトコル]
- **データ形式:** [JSON/XML/その他]
- **通信方式:** [同期/非同期]
- **セキュリティ:** [暗号化方式]

---

## 6. その他の要件

### 6.1 データ要件

#### 6.1.1 データモデル

```
[ER図またはデータモデル図をここに挿入]
```

#### 6.1.2 データベース要件

| 項目 | 要件 |
|------|------|
| DBMS | [製品名とバージョン] |
| データ保持期間 | [期間] |
| バックアップ方式 | [方式] |
| データ量予測 | [初期/1年後/3年後] |

### 6.2 コンプライアンス要件

- **法規制:** [該当する法規制]
- **業界標準:** [準拠する標準]
- **社内規程:** [該当する社内規程]
- **監査要件:** [監査対応要件]

### 6.3 国際化要件

- **対応言語:** [言語リスト]
- **タイムゾーン:** [対応タイムゾーン]
- **文字コード:** [使用文字コード]
- **通貨・日付形式:** [形式]

### 6.4 ライセンス・購入要件

| ソフトウェア | ライセンス | 数量 | 備考 |
|------------|-----------|------|------|
| [製品1] | [ライセンス形態] | [数] | [備考] |
| [製品2] | [ライセンス形態] | [数] | [備考] |

---

## 7. 付録

### 7.1 要件トレーサビリティマトリクス(RTM)

| 要件ID | 要件名 | 設計書 | テストケース | 実装 | 状態 |
|--------|--------|--------|------------|------|------|
| FR-001 | [名称] | DD-xxx | TC-xxx | [モジュール] | [状態] |
| FR-002 | [名称] | DD-xxx | TC-xxx | [モジュール] | [状態] |

### 7.2 用例シナリオ

**シナリオ1: [シナリオ名]**

1. [ステップ1]
2. [ステップ2]
3. [ステップ3]

**期待結果:**
[期待される結果]

### 7.3 画面モックアップ

[画面のワイヤーフレームやモックアップをここに添付]

### 7.4 承認

| 役割 | 氏名 | 承認日 | 署名 |
|------|------|--------|------|
| プロジェクトマネージャー | [氏名] | YYYY/MM/DD | |
| システムアーキテクト | [氏名] | YYYY/MM/DD | |
| ビジネスオーナー | [氏名] | YYYY/MM/DD | |

---

**【文書終了】**

```

---

### ✅ SRS作成時のチェックリスト

**1. 概要セクション:**
- ☐ 目的が明確に記述されている
- ☐ スコープが明確に定義されている
- ☐ 用語が定義されている
- ☐ 参照文書がリストアップされている

**2. 機能要件:**
- ☐ 全ての機能要件に一意のIDが付与されている
- ☐ 優先度が明確になっている
- ☐ 入力・処理・出力が明確に定義されている
- ☐ 例外処理が記述されている

**3. 非機能要件:**
- ☐ 性能要件が定量的に定義されている
- ☐ セキュリティ要件が網羅されている
- ☐ 可用性・信頼性要件が明確である
- ☐ 保守性要件が定義されている

**4. インターフェース:**
- ☐ UI仕様が明確に定義されている
- ☐ API仕様が詳細に記述されている
- ☐ 外部システム連携が定義されている

**5. その他:**
- ☐ データモデルが明確である
- ☐ コンプライアンス要件が確認されている
- ☐ 変更履歴が記録されている
- ☐ 承認者の署名欄がある

---

### ⚠️ SRS作成時の注意点

**やってはいけないこと:**
1. **曖昧な表現を使う**
   - ❌ 「高速に動作する」
   - ✅ 「レスポンスタイム1秒以内」

2. **実装方法を記述する**
   - ❌ 「MySQLを使用してデータを保存する」
   - ✅ 「データは永続的に保存される」

3. **要件の優先度を付けない**
   - ❌ 全ての要件を同列に扱う
   - ✅ 高・中・低の優先度を明確にする

4. **測定不可能な要件を書く**
   - ❌ 「ユーザーが使いやすいシステム」
   - ✅ 「3回の操作以内で目的の機能にアクセス可能」

**良い実践:**
1. **具体的で測定可能な要件を書く**
2. **ステークホルダーと頻繁にレビューする**
3. **要件の変更を適切に管理する**
4. **トレーサビリティを確保する**

---

### 💡 SRSテンプレート使用のヒント

**初めて作成する場合:**
1. **小さく始める:** 全項目を埋めようとせず、重要な部分から記述
2. **サンプルを参考にする:** 類似プロジェクトのSRSを参照
3. **レビューを重ねる:** 初版は完璧でなくて良い、段階的に改善

**効率的に作成するには:**
1. **テンプレートをカスタマイズ:** プロジェクトに不要な項目は削除
2. **ツールを活用:** 要件管理ツール(Jira、Azure DevOps等)を使用
3. **自動生成を検討:** UIモックアップからの要件抽出など

**品質を高めるには:**
1. **クロスレビュー:** 複数の視点でレビュー
2. **プロトタイプ作成:** 要件の妥当性を早期に検証
3. **定期的な見直し:** 開発中も要件を継続的に更新

**関連用語:** 要求定義、機能要件、非機能要件、ユースケース、要件管理

---


## 8.2 基本設計書テンプレート

**重要度:** ★★★★★

基本設計書は、SRSで定義した要件を**どのように実現するか**を技術的な観点から記述するドキュメントです。

### 📄 基本設計書の全体構成

```mermaid
graph TD
    A[基本設計書] --> B[1. システム方式設計]
    A --> C[2. アーキテクチャ設計]
    A --> D[3. データベース設計]
    A --> E[4. インターフェース設計]
    A --> F[5. セキュリティ設計]
    
    B --> B1[システム構成・<br/>技術選定]
    C --> C1[層別設計・<br/>コンポーネント]
    D --> D1[論理設計・<br/>物理設計]
    E --> E1[API設計・<br/>画面設計]
    F --> F1[認証認可・<br/>暗号化]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#f3e5f5,stroke:#7b1fa2
    style D fill:#e8f5e9,stroke:#2e7d32
    style E fill:#fff9c4,stroke:#f57f17
    style F fill:#fce4ec,stroke:#c2185b
```

---

### 📋 基本設計書テンプレート(簡略版)

以下は実務で使用できる基本設計書の主要セクションです。

```markdown
# 基本設計書
# Basic Design Document

---

## ドキュメント管理情報

| 項目 | 内容 |
|------|------|
| **文書番号** | BD-[プロジェクト名]-001 |
| **文書名** | [システム名] 基本設計書 |
| **バージョン** | 1.0 |
| **作成日** | YYYY/MM/DD |
| **作成者** | [氏名・所属] |
| **ベース文書** | [SRS文書番号] |

---

## 1. システム方式設計

### 1.1 システム概要
[システムの目的と特徴を簡潔に記述]

### 1.2 システム構成

#### 1.2.1 全体構成図
```

[システム全体の構成図]
クライアント層 → アプリケーション層 → データ層

```

#### 1.2.2 システム構成要素
| コンポーネント | 役割 | 技術スタック |
|--------------|------|------------|
| Webサーバー | [役割] | [技術] |
| APサーバー | [役割] | [技術] |
| DBサーバー | [役割] | [技術] |

### 1.3 技術選定

| 項目 | 技術 | バージョン | 選定理由 |
|------|------|-----------|---------|
| 言語 | [言語] | [Ver] | [理由] |
| フレームワーク | [FW] | [Ver] | [理由] |
| DBMS | [製品] | [Ver] | [理由] |

---

## 2. アーキテクチャ設計

### 2.1 アーキテクチャスタイル
[採用するアーキテクチャ: レイヤード、マイクロサービス等]

### 2.2 層別設計

#### プレゼンテーション層
- UI/画面表示
- ユーザー入力の受付

#### アプリケーション層
- ビジネスロジック
- データ処理

#### データアクセス層
- データベース接続
- CRUD操作

### 2.3 コンポーネント設計
| コンポーネント | 責務 | 依存関係 |
|--------------|------|---------|
| [コンポーネント1] | [責務] | [依存] |
| [コンポーネント2] | [責務] | [依存] |

---

## 3. データベース設計

### 3.1 ER図
```

[Entity-Relationship図をここに挿入]

```

### 3.2 テーブル定義

**テーブル名: users**

| カラム名 | データ型 | NULL | キー | 説明 |
|---------|---------|------|-----|------|
| id | BIGINT | NOT NULL | PK | ユーザーID |
| username | VARCHAR(50) | NOT NULL | UQ | ユーザー名 |
| email | VARCHAR(100) | NOT NULL | UQ | メールアドレス |
| password_hash | VARCHAR(255) | NOT NULL | - | パスワードハッシュ |
| created_at | TIMESTAMP | NOT NULL | - | 作成日時 |
| updated_at | TIMESTAMP | NOT NULL | - | 更新日時 |

**インデックス:**
- PRIMARY KEY (id)
- UNIQUE KEY uk_username (username)
- UNIQUE KEY uk_email (email)
- INDEX idx_created_at (created_at)

---

## 4. インターフェース設計

### 4.1 API設計

#### APIエンドポイント一覧
| エンドポイント | メソッド | 概要 | 認証 |
|--------------|---------|------|------|
| /api/v1/users | GET | ユーザー一覧取得 | 必要 |
| /api/v1/users | POST | ユーザー作成 | 必要 |
| /api/v1/users/{id} | GET | ユーザー詳細取得 | 必要 |
| /api/v1/users/{id} | PUT | ユーザー更新 | 必要 |
| /api/v1/users/{id} | DELETE | ユーザー削除 | 必要 |

#### API詳細例
**エンドポイント:** `GET /api/v1/users/{id}`

**リクエスト:**
```

GET /api/v1/users/123
Authorization: Bearer {token}

```

**レスポンス(成功):**
```json
{
  "status": "success",
  "data": {
    "id": 123,
    "username": "example_user",
    "email": "user@example.com",
    "created_at": "2025-01-01T00:00:00Z"
  }
}
```

### 4.2 画面設計

#### 画面一覧

| 画面ID | 画面名 | URL | 説明 |
|--------|--------|-----|------|
| SCR-001 | ログイン画面 | /login | 認証画面 |
| SCR-002 | ダッシュボード | /dashboard | メイン画面 |
| SCR-003 | ユーザー一覧 | /users | ユーザー管理 |

---

## 5. セキュリティ設計

### 5.1 認証・認可

- **認証方式:** JWT (JSON Web Token)
- **パスワード:** bcryptでハッシュ化
- **セッション:** トークンベース、有効期限24時間

### 5.2 データ保護

- **通信暗号化:** TLS 1.3
- **データ暗号化:** AES-256
- **個人情報:** マスキング処理

### 5.3 セキュリティ対策

- SQLインジェクション対策: プリペアドステートメント
- XSS対策: エスケープ処理
- CSRF対策: トークン検証
- 認証エラー: ブルートフォース攻撃対策

---

## 6. 性能設計

### 6.1 性能目標

| 項目 | 目標値 |
|------|--------|
| レスポンスタイム | 1秒以内 |
| 同時接続数 | 10,000ユーザー |
| スループット | 1000TPS |

### 6.2 性能対策

- **キャッシング:** Redis使用、TTL 1時間
- **データベース最適化:** インデックス設計、クエリチューニング
- **ロードバランシング:** 複数APサーバーで負荷分散

---

## 7. 運用設計

### 7.1 監視項目

- サーバーリソース(CPU、メモリ、ディスク)
- アプリケーションログ
- エラーレート
- レスポンスタイム

### 7.2 バックアップ

- **データベース:** 日次フルバックアップ、時間毎の差分
- **ファイル:** 日次バックアップ
- **保持期間:** 30日間

---

**【文書終了】**

```

---

### ✅ 基本設計書作成時のチェックリスト

**1. システム方式設計:**
- ☐ システム構成が明確に図示されている
- ☐ 技術選定の理由が記載されている
- ☐ 各環境が定義されている

**2. アーキテクチャ設計:**
- ☐ アーキテクチャスタイルが明確である
- ☐ 層別設計が適切に分離されている
- ☐ コンポーネント間の依存関係が明確である

**3. データベース設計:**
- ☐ ER図が作成されている
- ☐ 全テーブルの定義が完成している
- ☐ インデックス設計が適切である

**4. インターフェース設計:**
- ☐ APIエンドポイントが一覧化されている
- ☐ リクエスト/レスポンス仕様が明確である
- ☐ 画面一覧と遷移が定義されている

**5. セキュリティ設計:**
- ☐ 認証・認可方式が明確である
- ☐ データ保護対策が定義されている
- ☐ 主要な脆弱性対策が記載されている

---

### ⚠️ 基本設計書作成時の注意点

**よくある間違い:**
1. **実装の詳細を書きすぎる**
   - 基本設計では「どう作るか」の方針を決める
   - 細かいコードは詳細設計で

2. **技術選定の理由が不明確**
   - 「なぜその技術を選んだか」を必ず記載
   - 代替案との比較も有効

3. **非機能要件を考慮していない**
   - 性能・セキュリティは必須項目

4. **レビュー不足**
   - 複数の視点で設計を確認する

**良い実践:**
1. **図を積極的に使う:** 視覚的に理解しやすくする
2. **プロトタイプで検証:** 重要な部分は試作して確認
3. **継続的に更新:** 開発中も最新に保つ
4. **トレードオフを明記:** 設計判断の理由を記録

---

### 💡 基本設計書作成のヒント

**効率的に作成するには:**
1. **テンプレートをカスタマイズ:** プロジェクトに合わせて調整
2. **既存資産を参考:** 類似プロジェクトの設計書を活用
3. **ツールを活用:** PlantUML、Mermaidで図を効率的に作成

**品質を高めるには:**
1. **設計レビュー会を開催:** ステークホルダー全員で確認
2. **POC(概念実証)を実施:** 技術的な不確実性を早期に解消
3. **ADR(設計判断記録)を作成:** 重要な判断を文書化

**関連用語:** アーキテクチャ、コンポーネント設計、データベース設計、API設計、セキュリティ設計

---


## 8.3 詳細設計書テンプレート

**重要度:** ★★★★☆

詳細設計書は、基本設計をさらに具体化し、**プログラマーが実装できるレベル**まで詳細化したドキュメントです。

### 📄 詳細設計書の全体構成

```mermaid
graph TD
    A[詳細設計書] --> B[1. モジュール設計]
    A --> C[2. 処理フロー設計]
    A --> D[3. データ設計]
    A --> E[4. エラー処理設計]
    A --> F[5. インターフェース詳細]
    
    B --> B1[クラス・関数・<br/>メソッド定義]
    C --> C1[フローチャート・<br/>シーケンス図]
    D --> D1[データ構造・<br/>変換ルール]
    E --> E1[例外処理・<br/>ログ出力]
    F --> F1[API詳細・<br/>画面項目]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#f3e5f5,stroke:#7b1fa2
    style D fill:#e8f5e9,stroke:#2e7d32
    style E fill:#fff9c4,stroke:#f57f17
    style F fill:#fce4ec,stroke:#c2185b
```

---

### 📋 詳細設計書テンプレート

```markdown
# 詳細設計書
# Detailed Design Document

---

## ドキュメント管理情報

| 項目 | 内容 |
|------|------|
| **文書番号** | DD-[プロジェクト名]-[機能名]-001 |
| **文書名** | [機能名] 詳細設計書 |
| **バージョン** | 1.0 |
| **作成日** | YYYY/MM/DD |
| **作成者** | [氏名・所属] |
| **ベース文書** | [基本設計書番号] |

---

## 1. 機能概要

### 1.1 機能の目的
[この機能が実現する目的を記述]

### 1.2 対応する要件
- **要件ID:** FR-XXX
- **要件名:** [要件名]
- **優先度:** [高/中/低]

### 1.3 関連機能
- [関連機能1]
- [関連機能2]

---

## 2. モジュール設計

### 2.1 モジュール構成

```

[パッケージ名]/
├── controller/
│   └── UserController.java     # ユーザー管理コントローラー
├── service/
│   ├── UserService.java        # ユーザー業務ロジック
│   └── UserServiceImpl.java    # 実装クラス
├── repository/
│   └── UserRepository.java     # データアクセス
├── model/
│   ├── User.java              # ユーザーエンティティ
│   └── UserDTO.java           # データ転送オブジェクト
└── exception/
    └── UserNotFoundException.java # 例外クラス

```

### 2.2 クラス設計

#### クラス名: UserController

**責務:** ユーザー管理のHTTPリクエストを受け付け、適切なサービスに処理を委譲する

**クラス図:**
```

┌─────────────────────────┐
│   UserController        │
├─────────────────────────┤
│ - userService: UserService │
├─────────────────────────┤
│ + getUsers(): List<User>  │
│ + getUser(id): User       │
│ + createUser(dto): User   │
│ + updateUser(id,dto): User│
│ + deleteUser(id): void    │
└─────────────────────────┘

```

**属性:**
| 属性名 | データ型 | アクセス | 説明 |
|--------|---------|---------|------|
| userService | UserService | private | ユーザーサービス |

**メソッド:**
| メソッド名 | 引数 | 戻り値 | 説明 |
|----------|------|--------|------|
| getUsers | なし | List<User> | 全ユーザー取得 |
| getUser | Long id | User | ユーザー詳細取得 |
| createUser | UserDTO dto | User | ユーザー作成 |
| updateUser | Long id, UserDTO dto | User | ユーザー更新 |
| deleteUser | Long id | void | ユーザー削除 |

---

## 3. 処理フロー設計

### 3.1 ユーザー作成処理

#### 3.1.1 処理フロー図
```mermaid
flowchart TD
    A[開始] --> B{入力検証}
    B -->|NG| C[エラーレスポンス]
    B -->|OK| D{メールアドレス<br/>重複チェック}
    D -->|重複あり| E[409 Conflict]
    D -->|重複なし| F[パスワードハッシュ化]
    F --> G[DBに保存]
    G --> H[成功レスポンス]
    C --> Z[終了]
    E --> Z
    H --> Z
    
    style A fill:#c8e6c9
    style B fill:#fff9c4
    style C fill:#ffcdd2
    style D fill:#fff9c4
    style E fill:#ffcdd2
    style F fill:#b3e5fc
    style G fill:#b3e5fc
    style H fill:#c8e6c9
```

#### 3.1.2 処理詳細

**関数名:** `createUser(UserDTO dto)`

**入力:**

```java
UserDTO {
    String username;     // ユーザー名 (必須、3-50文字)
    String email;        // メール (必須、形式チェック)
    String password;     // パスワード (必須、8文字以上)
}
```

**処理ステップ:**

1. **入力検証**

   ```java
   if (dto.username == null || dto.username.length() < 3) {
       throw new ValidationException("ユーザー名は3文字以上");
   }
   if (!isValidEmail(dto.email)) {
       throw new ValidationException("メール形式が不正");
   }
   ```

2. **重複チェック**

   ```java
   if (userRepository.existsByEmail(dto.email)) {
       throw new DuplicateEmailException("既に登録済み");
   }
   ```

3. **パスワードハッシュ化**

   ```java
   String hashedPassword = BCrypt.hashpw(dto.password, BCrypt.gensalt());
   ```

4. **ユーザー作成・保存**

   ```java
   User user = new User();
   user.setUsername(dto.username);
   user.setEmail(dto.email);
   user.setPasswordHash(hashedPassword);
   user.setCreatedAt(LocalDateTime.now());
   return userRepository.save(user);
   ```

**出力:**

```java
User {
    Long id;
    String username;
    String email;
    LocalDateTime createdAt;
}
```

**例外:**

| 例外 | 発生条件 | HTTPステータス |
|------|---------|---------------|
| ValidationException | 入力値不正 | 400 Bad Request |
| DuplicateEmailException | メール重複 | 409 Conflict |
| DatabaseException | DB接続エラー | 500 Internal Server Error |

---

## 4. データ設計

### 4.1 エンティティ定義

#### User エンティティ

```java
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true, length = 50)
    private String username;
    
    @Column(nullable = false, unique = true, length = 100)
    private String email;
    
    @Column(name = "password_hash", nullable = false)
    private String passwordHash;
    
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;
    
    // Getter/Setter省略
}
```

### 4.2 DTO定義

#### UserDTO

```java
public class UserDTO {
    @NotNull
    @Size(min = 3, max = 50)
    private String username;
    
    @NotNull
    @Email
    private String email;
    
    @NotNull
    @Size(min = 8)
    private String password;
    
    // Getter/Setter省略
}
```

### 4.3 データ変換ルール

| エンティティ | DTO | 変換ルール |
|-----------|-----|----------|
| User | UserDTO | パスワードハッシュは含めない |
| User | UserResponseDTO | IDと基本情報のみ返却 |

---

## 5. エラー処理設計

### 5.1 例外クラス階層

```
Exception
└── RuntimeException
    └── ApplicationException (基底クラス)
        ├── ValidationException      # 入力検証エラー
        ├── ResourceNotFoundException # リソース未発見
        ├── DuplicateResourceException # 重複エラー
        └── DatabaseException        # DB関連エラー
```

### 5.2 エラーレスポンス形式

```json
{
  "status": "error",
  "error": {
    "code": "E001",
    "message": "エラーメッセージ",
    "details": [
      {
        "field": "email",
        "message": "メールアドレスは必須です"
      }
    ],
    "timestamp": "2025-01-01T00:00:00Z"
  }
}
```

### 5.3 エラーコード一覧

| コード | 種類 | HTTPステータス | 説明 |
|-------|------|---------------|------|
| E001 | VALIDATION_ERROR | 400 | 入力検証エラー |
| E002 | RESOURCE_NOT_FOUND | 404 | リソース未発見 |
| E003 | DUPLICATE_RESOURCE | 409 | リソース重複 |
| E004 | UNAUTHORIZED | 401 | 認証エラー |
| E005 | FORBIDDEN | 403 | 権限エラー |
| E999 | INTERNAL_ERROR | 500 | システムエラー |

---

## 6. ログ設計

### 6.1 ログレベル

| レベル | 用途 | 出力先 |
|--------|------|--------|
| ERROR | エラー発生時 | ファイル、監視ツール |
| WARN | 警告事項 | ファイル |
| INFO | 重要な処理 | ファイル |
| DEBUG | デバッグ情報 | 開発環境のみ |

### 6.2 ログ出力形式

```
[2025-01-01 12:00:00.000] [INFO] [UserService] User created: id=123, username=example_user
[2025-01-01 12:00:01.000] [ERROR] [UserService] Failed to create user: email=test@example.com, error=Duplicate email
```

### 6.3 ログ出力項目

- タイムスタンプ
- ログレベル
- クラス名/メソッド名
- メッセージ
- エラーの場合: スタックトレース

---

## 7. テスト観点

### 7.1 単体テストケース

#### ユーザー作成テスト

| テストケース | 入力 | 期待結果 |
|------------|------|---------|
| 正常系 | 有効な入力値 | ユーザー作成成功 |
| 異常系: ユーザー名null | username=null | ValidationException |
| 異常系: ユーザー名短い | username="ab" | ValidationException |
| 異常系: メール形式不正 | email="invalid" | ValidationException |
| 異常系: メール重複 | 既存メール | DuplicateEmailException |
| 異常系: パスワード短い | password="1234567" | ValidationException |

### 7.2 境界値テスト

| 項目 | 最小値 | 最大値 | テスト値 |
|------|-------|--------|---------|
| ユーザー名 | 3文字 | 50文字 | 2文字、3文字、50文字、51文字 |
| パスワード | 8文字 | 制限なし | 7文字、8文字、100文字 |

---

## 8. 付録

### 8.1 使用ライブラリ

| ライブラリ | バージョン | 用途 |
|----------|-----------|------|
| Spring Boot | 3.2.0 | フレームワーク |
| Spring Data JPA | 3.2.0 | データアクセス |
| BCrypt | 0.10.2 | パスワードハッシュ |
| Validation | 3.0.2 | 入力検証 |

### 8.2 参照資料

- [基本設計書番号]
- [APIドキュメント]

---

**【文書終了】**

```

---

### ✅ 詳細設計書作成時のチェックリスト

**1. モジュール設計:**
- ☐ クラス/関数の責務が明確
- ☐ メソッドのシグネチャが定義されている
- ☐ 依存関係が明確である

**2. 処理フロー:**
- ☐ フローチャートが作成されている
- ☐ 処理の分岐条件が明確
- ☐ 例外処理が考慮されている

**3. データ設計:**
- ☐ エンティティ/DTOが定義されている
- ☐ データ変換ルールが明確
- ☐ バリデーションルールが定義されている

**4. エラー処理:**
- ☐ 例外クラスが定義されている
- ☐ エラーレスポンス形式が統一されている
- ☐ エラーコードが体系化されている

**5. ログ設計:**
- ☐ ログレベルが適切に設定されている
- ☐ ログ出力項目が定義されている

---

### ⚠️ 詳細設計書作成時の注意点

**やってはいけないこと:**
1. **コードを書きすぎる**
   - ❌ 実装コードを全て書く
   - ✅ 重要な処理の疑似コードやサンプル

2. **処理フローが不明確**
   - ❌ 文章だけで説明
   - ✅ フローチャートやシーケンス図を使用

3. **エラー処理を後回し**
   - ❌ 正常系だけ設計
   - ✅ 異常系も含めて設計

4. **テスト観点がない**
   - ❌ 実装だけ考える
   - ✅ テストケースも考慮

**良い実践:**
1. **実装可能なレベルまで詳細化**
2. **サンプルコードを含める**
3. **レビューを頻繁に実施**
4. **実装しながら更新**

---

### 💡 詳細設計書作成のヒント

**効率的に作成するには:**
1. **コード生成ツールを活用:** エンティティやDTOは自動生成可能
2. **既存コードを参考:** 類似機能の実装を参照
3. **ペアプログラミング:** 設計しながら実装も検討

**品質を高めるには:**
1. **早期に実装を開始:** 設計と実装を並行
2. **単体テストを先に書く:** TDD(テスト駆動開発)
3. **コードレビューと設計レビューを連動:** 実装と設計の整合性確保

**関連用語:** クラス設計、処理フロー、エラー処理、ログ設計、単体テスト

---


## 8.3 詳細設計書テンプレート

**重要度:** ★★★★☆

詳細設計書は、基本設計をさらに具体化し、**プログラマーが実装できるレベル**まで詳細化したドキュメントです。

### 📄 詳細設計書の全体構成

```mermaid
graph TD
    A[詳細設計書] --> B[1. モジュール設計]
    A --> C[2. 処理フロー設計]
    A --> D[3. データ設計]
    A --> E[4. エラー処理設計]
    A --> F[5. インターフェース詳細]
    
    B --> B1[クラス・関数・<br/>メソッド定義]
    C --> C1[フローチャート・<br/>シーケンス図]
    D --> D1[データ構造・<br/>変換ルール]
    E --> E1[例外処理・<br/>ログ出力]
    F --> F1[API詳細・<br/>画面項目]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#f3e5f5,stroke:#7b1fa2
    style D fill:#e8f5e9,stroke:#2e7d32
    style E fill:#fff9c4,stroke:#f57f17
    style F fill:#fce4ec,stroke:#c2185b
```

---

### 📋 詳細設計書テンプレート

```markdown
# 詳細設計書
# Detailed Design Document

---

## ドキュメント管理情報

| 項目 | 内容 |
|------|------|
| **文書番号** | DD-[プロジェクト名]-[機能名]-001 |
| **文書名** | [機能名] 詳細設計書 |
| **バージョン** | 1.0 |
| **作成日** | YYYY/MM/DD |
| **作成者** | [氏名・所属] |
| **ベース文書** | [基本設計書番号] |

---

## 1. 機能概要

### 1.1 機能の目的
[この機能が実現する目的を記述]

### 1.2 対応する要件
- **要件ID:** FR-XXX
- **要件名:** [要件名]
- **優先度:** [高/中/低]

### 1.3 関連機能
- [関連機能1]
- [関連機能2]

---

## 2. モジュール設計

### 2.1 モジュール構成

```

[パッケージ名]/
├── controller/
│   └── UserController.java     # ユーザー管理コントローラー
├── service/
│   ├── UserService.java        # ユーザー業務ロジック
│   └── UserServiceImpl.java    # 実装クラス
├── repository/
│   └── UserRepository.java     # データアクセス
├── model/
│   ├── User.java              # ユーザーエンティティ
│   └── UserDTO.java           # データ転送オブジェクト
└── exception/
    └── UserNotFoundException.java # 例外クラス

```

### 2.2 クラス設計

#### クラス名: UserController

**責務:** ユーザー管理のHTTPリクエストを受け付け、適切なサービスに処理を委譲する

**クラス図:**
```

┌─────────────────────────┐
│   UserController        │
├─────────────────────────┤
│ - userService: UserService │
├─────────────────────────┤
│ + getUsers(): List<User>  │
│ + getUser(id): User       │
│ + createUser(dto): User   │
│ + updateUser(id,dto): User│
│ + deleteUser(id): void    │
└─────────────────────────┘

```

**属性:**
| 属性名 | データ型 | アクセス | 説明 |
|--------|---------|---------|------|
| userService | UserService | private | ユーザーサービス |

**メソッド:**
| メソッド名 | 引数 | 戻り値 | 説明 |
|----------|------|--------|------|
| getUsers | なし | List<User> | 全ユーザー取得 |
| getUser | Long id | User | ユーザー詳細取得 |
| createUser | UserDTO dto | User | ユーザー作成 |
| updateUser | Long id, UserDTO dto | User | ユーザー更新 |
| deleteUser | Long id | void | ユーザー削除 |

---

## 3. 処理フロー設計

### 3.1 ユーザー作成処理

#### 3.1.1 処理フロー図
```mermaid
flowchart TD
    A[開始] --> B{入力検証}
    B -->|NG| C[エラーレスポンス]
    B -->|OK| D{メールアドレス<br/>重複チェック}
    D -->|重複あり| E[409 Conflict]
    D -->|重複なし| F[パスワードハッシュ化]
    F --> G[DBに保存]
    G --> H[成功レスポンス]
    C --> Z[終了]
    E --> Z
    H --> Z
    
    style A fill:#c8e6c9
    style B fill:#fff9c4
    style C fill:#ffcdd2
    style D fill:#fff9c4
    style E fill:#ffcdd2
    style F fill:#b3e5fc
    style G fill:#b3e5fc
    style H fill:#c8e6c9
```

#### 3.1.2 処理詳細

**関数名:** `createUser(UserDTO dto)`

**入力:**

```java
UserDTO {
    String username;     // ユーザー名 (必須、3-50文字)
    String email;        // メール (必須、形式チェック)
    String password;     // パスワード (必須、8文字以上)
}
```

**処理ステップ:**

1. **入力検証**

   ```java
   if (dto.username == null || dto.username.length() < 3) {
       throw new ValidationException("ユーザー名は3文字以上");
   }
   if (!isValidEmail(dto.email)) {
       throw new ValidationException("メール形式が不正");
   }
   ```

2. **重複チェック**

   ```java
   if (userRepository.existsByEmail(dto.email)) {
       throw new DuplicateEmailException("既に登録済み");
   }
   ```

3. **パスワードハッシュ化**

   ```java
   String hashedPassword = BCrypt.hashpw(dto.password, BCrypt.gensalt());
   ```

4. **ユーザー作成・保存**

   ```java
   User user = new User();
   user.setUsername(dto.username);
   user.setEmail(dto.email);
   user.setPasswordHash(hashedPassword);
   user.setCreatedAt(LocalDateTime.now());
   return userRepository.save(user);
   ```

**出力:**

```java
User {
    Long id;
    String username;
    String email;
    LocalDateTime createdAt;
}
```

**例外:**

| 例外 | 発生条件 | HTTPステータス |
|------|---------|---------------|
| ValidationException | 入力値不正 | 400 Bad Request |
| DuplicateEmailException | メール重複 | 409 Conflict |
| DatabaseException | DB接続エラー | 500 Internal Server Error |

---

## 4. データ設計

### 4.1 エンティティ定義

#### User エンティティ

```java
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true, length = 50)
    private String username;
    
    @Column(nullable = false, unique = true, length = 100)
    private String email;
    
    @Column(name = "password_hash", nullable = false)
    private String passwordHash;
    
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;
    
    // Getter/Setter省略
}
```

### 4.2 DTO定義

#### UserDTO

```java
public class UserDTO {
    @NotNull
    @Size(min = 3, max = 50)
    private String username;
    
    @NotNull
    @Email
    private String email;
    
    @NotNull
    @Size(min = 8)
    private String password;
    
    // Getter/Setter省略
}
```

### 4.3 データ変換ルール

| エンティティ | DTO | 変換ルール |
|-----------|-----|----------|
| User | UserDTO | パスワードハッシュは含めない |
| User | UserResponseDTO | IDと基本情報のみ返却 |

---

## 5. エラー処理設計

### 5.1 例外クラス階層

```
Exception
└── RuntimeException
    └── ApplicationException (基底クラス)
        ├── ValidationException      # 入力検証エラー
        ├── ResourceNotFoundException # リソース未発見
        ├── DuplicateResourceException # 重複エラー
        └── DatabaseException        # DB関連エラー
```

### 5.2 エラーレスポンス形式

```json
{
  "status": "error",
  "error": {
    "code": "E001",
    "message": "エラーメッセージ",
    "details": [
      {
        "field": "email",
        "message": "メールアドレスは必須です"
      }
    ],
    "timestamp": "2025-01-01T00:00:00Z"
  }
}
```

### 5.3 エラーコード一覧

| コード | 種類 | HTTPステータス | 説明 |
|-------|------|---------------|------|
| E001 | VALIDATION_ERROR | 400 | 入力検証エラー |
| E002 | RESOURCE_NOT_FOUND | 404 | リソース未発見 |
| E003 | DUPLICATE_RESOURCE | 409 | リソース重複 |
| E004 | UNAUTHORIZED | 401 | 認証エラー |
| E005 | FORBIDDEN | 403 | 権限エラー |
| E999 | INTERNAL_ERROR | 500 | システムエラー |

---

## 6. ログ設計

### 6.1 ログレベル

| レベル | 用途 | 出力先 |
|--------|------|--------|
| ERROR | エラー発生時 | ファイル、監視ツール |
| WARN | 警告事項 | ファイル |
| INFO | 重要な処理 | ファイル |
| DEBUG | デバッグ情報 | 開発環境のみ |

### 6.2 ログ出力形式

```
[2025-01-01 12:00:00.000] [INFO] [UserService] User created: id=123, username=example_user
[2025-01-01 12:00:01.000] [ERROR] [UserService] Failed to create user: email=test@example.com, error=Duplicate email
```

### 6.3 ログ出力項目

- タイムスタンプ
- ログレベル
- クラス名/メソッド名
- メッセージ
- エラーの場合: スタックトレース

---

## 7. テスト観点

### 7.1 単体テストケース

#### ユーザー作成テスト

| テストケース | 入力 | 期待結果 |
|------------|------|---------|
| 正常系 | 有効な入力値 | ユーザー作成成功 |
| 異常系: ユーザー名null | username=null | ValidationException |
| 異常系: ユーザー名短い | username="ab" | ValidationException |
| 異常系: メール形式不正 | email="invalid" | ValidationException |
| 異常系: メール重複 | 既存メール | DuplicateEmailException |
| 異常系: パスワード短い | password="1234567" | ValidationException |

### 7.2 境界値テスト

| 項目 | 最小値 | 最大値 | テスト値 |
|------|-------|--------|---------|
| ユーザー名 | 3文字 | 50文字 | 2文字、3文字、50文字、51文字 |
| パスワード | 8文字 | 制限なし | 7文字、8文字、100文字 |

---

## 8. 付録

### 8.1 使用ライブラリ

| ライブラリ | バージョン | 用途 |
|----------|-----------|------|
| Spring Boot | 3.2.0 | フレームワーク |
| Spring Data JPA | 3.2.0 | データアクセス |
| BCrypt | 0.10.2 | パスワードハッシュ |
| Validation | 3.0.2 | 入力検証 |

### 8.2 参照資料

- [基本設計書番号]
- [APIドキュメント]

---

**【文書終了】**

```

---

### ✅ 詳細設計書作成時のチェックリスト

**1. モジュール設計:**
- ☐ クラス/関数の責務が明確
- ☐ メソッドのシグネチャが定義されている
- ☐ 依存関係が明確である

**2. 処理フロー:**
- ☐ フローチャートが作成されている
- ☐ 処理の分岐条件が明確
- ☐ 例外処理が考慮されている

**3. データ設計:**
- ☐ エンティティ/DTOが定義されている
- ☐ データ変換ルールが明確
- ☐ バリデーションルールが定義されている

**4. エラー処理:**
- ☐ 例外クラスが定義されている
- ☐ エラーレスポンス形式が統一されている
- ☐ エラーコードが体系化されている

**5. ログ設計:**
- ☐ ログレベルが適切に設定されている
- ☐ ログ出力項目が定義されている

---

### ⚠️ 詳細設計書作成時の注意点

**やってはいけないこと:**
1. **コードを書きすぎる**
   - ❌ 実装コードを全て書く
   - ✅ 重要な処理の疑似コードやサンプル

2. **処理フローが不明確**
   - ❌ 文章だけで説明
   - ✅ フローチャートやシーケンス図を使用

3. **エラー処理を後回し**
   - ❌ 正常系だけ設計
   - ✅ 異常系も含めて設計

4. **テスト観点がない**
   - ❌ 実装だけ考える
   - ✅ テストケースも考慮

**良い実践:**
1. **実装可能なレベルまで詳細化**
2. **サンプルコードを含める**
3. **レビューを頻繁に実施**
4. **実装しながら更新**

---

### 💡 詳細設計書作成のヒント

**効率的に作成するには:**
1. **コード生成ツールを活用:** エンティティやDTOは自動生成可能
2. **既存コードを参考:** 類似機能の実装を参照
3. **ペアプログラミング:** 設計しながら実装も検討

**品質を高めるには:**
1. **早期に実装を開始:** 設計と実装を並行
2. **単体テストを先に書く:** TDD(テスト駆動開発)
3. **コードレビューと設計レビューを連動:** 実装と設計の整合性確保

**関連用語:** クラス設計、処理フロー、エラー処理、ログ設計、単体テスト

---


## 8.4 テスト仕様書テンプレート

**重要度:** ★★★★★

テスト仕様書は、システムの品質を保証するために**何をどのようにテストするか**を定義するドキュメントです。

### 📄 テスト仕様書の全体構成

```mermaid
graph TD
    A[テスト仕様書] --> B[1. テスト計画]
    A --> C[2. テスト項目]
    A --> D[3. テストケース]
    A --> E[4. テストデータ]
    A --> F[5. テスト結果]
    
    B --> B1[テスト方針・<br/>スケジュール]
    C --> C1[テスト項目一覧・<br/>優先度]
    D --> D1[詳細手順・<br/>期待結果]
    E --> E1[テストデータ・<br/>環境]
    F --> F1[実施結果・<br/>不具合管理]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#f3e5f5,stroke:#7b1fa2
    style D fill:#e8f5e9,stroke:#2e7d32
    style E fill:#fff9c4,stroke:#f57f17
    style F fill:#fce4ec,stroke:#c2185b
```

---

### 📋 テスト仕様書テンプレート

```markdown
# テスト仕様書
# Test Specification

---

## ドキュメント管理情報

| 項目 | 内容 |
|------|------|
| **文書番号** | TEST-[プロジェクト名]-001 |
| **文書名** | [システム名] テスト仕様書 |
| **テスト種別** | [単体/結合/システム/受入] |
| **バージョン** | 1.0 |
| **作成日** | YYYY/MM/DD |
| **作成者** | [氏名・所属] |
| **ベース文書** | [設計書番号] |

---

## 1. テスト計画

### 1.1 テストの目的
[このテストで何を確認するかを記述]
- 機能が要件通りに動作することを確認
- 非機能要件(性能、セキュリティ)の検証
- システム全体の品質保証

### 1.2 テスト方針

| 項目 | 方針 |
|------|------|
| **テスト範囲** | [対象機能・対象外機能] |
| **テスト手法** | [手動/自動化] |
| **品質基準** | [合格基準: 重大バグ0件、バグ密度XX件/KLOC] |
| **中止基準** | [テスト中止の条件] |

### 1.3 テストスケジュール

| フェーズ | 開始日 | 終了日 | 担当者 | 状態 |
|---------|--------|--------|--------|------|
| テスト設計 | YYYY/MM/DD | YYYY/MM/DD | [氏名] | [状態] |
| テスト実施 | YYYY/MM/DD | YYYY/MM/DD | [氏名] | [状態] |
| バグ修正 | YYYY/MM/DD | YYYY/MM/DD | [氏名] | [状態] |
| 再テスト | YYYY/MM/DD | YYYY/MM/DD | [氏名] | [状態] |

### 1.4 テスト環境

#### ハードウェア
- サーバー: [スペック]
- クライアント: [スペック]
- ネットワーク: [構成]

#### ソフトウェア
- OS: [バージョン]
- ブラウザ: [種類とバージョン]
- データベース: [製品とバージョン]
- テストツール: [ツール名]

### 1.5 テスト体制

| 役割 | 氏名 | 責任範囲 |
|------|------|---------|
| テストリーダー | [氏名] | [責任範囲] |
| テスター | [氏名] | [責任範囲] |
| 開発担当 | [氏名] | バグ修正 |

---

## 2. テスト項目一覧

### 2.1 機能テスト項目

| 項目ID | 大分類 | 中分類 | 小分類 | 優先度 | ケース数 |
|--------|--------|--------|--------|--------|---------|
| T-001 | ユーザー管理 | ログイン | 正常系 | 高 | 5 |
| T-002 | ユーザー管理 | ログイン | 異常系 | 高 | 8 |
| T-003 | ユーザー管理 | ユーザー登録 | 正常系 | 高 | 3 |
| T-004 | ユーザー管理 | ユーザー登録 | 異常系 | 高 | 10 |
| T-005 | データ管理 | データ作成 | 正常系 | 中 | 4 |

### 2.2 非機能テスト項目

| 項目ID | テスト種別 | テスト内容 | 目標値 |
|--------|-----------|----------|--------|
| NF-001 | 性能テスト | レスポンスタイム | 1秒以内 |
| NF-002 | 性能テスト | 同時接続数 | 10,000ユーザー |
| NF-003 | 負荷テスト | スループット | 1000TPS |
| NF-004 | セキュリティテスト | 脆弱性診断 | 重大な脆弱性0件 |
| NF-005 | ユーザビリティテスト | 操作性 | タスク完了率90%以上 |

---

## 3. テストケース詳細

### 3.1 テストケーステンプレート

**テストケースID:** T-001-01

**テストケース名:** ログイン - 正常系(有効な認証情報)

**分類:** 機能テスト > ユーザー管理 > ログイン

**優先度:** 高 ★★★

**前提条件:**
- ユーザー「test_user」がDB に登録されている
- パスワードは「Password123!」
- ブラウザでログイン画面を表示している

**テストデータ:**
| 項目 | 値 |
|------|-----|
| ユーザー名 | test_user |
| パスワード | Password123! |

**テスト手順:**
1. ユーザー名に「test_user」を入力
2. パスワードに「Password123!」を入力
3. 「ログイン」ボタンをクリック

**期待結果:**
1. ダッシュボード画面に遷移する
2. 画面右上に「test_user」のユーザー名が表示される
3. セッションが確立される(Cookie確認)
4. ログイン成功のログが出力される

**実施結果:**
| 項目 | 結果 |
|------|------|
| 実施日 | YYYY/MM/DD |
| 実施者 | [氏名] |
| 判定 | [OK/NG] |
| 備考 | [特記事項] |

---

### 3.2 テストケース例(異常系)

**テストケースID:** T-002-01

**テストケース名:** ログイン - 異常系(パスワード誤り)

**優先度:** 高 ★★★

**前提条件:**
- ユーザー「test_user」がDBに登録されている
- 正しいパスワードは「Password123!」

**テストデータ:**
| 項目 | 値 |
|------|-----|
| ユーザー名 | test_user |
| パスワード | WrongPassword |

**テスト手順:**
1. ユーザー名に「test_user」を入力
2. パスワードに「WrongPassword」を入力
3. 「ログイン」ボタンをクリック

**期待結果:**
1. エラーメッセージが表示される
   - 「ユーザー名またはパスワードが正しくありません」
2. ログイン画面のまま遷移しない
3. パスワード入力欄がクリアされる
4. ログイン失敗のログが出力される
5. 失敗回数がカウントされる(3回でアカウントロック)

---

### 3.3 境界値テスト

**テストケースID:** T-004-03

**テストケース名:** ユーザー登録 - 境界値(ユーザー名最小文字数)

**テスト観点:** ユーザー名は3文字以上50文字以下

| ケース | 文字数 | 入力値 | 期待結果 |
|--------|--------|--------|---------|
| 最小値-1 | 2文字 | "ab" | エラー: 3文字以上必要 |
| 最小値 | 3文字 | "abc" | 正常: 登録成功 |
| 最大値 | 50文字 | "a...a"(50文字) | 正常: 登録成功 |
| 最大値+1 | 51文字 | "a...a"(51文字) | エラー: 50文字以下必要 |

---

## 4. テストデータ

### 4.1 マスターデータ

**ユーザーマスター:**
| ID | ユーザー名 | メール | パスワード | 権限 | 用途 |
|----|----------|--------|-----------|------|------|
| 1 | admin | admin@example.com | Admin123! | 管理者 | 管理者権限テスト |
| 2 | test_user | test@example.com | Password123! | 一般 | 一般ユーザーテスト |
| 3 | readonly | readonly@example.com | Read123! | 閲覧 | 閲覧権限テスト |

### 4.2 トランザクションデータ

**注文データ:**
| 注文ID | ユーザーID | 商品ID | 数量 | 金額 | 状態 |
|--------|-----------|--------|------|------|------|
| 1001 | 2 | 101 | 2 | 2000 | 完了 |
| 1002 | 2 | 102 | 1 | 1500 | 処理中 |
| 1003 | 3 | 103 | 5 | 5000 | キャンセル |

### 4.3 異常系データ

**不正な入力値:**
- SQLインジェクション: `' OR '1'='1`
- XSS: `<script>alert('XSS')</script>`
- 特殊文字: `!@#$%^&*()`
- 長文字列: 10,000文字の文字列
- NULL値: `null`

---

## 5. テスト結果

### 5.1 テスト実施サマリー

| テスト種別 | 計画数 | 実施数 | 合格数 | 不合格数 | 実施率 | 合格率 |
|-----------|--------|--------|--------|---------|--------|--------|
| 機能テスト | 100 | 100 | 95 | 5 | 100% | 95% |
| 性能テスト | 10 | 10 | 9 | 1 | 100% | 90% |
| セキュリティテスト | 20 | 20 | 18 | 2 | 100% | 90% |
| **合計** | **130** | **130** | **122** | **8** | **100%** | **93.8%** |

### 5.2 不具合サマリー

| 重要度 | 未対応 | 対応中 | 修正完了 | 再テストOK | 合計 |
|--------|--------|--------|---------|-----------|------|
| 致命的(Critical) | 0 | 0 | 2 | 2 | 2 |
| 重大(Major) | 1 | 2 | 3 | 3 | 6 |
| 軽微(Minor) | 3 | 5 | 10 | 10 | 18 |
| 提案(Trivial) | 5 | 0 | 2 | 2 | 7 |
| **合計** | **9** | **7** | **17** | **17** | **33** |

### 5.3 不具合一覧

| Bug ID | 重要度 | 概要 | 発見日 | 状態 | 修正予定日 |
|--------|--------|------|--------|------|-----------|
| BUG-001 | Major | ログイン後にセッションタイムアウト | 2025/01/10 | 修正完了 | - |
| BUG-002 | Critical | 決済処理で二重課金 | 2025/01/12 | 修正完了 | - |
| BUG-003 | Minor | ボタンの配置がずれる | 2025/01/15 | 対応中 | 2025/01/20 |

---

## 6. 評価とまとめ

### 6.1 品質評価

**合格基準との比較:**
| 項目 | 基準 | 実績 | 判定 |
|------|------|------|------|
| テストケース合格率 | 95%以上 | 93.8% | NG |
| 致命的バグ | 0件 | 0件 | OK |
| 重大バグ | 2件以下 | 3件(全て修正済) | OK |

**総合評価:** [OK/NG/条件付きOK]

**判定理由:**
[判定の理由を記述]

### 6.2 残課題

| 課題 | 内容 | 優先度 | 対応予定 |
|------|------|--------|---------|
| [課題1] | [内容] | [高/中/低] | [日付] |
| [課題2] | [内容] | [高/中/低] | [日付] |

### 6.3 次フェーズへの引き継ぎ事項

- [引き継ぎ事項1]
- [引き継ぎ事項2]
- [引き継ぎ事項3]

---

**【文書終了】**
```

---

### ✅ テスト仕様書作成時のチェックリスト

**1. テスト計画:**

- ☐ テストの目的が明確である
- ☐ テストスコープが定義されている
- ☐ スケジュールが現実的である
- ☐ テスト環境が準備されている

**2. テスト項目:**

- ☐ 全機能がカバーされている
- ☐ 優先度が設定されている
- ☐ 非機能要件も含まれている

**3. テストケース:**

- ☐ 正常系・異常系が網羅されている
- ☐ 期待結果が明確である
- ☐ 再現手順が詳細である
- ☐ 境界値テストが含まれている

**4. テストデータ:**

- ☐ 必要なデータが準備されている
- ☐ 異常系データも用意されている

**5. テスト結果:**

- ☐ 実施結果が記録されている
- ☐ 不具合が適切に管理されている
- ☐ 品質評価が実施されている

---

### ⚠️ テスト仕様書作成時の注意点

**やってはいけないこと:**

1. **曖昧な期待結果**
   - ❌ 「正常に動作する」
   - ✅ 「ダッシュボード画面に遷移し、ユーザー名が表示される」

2. **再現手順が不明確**
   - ❌ 「ログインしてデータを入力」
   - ✅ 「1. ログイン画面で...、2. データ入力画面で...」

3. **異常系テストの不足**
   - ❌ 正常系だけテスト
   - ✅ 異常系・境界値も十分にテスト

4. **テストデータの準備不足**
   - ❌ テスト直前にデータ作成
   - ✅ 事前にテストデータを準備

**良い実践:**

1. **早期にテスト設計を開始:** 設計段階からテスト観点を考える
2. **自動化を検討:** 繰り返しテストは自動化
3. **リスクベーステスト:** 重要な機能を優先的にテスト
4. **継続的にテスト:** 開発中も継続的にテスト実施

---

### 💡 テスト仕様書作成のヒント

**効率的に作成するには:**

1. **テンプレートを活用:** 標準フォーマットで統一
2. **ツールを使う:** JiraやTestRailなどのテスト管理ツール
3. **過去のテストケースを流用:** 類似機能のケースを参考

**品質を高めるには:**

1. **レビューを実施:** 複数人でテストケースを確認
2. **探索的テストも実施:** スクリプトテストだけでなく自由なテストも
3. **ユーザー視点でテスト:** 実際の使用シーンを想定

**テスト自動化のポイント:**

1. **UIテスト:** Selenium、Playwrightなど
2. **APIテスト:** Postman、REST Assured など
3. **単体テスト:** JUnit、pytest など
4. **CI/CDに組み込む:** 自動テストをパイプラインに統合

**関連用語:** テスト計画、テストケース、テストデータ、不具合管理、品質保証

---

## 8.5 その他のテンプレート

**重要度:** ★★★☆☆

システム開発では、設計書やテスト仕様書以外にも様々なドキュメントが必要です。ここでは実務でよく使用されるテンプレートを紹介します。

### 📋 その他のテンプレート一覧

```mermaid
graph LR
    A[その他の<br/>テンプレート] --> B[議事録]
    A --> C[課題管理表]
    A --> D[リリースノート]
    A --> E[運用手順書]
    A --> F[ADR]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#f3e5f5,stroke:#7b1fa2
    style D fill:#e8f5e9,stroke:#2e7d32
    style E fill:#fff9c4,stroke:#f57f17
    style F fill:#fce4ec,stroke:#c2185b
```

---

### 8.5.1 プロジェクト議事録テンプレート

```markdown
# プロジェクト議事録

## 会議情報

| 項目 | 内容 |
|------|------|
| **会議名** | [会議名] |
| **日時** | YYYY/MM/DD HH:MM-HH:MM |
| **場所** | [会議室/オンライン] |
| **議事録作成者** | [氏名] |

## 参加者

| 氏名 | 所属 | 役割 |
|------|------|------|
| [氏名1] | [所属] | [役割] |
| [氏名2] | [所属] | [役割] |

## 欠席者
- [氏名] ([所属])

---

## 議題

### 1. [議題1のタイトル]

**討議内容:**
- [内容1]
- [内容2]

**決定事項:**
- [決定1]
- [決定2]

**アクションアイテム:**
| タスク | 担当者 | 期限 | 状態 |
|--------|--------|------|------|
| [タスク1] | [氏名] | YYYY/MM/DD | [未着手/進行中/完了] |
| [タスク2] | [氏名] | YYYY/MM/DD | [未着手/進行中/完了] |

---

### 2. [議題2のタイトル]

**討議内容:**
[内容を記述]

**決定事項:**
[決定事項を記述]

---

## 次回会議

- **日時:** YYYY/MM/DD HH:MM
- **議題:** [次回の議題]

---

**【議事録終了】**
```

---

### 8.5.2 課題管理表テンプレート

```markdown
# 課題管理表
# Issue Tracking Log

## プロジェクト情報
- **プロジェクト名:** [プロジェクト名]
- **期間:** YYYY/MM/DD ~ YYYY/MM/DD
- **更新日:** YYYY/MM/DD

---

## 課題サマリー

| 状態 | 件数 |
|------|------|
| 未対応 | [件数] |
| 対応中 | [件数] |
| 対応完了 | [件数] |
| 保留 | [件数] |
| **合計** | **[件数]** |

---

## 課題一覧

| ID | 優先度 | カテゴリ | 課題内容 | 影響範囲 | 起票者 | 担当者 | 起票日 | 期限 | 状態 | 備考 |
|----|--------|---------|---------|---------|--------|--------|--------|------|------|------|
| ISS-001 | 高 | 要件 | [課題内容] | [影響] | [氏名] | [氏名] | YYYY/MM/DD | YYYY/MM/DD | 対応中 | [備考] |
| ISS-002 | 中 | 設計 | [課題内容] | [影響] | [氏名] | [氏名] | YYYY/MM/DD | YYYY/MM/DD | 未対応 | [備考] |
| ISS-003 | 低 | 運用 | [課題内容] | [影響] | [氏名] | [氏名] | YYYY/MM/DD | YYYY/MM/DD | 完了 | [備考] |

---

## 課題詳細

### ISS-001: [課題タイトル]

**優先度:** 高 ★★★

**カテゴリ:** 要件

**発生日:** YYYY/MM/DD

**起票者:** [氏名]

**担当者:** [氏名]

**状態:** 対応中

**課題内容:**
[詳細な課題内容を記述]

**影響範囲:**
- [影響1]
- [影響2]

**原因:**
[課題の原因を記述]

**対応方針:**
[対応方針を記述]

**対応履歴:**
| 日付 | 対応者 | 対応内容 |
|------|--------|---------|
| YYYY/MM/DD | [氏名] | [内容] |
| YYYY/MM/DD | [氏名] | [内容] |

**備考:**
[その他の情報]

---

**【文書終了】**
```

---

### 8.5.3 リリースノートテンプレート

```markdown
# リリースノート
# Release Notes

## リリース情報

| 項目 | 内容 |
|------|------|
| **バージョン** | v1.2.0 |
| **リリース日** | YYYY/MM/DD |
| **リリース種別** | [メジャー/マイナー/パッチ] |
| **対象環境** | 本番環境 |

---

## 📦 新機能

### ユーザー管理機能の拡張
- **機能ID:** FR-101
- **概要:** 2段階認証(2FA)のサポートを追加
- **詳細:**
  - SMS認証に対応
  - 認証アプリ(TOTP)に対応
  - バックアップコードの生成機能
- **影響:** 既存ユーザーは次回ログイン時に2FA設定を促される

### ダッシュボードの刷新
- **機能ID:** FR-102
- **概要:** 新しいダッシュボードデザイン
- **詳細:**
  - リアルタイムグラフ表示
  - カスタマイズ可能なウィジェット
  - レスポンシブデザイン対応

---

## 🔧 改善

### パフォーマンス改善
- API応答時間を平均30%改善
- データベースクエリの最適化
- キャッシュ戦略の改善

### UI/UX改善
- ボタンの配置を統一
- エラーメッセージをより分かりやすく
- 読み込み中のインジケータを追加

---

## 🐛 バグ修正

| Bug ID | 概要 | 影響 |
|--------|------|------|
| BUG-201 | ログイン後のセッションタイムアウト | 一部ユーザーで発生 |
| BUG-202 | 決済処理の二重課金 | 重大 - 全ユーザー |
| BUG-203 | 画像アップロードの失敗 | 中程度 |

---

## ⚠️ 破壊的変更

### API変更
- **エンドポイント:** `/api/v1/users`
- **変更内容:** レスポンス形式の変更
- **移行方法:** [移行ガイドへのリンク]

---

## 📝 既知の問題

- Safariブラウザで一部CSSが正しく表示されない(次回リリースで修正予定)
- 大容量ファイルのアップロードに時間がかかる(調査中)

---

## 🔄 アップグレード手順

1. データベースのバックアップを取得
   ```bash
   pg_dump -U postgres mydb > backup_YYYYMMDD.sql
   ```

2. アプリケーションを停止

   ```bash
   systemctl stop myapp
   ```

3. 新バージョンをデプロイ

   ```bash
   git pull origin main
   npm install
   npm run build
   ```

4. データベースマイグレーション実行

   ```bash
   npm run migrate
   ```

5. アプリケーションを起動

   ```bash
   systemctl start myapp
   ```

6. 動作確認
   - ヘルスチェックエンドポイントの確認
   - 主要機能の動作確認

---

## ⏪ ロールバック手順

問題が発生した場合は、以下の手順でロールバックします:

1. アプリケーションを停止
2. 前バージョンに戻す
3. データベースをリストア(必要に応じて)
4. アプリケーションを起動

---

## 📞 サポート情報

問題が発生した場合:

- **技術サポート:** <support@example.com>
- **緊急連絡先:** +81-XX-XXXX-XXXX
- **ドキュメント:** <https://docs.example.com>

---

**【リリースノート終了】**

```

---

### 8.5.4 運用手順書テンプレート

```markdown
# 運用手順書
# Operations Manual

## 文書情報

| 項目 | 内容 |
|------|------|
| **システム名** | [システム名] |
| **バージョン** | 1.0 |
| **作成日** | YYYY/MM/DD |
| **対象者** | 運用担当者 |

---

## 1. 日次運用

### 1.1 朝の起動確認(9:00)

**目的:** システムの正常稼働を確認

**手順:**
1. 監視ダッシュボードにアクセス
   - URL: https://monitor.example.com
   - ログイン情報: [別紙参照]

2. ヘルスチェック確認
   ```bash
   curl https://api.example.com/health
   ```

   **期待結果:**

   ```json
   {"status": "healthy"}
   ```

3. エラーログ確認

   ```bash
   tail -n 100 /var/log/app/error.log
   ```

   - エラーがないことを確認

4. リソース使用状況確認
   - CPU使用率: 80%以下
   - メモリ使用率: 85%以下
   - ディスク使用率: 80%以下

**異常時の対応:**

- [対応手順へのリンク]

---

### 1.2 バックアップ確認(10:00)

**目的:** 前日のバックアップが正常に完了したことを確認

**手順:**

1. バックアップログ確認

   ```bash
   cat /var/log/backup/backup_$(date +%Y%m%d).log
   ```

2. バックアップファイルの存在確認

   ```bash
   ls -lh /backup/db/mydb_$(date +%Y%m%d).sql.gz
   ```

3. バックアップファイルサイズの確認
   - 前日との比較で大きな変動がないか確認

**異常時の対応:**

- バックアップが失敗している場合は手動で再実行

  ```bash
  /opt/scripts/backup.sh
  ```

---

## 2. 定期運用

### 2.1 週次運用(毎週月曜 10:00)

**ログファイルのローテーション:**

```bash
/opt/scripts/log_rotation.sh
```

**ディスク容量の確認:**

```bash
df -h
```

- 80%を超える場合は古いログを削除

---

### 2.2 月次運用(毎月1日 10:00)

**セキュリティパッチ適用:**

1. パッチ情報の確認
2. テスト環境での検証
3. 本番環境への適用(要承認)

**パフォーマンスレポート作成:**

- 月次のシステムパフォーマンスをまとめる
- [レポートテンプレート]

---

## 3. 障害対応

### 3.1 システムダウン時の対応

**レベル1: サービス停止**

**対応手順:**

1. 障害を検知したら即座にエスカレーション
   - 連絡先: [緊急連絡先]

2. サービス状況の確認

   ```bash
   systemctl status myapp
   ```

3. 再起動を試みる

   ```bash
   systemctl restart myapp
   ```

4. ログを確認

   ```bash
   journalctl -u myapp -n 100
   ```

5. 復旧しない場合は開発チームにエスカレーション

---

## 4. 緊急連絡先

| 役割 | 氏名 | 電話番号 | メール | 対応時間 |
|------|------|---------|--------|---------|
| 運用責任者 | [氏名] | [番号] | [メール] | 24時間 |
| 開発リーダー | [氏名] | [番号] | [メール] | 平日9-18時 |
| インフラ担当 | [氏名] | [番号] | [メール] | 24時間 |

---

**【運用手順書終了】**

```

---

### 8.5.5 ADR(設計判断記録)テンプレート

```markdown
# ADR-001: [意思決定のタイトル]

## ステータス
[提案中 / 承認済み / 却下 / 廃止 / 置換]

## コンテキスト(状況・背景)

[この意思決定が必要になった状況や背景を記述]

例:
- 現在のシステムはモノリシックアーキテクチャで構築されている
- サービスの成長に伴い、開発スピードの低下が問題となっている
- 特定機能の障害が全体に影響する問題がある

---

## 決定内容

[何を決定したか、採用する解決策を明確に記述]

例:
マイクロサービスアーキテクチャへの段階的な移行を決定する。
最初のステップとして、以下の3つのサービスを分離する:
1. 認証サービス
2. ユーザー管理サービス
3. 通知サービス

---

## 理由

[なぜこの決定をしたのか、複数の選択肢がある場合は比較も記述]

### メリット:
- 各サービスを独立して開発・デプロイ可能
- 障害の影響範囲を限定できる
- チームごとに異なる技術スタックを選択可能

### デメリット:
- システム全体の複雑性が増加
- サービス間通信のオーバーヘッド
- 運用コストの増加

### 代替案との比較:
| 案 | メリット | デメリット | 選定理由 |
|----|---------|----------|---------|
| モノリス維持 | シンプル | スケーラビリティ不足 | - |
| 完全マイクロサービス化 | 最大の柔軟性 | リスク大、コスト高 | - |
| **段階的移行** | **リスク管理可能** | **期間が長い** | **採用** |

---

## 影響

[この決定が与える影響を記述]

**技術的影響:**
- サービス間通信にはREST APIを使用
- 各サービスは独立したDBを持つ
- API Gatewayの導入が必要

**組織的影響:**
- チーム構成の見直しが必要
- マイクロサービスに関する学習コストが発生

**スケジュール影響:**
- 移行期間: 6ヶ月を想定
- 段階的リリースのため、全体スケジュールへの影響は限定的

---

## 注記

**関連する決定:**
- ADR-002: API Gateway製品の選定

**参照資料:**
- [マイクロサービス設計ガイド]
- [社内アーキテクチャ標準]

**決定者:**
- システムアーキテクト: [氏名]
- プロジェクトマネージャー: [氏名]

**決定日:** YYYY/MM/DD

**レビュー日:** YYYY/MM/DD

---

**【ADR終了】**
```

---

## 第8章のまとめ

本章では、**実践で即座に使えるテンプレート集**を提供しました。

### 提供したテンプレート一覧

| テンプレート | 用途 | 重要度 |
|------------|------|--------|
| **8.1 SRS** | 要求仕様書 | ★★★★★ |
| **8.2 基本設計書** | アーキテクチャ設計 | ★★★★★ |
| **8.3 詳細設計書** | 実装レベル設計 | ★★★★☆ |
| **8.4 テスト仕様書** | テスト計画・実施 | ★★★★★ |
| **8.5 その他** | 議事録・課題管理等 | ★★★☆☆ |

### テンプレート活用のポイント

```mermaid
graph LR
    A[テンプレート<br/>活用] --> B[カスタマイズ]
    A --> C[継続的更新]
    A --> D[チーム共有]
    A --> E[ツール連携]
    
    B --> B1[プロジェクトに<br/>合わせて調整]
    C --> C1[開発中も<br/>最新に保つ]
    D --> D1[チーム全体で<br/>統一フォーマット]
    E --> E1[Jira等の<br/>ツールと連携]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#fff3e0
    style C fill:#f3e5f5
    style D fill:#e8f5e9
    style E fill:#fff9c4
```

### ðŸ'¡ テンプレート使用のベストプラクティス

1. **プロジェクトに合わせてカスタマイズ**
   - 不要な項目は削除
   - 必要な項目は追加
   - プロジェクト固有のルールを反映

2. **バージョン管理**
   - テンプレート自体もバージョン管理
   - 変更履歴を記録
   - チーム全体で最新版を共有

3. **自動化の検討**
   - ツールを使った自動生成
   - テンプレートからの項目抽出
   - レポート生成の自動化

4. **定期的な見直し**
   - プロジェクト終了後にテンプレートを改善
   - フィードバックを次回に活かす
   - 業界のベストプラクティスを取り入れる

### 次のステップ

テンプレートを実際に使用する際は:

1. **小さく始める:** 最初は最小限の項目から
2. **段階的に充実:** プロジェクトの進行に合わせて追記
3. **レビューを重ねる:** チームでレビューして品質向上
4. **ツールを活用:** Confluence、Notion等でテンプレート管理

---

**次の第9章では、各フェーズのチェックリストとベストプラクティスを提供します。**

---

# 第9章：チェックリストとベストプラクティス

## 9.1 各フェーズのゲートチェックリスト

各開発フェーズの終了時に確認すべき項目をまとめました。これらのチェックリストを使うことで、**次のフェーズに進む前に必要な成果物が揃っているか**を確認できます。

### 🎯 チェックリストの使い方

```mermaid
graph LR
    A[フェーズ完了] --> B[チェックリスト<br/>で確認]
    B --> C{全て<br/>OK?}
    C -->|Yes| D[次フェーズへ]
    C -->|No| E[不足項目を<br/>完成させる]
    E --> B
    
    style A fill:#e1f5ff,stroke:#0277bd
    style B fill:#fff3e0,stroke:#ef6c00
    style C fill:#ffcdd2,stroke:#c62828
    style D fill:#c8e6c9,stroke:#2e7d32
    style E fill:#fff9c4,stroke:#f57f17
```

---

### 9.1.1 ①企画・課題定義フェーズのチェックリスト

**目的:** プロジェクトの目的と範囲が明確になっているか確認

| チェック項目 | 確認内容 | 重要度 | チェック |
|------------|---------|--------|---------|
| **ビジネス目標** | 解決したい課題が明確に定義されているか | ★★★★★ | □ |
| **効果測定** | プロジェクトの成功基準が数値で定義されているか | ★★★★★ | □ |
| **ステークホルダー** | 関係者全員が洗い出され、役割が明確か | ★★★★☆ | □ |
| **予算** | プロジェクト予算が承認されているか | ★★★★★ | □ |
| **スケジュール** | ざっくりとしたスケジュールが定義されているか | ★★★★☆ | □ |
| **制約条件** | 技術的・ビジネス的制約が明確か | ★★★★☆ | □ |
| **リスク** | 主要なリスクが洗い出されているか | ★★★★☆ | □ |
| **承認** | 経営層からプロジェクト実施の承認を得ているか | ★★★★★ | □ |

**📄 必須成果物チェック:**

- [ ] 企画書 or プロジェクト憲章
- [ ] RFP（提案依頼書）※外部発注の場合
- [ ] プロジェクト計画書（概要版)
- [ ] リスク管理表

**⚠️ よくある不備:**

- ❌ 「売上を上げる」など抽象的な目標のみ
- ❌ ステークホルダーの一部が漏れている
- ❌ 予算が未確定のまま次フェーズに進む

**✅ 合格基準:**
> 「なぜこのプロジェクトをやるのか」をチーム全員が同じ言葉で説明できる

---

### 9.1.2 ②要件定義フェーズのチェックリスト

**目的:** 何を作るかが具体的かつ明確になっているか確認

| チェック項目 | 確認内容 | 重要度 | チェック |
|------------|---------|--------|---------|
| **機能要件** | 全ての機能がリスト化され、優先順位付けされているか | ★★★★★ | □ |
| **非機能要件** | 性能・セキュリティ・可用性が定義されているか | ★★★★★ | □ |
| **ユースケース** | 主要なユースケースが図と説明で記述されているか | ★★★★☆ | □ |
| **画面仕様** | 主要画面の遷移図とワイヤーフレームがあるか | ★★★★☆ | □ |
| **データ定義** | 主要なデータ項目と関係性が定義されているか | ★★★★★ | □ |
| **インターフェース** | 外部システムとの連携仕様が明確か | ★★★★☆ | □ |
| **受入基準** | 各機能の完成条件が定義されているか | ★★★★★ | □ |
| **レビュー** | ステークホルダー全員のレビューを得ているか | ★★★★★ | □ |
| **承認** | 要件定義書が正式に承認されているか | ★★★★★ | □ |

**📄 必須成果物チェック:**

- [ ] SRS（要求仕様書）
- [ ] ユースケース図・ユーザーストーリー
- [ ] 画面遷移図・ワイヤーフレーム
- [ ] ER図（エンティティリレーションシップ図）
- [ ] 非機能要件定義書

**⚠️ よくある不備:**

- ❌ 「使いやすい」など曖昧な表現
- ❌ 非機能要件が「後で決める」状態
- ❌ エラー処理や例外パターンの記載漏れ
- ❌ 「当然できるだろう」と思い込んで記載しない

**✅ 合格基準:**
> 要件定義書を読めば、開発者が具体的に何を作ればいいか理解できる

---

### 9.1.3 ③基本設計フェーズのチェックリスト

**目的:** システム全体の設計方針と構造が明確になっているか確認

| チェック項目 | 確認内容 | 重要度 | チェック |
|------------|---------|--------|---------|
| **アーキテクチャ** | システム全体のアーキテクチャが図で示されているか | ★★★★★ | □ |
| **技術選定** | 使用する技術スタックが決定し、理由が明確か | ★★★★★ | □ |
| **コンポーネント設計** | 主要なコンポーネントと責務が定義されているか | ★★★★★ | □ |
| **データベース設計** | テーブル定義とリレーションが明確か | ★★★★★ | □ |
| **API設計** | インターフェース仕様が定義されているか | ★★★★☆ | □ |
| **セキュリティ設計** | 認証・認可・暗号化の方針が明確か | ★★★★★ | □ |
| **性能設計** | 性能要件を満たすための設計になっているか | ★★★★☆ | □ |
| **運用設計** | ログ・監視・バックアップ方針が定義されているか | ★★★★☆ | □ |
| **設計レビュー** | アーキテクトによるレビューを受けているか | ★★★★★ | □ |

**📄 必須成果物チェック:**

- [ ] 基本設計書
- [ ] アーキテクチャ図（C4モデルのContext, Container図）
- [ ] データベース設計書（論理設計）
- [ ] API仕様書（概要）
- [ ] 非機能要件の設計方針書

**⚠️ よくある不備:**

- ❌ アーキテクチャ図が抽象的すぎる
- ❌ 技術選定の理由が「なんとなく」
- ❌ セキュリティ設計が後回し
- ❌ スケーラビリティを考慮していない

**✅ 合格基準:**
> 基本設計書を読めば、システムの全体像と主要な設計判断が理解できる

---

### 9.1.4 ④詳細設計フェーズのチェックリスト

**目的:** 実装に必要な情報が全て揃っているか確認

| チェック項目 | 確認内容 | 重要度 | チェック |
|------------|---------|--------|---------|
| **クラス設計** | クラス図とクラスの責務が明確か | ★★★★☆ | □ |
| **シーケンス図** | 主要な処理フローが図示されているか | ★★★★☆ | □ |
| **データベース詳細** | テーブル定義（カラム、型、制約）が完全か | ★★★★★ | □ |
| **API詳細** | エンドポイント、パラメータ、レスポンスが明確か | ★★★★★ | □ |
| **エラー処理** | 例外ケースとエラーハンドリングが定義されているか | ★★★★★ | □ |
| **バリデーション** | 入力チェックのルールが明確か | ★★★★☆ | □ |
| **画面詳細** | 画面ごとの項目、動作、バリデーションが定義されているか | ★★★★☆ | □ |
| **テストデータ** | テスト用のデータ設計がされているか | ★★★☆☆ | □ |

**📄 必須成果物チェック:**

- [ ] 詳細設計書
- [ ] クラス図・シーケンス図
- [ ] データベース設計書（物理設計）
- [ ] API仕様書（詳細版）
- [ ] 画面設計書

**⚠️ よくある不備:**

- ❌ 「コード見ればわかる」として設計書が不十分
- ❌ 正常系のみで異常系が未定義
- ❌ データベースのインデックス設計が漏れている

**✅ 合格基準:**
> 詳細設計書を読めば、開発者がコードを書き始められる

---

### 9.1.5 ⑤実装・開発フェーズのチェックリスト

**目的:** コードの品質と実装の完全性を確認

| チェック項目 | 確認内容 | 重要度 | チェック |
|------------|---------|--------|---------|
| **コーディング規約** | チーム統一のコーディングルールに従っているか | ★★★★☆ | □ |
| **ユニットテスト** | 主要な関数にユニットテストが書かれているか | ★★★★★ | □ |
| **コードレビュー** | 全てのコードがレビューされているか | ★★★★★ | □ |
| **コメント** | 複雑なロジックに適切なコメントがあるか | ★★★☆☆ | □ |
| **エラーハンドリング** | 例外処理が適切に実装されているか | ★★★★★ | □ |
| **ログ出力** | デバッグに必要なログが出力されているか | ★★★★☆ | □ |
| **セキュリティ** | SQLインジェクション等の脆弱性対策ができているか | ★★★★★ | □ |
| **パフォーマンス** | 性能要件を満たしているか | ★★★★☆ | □ |
| **ドキュメント更新** | コード変更に合わせて設計書を更新しているか | ★★★☆☆ | □ |

**📄 必須成果物チェック:**

- [ ] ソースコード（バージョン管理されている）
- [ ] ユニットテストコード
- [ ] コードレビュー記録
- [ ] README・開発者向けドキュメント

**⚠️ よくある不備:**

- ❌ テストコードが書かれていない
- ❌ ハードコーディングされた値が多い
- ❌ エラー処理が適当（握りつぶしている）
- ❌ 設計書との乖離が放置されている

**✅ 合格基準:**
> コードが自己説明的で、他の開発者が理解・修正できる状態

---

### 9.1.6 ⑥テストフェーズのチェックリスト

**目的:** システムが要件を満たし、品質基準をクリアしているか確認

| チェック項目 | 確認内容 | 重要度 | チェック |
|------------|---------|--------|---------|
| **テスト計画** | テスト計画書が作成され、承認されているか | ★★★★★ | □ |
| **テストケース** | 要件ごとにテストケースが作成されているか | ★★★★★ | □ |
| **テストデータ** | テスト用データが準備されているか | ★★★★☆ | □ |
| **単体テスト** | ユニットテストが全てパスしているか | ★★★★★ | □ |
| **結合テスト** | コンポーネント間の連携が正しく動作するか | ★★★★★ | □ |
| **システムテスト** | エンドツーエンドのシナリオテストが完了しているか | ★★★★★ | □ |
| **性能テスト** | 非機能要件（性能）を満たしているか | ★★★★☆ | □ |
| **セキュリティテスト** | 脆弱性診断を実施したか | ★★★★★ | □ |
| **受入テスト** | ユーザーによる受入テストが完了しているか | ★★★★★ | □ |
| **バグ管理** | 重大なバグが全て修正されているか | ★★★★★ | □ |
| **回帰テスト** | バグ修正後に再テストを実施したか | ★★★★☆ | □ |

**📄 必須成果物チェック:**

- [ ] テスト計画書
- [ ] テスト仕様書
- [ ] テスト実施結果報告書
- [ ] バグ管理表（全てクローズ）
- [ ] テストエビデンス

**⚠️ よくある不備:**

- ❌ 正常系しかテストしていない
- ❌ 性能テストを実施していない
- ❌ 既知のバグを残したままリリース
- ❌ テストエビデンスが不完全

**✅ 合格基準:**
> 本番環境で問題なく動作する自信がある

---

### 9.1.7 ⑦リリース・展開フェーズのチェックリスト

**目的:** 本番環境へ安全にリリースできる準備が整っているか確認

| チェック項目 | 確認内容 | 重要度 | チェック |
|------------|---------|--------|---------|
| **リリース計画** | リリース手順書が作成されているか | ★★★★★ | □ |
| **本番環境** | 本番環境の準備が完了しているか | ★★★★★ | □ |
| **データ移行** | データ移行スクリプトと手順が確認されているか | ★★★★★ | □ |
| **バックアップ** | ロールバック手順が用意されているか | ★★★★★ | □ |
| **監視設定** | ログ・監視・アラート設定が完了しているか | ★★★★☆ | □ |
| **ドキュメント** | 運用手順書・マニュアルが完成しているか | ★★★★☆ | □ |
| **ユーザー通知** | リリース内容がユーザーに通知されているか | ★★★★☆ | □ |
| **サポート体制** | リリース後のサポート体制が整っているか | ★★★★☆ | □ |
| **リハーサル** | リリース手順のリハーサルを実施したか | ★★★★☆ | □ |
| **承認** | リリースの最終承認を得ているか | ★★★★★ | □ |

**📄 必須成果物チェック:**

- [ ] リリース手順書
- [ ] ロールバック手順書
- [ ] 運用手順書
- [ ] ユーザーマニュアル
- [ ] リリースノート

**⚠️ よくある不備:**

- ❌ ロールバック手順が未準備
- ❌ 本番環境での動作確認をしていない
- ❌ データ移行のテストをしていない
- ❌ サポート体制が不明確

**✅ 合格基準:**
> リリースで問題が発生しても、迅速に対応・復旧できる体制が整っている

---

### 9.1.8 ⑧運用・保守フェーズのチェックリスト

**目的:** 安定したサービス運用ができる体制が整っているか確認

| チェック項目 | 確認内容 | 重要度 | チェック |
|------------|---------|--------|---------|
| **監視体制** | システム監視が24時間体制で行われているか | ★★★★★ | □ |
| **バックアップ** | 定期的なバックアップが実施されているか | ★★★★★ | □ |
| **ログ管理** | ログの収集・保管・分析体制があるか | ★★★★☆ | □ |
| **障害対応** | 障害対応フローと連絡体制が明確か | ★★★★★ | □ |
| **変更管理** | 変更リクエストの管理プロセスがあるか | ★★★★☆ | □ |
| **パッチ適用** | セキュリティパッチの適用ルールがあるか | ★★★★★ | □ |
| **性能監視** | システム性能の定期的な監視・改善があるか | ★★★☆☆ | □ |
| **ドキュメント更新** | 運用ドキュメントが最新に保たれているか | ★★★☆☆ | □ |
| **引き継ぎ** | 開発チームから運用チームへの引き継ぎが完了しているか | ★★★★★ | □ |

**📄 必須成果物チェック:**

- [ ] 運用手順書
- [ ] 障害対応手順書
- [ ] エスカレーションフロー
- [ ] 定期メンテナンス計画
- [ ] SLA（サービスレベル合意）

**⚠️ よくある不備:**

- ❌ 監視が不十分で障害に気づかない
- ❌ バックアップの取得漏れ・復旧テスト未実施
- ❌ 障害時の連絡先が不明確
- ❌ ドキュメントが古いまま

**✅ 合格基準:**
> システムが安定稼働し、問題発生時に迅速に対応できる

---

## 9.2 よくある失敗パターンと対策

システム開発プロジェクトでよく見られる失敗パターンと、その対策をまとめました。

### 📊 失敗パターン統計

```mermaid
pie title "プロジェクト失敗の主な原因（複数回答）"
    "要件定義の不備" : 42
    "コミュニケーション不足" : 28
    "スケジュール管理の甘さ" : 18
    "技術的な問題" : 7
    "その他" : 5
```

---

### 9.2.1 要件定義フェーズの失敗パターン

#### ❌ 失敗パターン1：「後で決める」症候群

**症状:**

- 「詳細は実装しながら決めればいい」
- 「この機能は必要かどうか後で判断しよう」
- 「データベース設計は開発時に考える」

**なぜ起こるか:**

- 早く開発に着手したい焦り
- 要件定義の重要性を理解していない
- ステークホルダーとの調整が面倒

**実際の被害:**

- 🔥 開発途中で大幅な仕様変更
- 💰 想定の2倍以上の開発コスト
- ⏰ 納期が3ヶ月遅延
- 😤 チームのモチベーション低下

**✅ 対策:**

1. **要件定義に十分な時間を確保**
   - プロジェクト全体の20-30%を要件定義に充てる

2. **「後で決める」を許さない文化**
   - 未決定事項リストを作り、期限を設ける

3. **プロトタイプで早期確認**
   - ワイヤーフレームやモックアップで認識を合わせる

**成功事例:**
> あるECサイトプロジェクトでは、要件定義に2ヶ月かけて詳細まで決定。
> 結果、開発中の仕様変更がほぼゼロで、予定通りリリースできた。

---

#### ❌ 失敗パターン2：「当然わかるだろう」の思い込み

**症状:**

- 「ログイン機能なんて説明不要でしょ」
- 「エラー処理は当然やってくれる」
- 「スマホ対応は当たり前」

**なぜ起こるか:**

- 自分の常識 = 相手の常識と思い込む
- 説明が面倒で省略
- 技術的な知識の差

**実際の被害:**

- 🔥 「そんな機能は聞いてない」と開発後にクレーム
- 💰 機能追加で追加費用発生
- 😡 発注者と開発者の信頼関係が悪化

**✅ 対策:**

1. **全てを明文化する**
   - 「当たり前」と思うことほど、明確に記載

2. **5W1Hで詳細化**
   - いつ、どこで、誰が、何を、なぜ、どのように

3. **具体例・画面イメージを添付**
   - 言葉だけでなく、図や画像で説明

**チェックリスト:**

```
□ エラー発生時の動作は明記したか？
□ 権限レベルごとの動作は定義したか？
□ データが存在しない場合の動作は？
□ 通信エラー時の動作は？
□ 同時アクセス時の動作は？
```

---

#### ❌ 失敗パターン3：ステークホルダーの巻き込み不足

**症状:**

- 発注者（または一部の人）とだけ要件を決める
- 現場のユーザーの意見を聞いていない
- 運用チームに後から報告

**なぜ起こるか:**

- 関係者が多すぎて調整が大変
- 意見がバラバラで まとまらない
- スケジュールが厳しく時間が取れない

**実際の被害:**

- 🔥 リリース後に「使えない」とクレーム
- 💰 運用で想定外のコストが発生
- 😤 関係者からの反発

**✅ 対策:**

1. **ステークホルダー分析を最初に実施**

   ```mermaid
   graph TD
       A[プロジェクト] --> B[発注者]
       A --> C[エンドユーザー]
       A --> D[運用チーム]
       A --> E[開発チーム]
       A --> F[セキュリティ担当]
       A --> G[経営層]
       
       B -->|要件定義参加| H[定例会議]
       C -->|ヒアリング| H
       D -->|運用設計参加| H
       
       style A fill:#e1f5ff
       style H fill:#c8e6c9
   ```

2. **定期的なレビュー会を実施**
   - 週次や隔週で全体レビュー

3. **意思決定のルールを明確化**
   - 誰が最終決定権を持つか事前に決める

---

### 9.2.2 設計フェーズの失敗パターン

#### ❌ 失敗パターン4：過剰設計（Over Engineering）

**症状:**

- 「将来のために」と複雑な設計をする
- 使われない機能を先回りして実装
- デザインパターンを使いすぎて複雑化

**なぜ起こるか:**

- エンジニアの「良いものを作りたい」という思い
- 将来の拡張性を重視しすぎ
- 技術的興味が先行

**実際の被害:**

- ⏰ 開発期間が2倍に延びる
- 🐛 複雑すぎてバグが多発
- 📚 保守が困難になる
- 💰 コストが膨れ上がる

**✅ 対策:**

1. **YAGNI原則を守る**
   - "You Aren't Gonna Need It" = 今必要ないものは作らない

2. **シンプルさを最優先**
   - 複雑な設計は本当に必要か自問する

3. **段階的な拡張を計画**
   - 最初は最小構成、必要になったら拡張

**判断基準:**

```
✅ 今のリリースで絶対に必要か？
✅ ビジネス価値があるか？
✅ シンプルに実装できるか？

❌ 「いつか使うかも」は作らない
❌ 「面白そう」だけで作らない
```

---

#### ❌ 失敗パターン5：非機能要件の軽視

**症状:**

- 「性能は後で考える」
- 「セキュリティは最後に」
- 「運用のことは運用チームが考える」

**なぜ起こるか:**

- 機能開発に注力しすぎ
- 非機能要件の重要性を理解していない
- 運用フェーズをイメージできていない

**実際の被害:**

- 🔥 リリース後に性能問題で炎上
- 💀 セキュリティ事故で情報漏洩
- 😤 運用チームから「運用できない」とクレーム

**✅ 対策:**

1. **非機能要件を要件定義で必ず決める**

   ```markdown
   【必須の非機能要件】
   ✓ 性能：応答時間、スループット、同時接続数
   ✓ セキュリティ：認証方式、暗号化、アクセス制御
   ✓ 可用性：稼働率、MTBF、MTTR
   ✓ 保守性：ログ、監視、バックアップ
   ✓ 拡張性：将来の負荷増への対応
   ```

2. **アーキテクチャレビューで必ずチェック**
   - セキュリティ専門家のレビューを受ける
   - 性能試験を設計段階で計画

3. **運用チームを設計段階から参加させる**

---

### 9.2.3 実装フェーズの失敗パターン

#### ❌ 失敗パターン6：技術的負債の放置

**症状:**

- 「とりあえず動けばいい」の積み重ね
- コードレビューをスキップ
- リファクタリングを後回し
- テストコードを書かない

**なぜ起こるか:**

- 納期に追われて品質を犠牲にする
- 「後で直す」が「永遠に直らない」
- 技術的負債の怖さを理解していない

**実際の被害:**

- 🐛 バグが多発し、品質が低下
- 🐌 機能追加が徐々に遅くなる
- 💰 保守コストが年々増大
- 😤 開発者のモチベーション低下

**✅ 対策:**

1. **「完了の定義」を明確にする**

   ```markdown
   【完了の定義 - Definition of Done】
   □ 機能が正しく動作する
   □ ユニットテストが書かれている（カバレッジ80%以上）
   □ コードレビューが完了している
   □ ドキュメントが更新されている
   □ 設計書との整合性が確認されている
   ```

2. **技術的負債の定期的な返済**
   - スプリントの20%はリファクタリングに充てる

3. **コード品質の自動チェック**
   - SonarQubeなどの静的解析ツールを導入
   - CI/CDパイプラインでテストを自動実行

---

#### ❌ 失敗パターン7：コミュニケーション不足

**症状:**

- チームメンバー間で情報共有がない
- 困っても相談しない
- 設計変更を勝手に行う

**なぜ起こるか:**

- リモートワークで会話の機会が減った
- 質問するのが恥ずかしい
- 忙しくて他人のことを気にする余裕がない

**実際の被害:**

- 🔥 同じ機能を別々の人が作ってしまう
- 🐛 整合性のない実装でバグ多発
- ⏰ 問題の発見が遅れてスケジュール遅延

**✅ 対策:**

1. **デイリースタンドアップミーティング**
   - 毎朝15分、全員で状況共有
   - 「昨日やったこと」「今日やること」「困っていること」

2. **ペアプログラミング・モブプログラミング**
   - 重要な機能は複数人で開発

3. **チャットツールの活用**
   - Slack等でいつでも相談できる環境
   - 「質問チャンネル」を作る

4. **ドキュメントの共有**
   - Confluence、Notionで情報を一元管理
   - 設計変更は必ずドキュメント更新

---

### 9.2.4 テストフェーズの失敗パターン

#### ❌ 失敗パターン8：テスト不足での見切りリリース

**症状:**

- 「重大なバグじゃないから後で直そう」
- 「時間がないのでテストをスキップ」
- 「本番で直せばいい」

**なぜ起こるか:**

- 納期が迫っている
- テストの重要性を軽視
- 「大丈夫だろう」という楽観

**実際の被害:**

- 🔥 リリース直後にシステムダウン
- 💀 データ消失や個人情報漏洩
- 💰 信用失墜と損害賠償
- 😤 ユーザーからの信頼喪失

**✅ 対策:**

1. **リリース判定基準を明確化**

   ```markdown
   【リリース可否基準】
   必須条件（1つでもNGならリリース不可）
   □ 重大度：高 のバグがゼロ
   □ セキュリティ診断でリスク無し
   □ 性能テストで基準クリア
   □ 受入テストで全シナリオ成功
   
   推奨条件
   □ 重大度：中 のバグが5件以下
   □ テストカバレッジ 80%以上
   ```

2. **テスト自動化で効率化**
   - 回帰テストを自動化
   - CI/CDでテストを自動実行

3. **段階的リリース（カナリアリリース）**
   - 一部ユーザーから段階的に展開
   - 問題があればすぐにロールバック

---

### 9.2.5 運用フェーズの失敗パターン

#### ❌ 失敗パターン9：運用設計の軽視

**症状:**

- 監視・ログが不十分
- 障害発生時の対応手順が未整備
- バックアップ・復旧手順がない

**なぜ起こるか:**

- 「開発が終われば終わり」と思っている
- 運用フェーズをイメージできていない
- 開発と運用のチームが分断

**実際の被害:**

- 🔥 障害に気づかず長時間停止
- 💀 バックアップなしでデータ消失
- ⏰ 復旧に膨大な時間がかかる

**✅ 対策:**

1. **DevOps文化の醸成**
   - 開発チームも運用を意識
   - 運用チームも開発に参加

2. **監視・アラートの整備**

   ```markdown
   【必須監視項目】
   ✓ サービスの死活監視（1分間隔）
   ✓ エラーログの監視（リアルタイム）
   ✓ リソース監視（CPU、メモリ、ディスク）
   ✓ アクセス数・レスポンス時間
   ✓ データベースの監視
   ```

3. **ランブック（運用手順書）の整備**
   - 障害対応フローチャート
   - よくある問題のトラブルシューティングガイド

---

## 9.3 成功のための10の原則

プロジェクトを成功に導くための重要な原則をまとめました。

```mermaid
graph TD
    A[プロジェクト成功] --> B[計画]
    A --> C[実行]
    A --> D[管理]
    A --> E[文化]
    
    B --> B1[原則1: 要件定義に時間をかける]
    B --> B2[原則2: 小さく始める]
    B --> B3[原則3: リスクを早期に潰す]
    
    C --> C1[原則4: 頻繁にリリースする]
    C --> C2[原則5: 自動化を推進する]
    C --> C3[原則6: 品質を妥協しない]
    
    D --> D1[原則7: 進捗を可視化する]
    D --> D2[原則8: 変更を恐れない]
    
    E --> E1[原則9: オープンなコミュニケーション]
    E --> E2[原則10: 継続的な改善]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:3px
    style B fill:#fff3e0
    style C fill:#f3e5f5
    style D fill:#c8e6c9
    style E fill:#fff9c4
```

---

### 原則1: 要件定義に時間をかける ⏰

**📌 なぜ重要か:**
要件定義の1時間の誤りは、実装では10時間、テストでは100時間のコストになります。

**✅ 実践方法:**

- プロジェクト全体の20-30%を要件定義に充てる
- 全てのステークホルダーを巻き込む
- プロトタイプで早期に認識を合わせる
- 要件定義書は「誰が読んでも同じ理解になる」レベルまで詳細化

**💡 成功事例:**
> 大手銀行のシステム刷新プロジェクト
>
> - 要件定義に6ヶ月かけた結果、開発中の仕様変更がゼロ
> - 予算・スケジュール通りに完了

---

### 原則2: 小さく始める（MVP思考）🌱

**📌 なぜ重要か:**
大きく作って失敗するより、小さく作って学ぶ方が成功確率が高い。

**✅ 実践方法:**

- MVP（Minimum Viable Product）で最小機能をリリース
- ユーザーのフィードバックを早期に得る
- 必要な機能から優先順位をつけて開発
- 「いつか使うかも」の機能は作らない（YAGNI原則）

**📊 MVP vs 完璧主義の比較:**

| 項目 | MVP思考 | 完璧主義 |
|------|---------|---------|
| リリースまでの期間 | 1-3ヶ月 | 6-12ヶ月 |
| ユーザーフィードバック | 早期に取得 | リリース後 |
| リスク | 小さい | 大きい |
| 市場適応力 | 高い | 低い |
| 失敗時の損失 | 小さい | 甚大 |

---

### 原則3: リスクを早期に潰す 🎯

**📌 なぜ重要か:**
プロジェクト後半での問題発覚は、致命的な遅延やコスト増を招きます。

**✅ 実践方法:**

1. **リスク管理表を作成**

   ```markdown
   | リスク | 影響度 | 発生確率 | 対策 | 担当 |
   |--------|--------|---------|------|------|
   | 新技術の習得不足 | 高 | 中 | 事前に技術検証 | 〇〇 |
   | API提供元の障害 | 高 | 低 | 代替手段を用意 | △△ |
   ```

2. **技術的な不確実性は早期に検証**
   - POC（Proof of Concept）で技術検証
   - スパイクで難しい部分を先に実装

3. **定期的なリスクレビュー**
   - 週次でリスク状況を確認
   - 新しいリスクの早期発見

---

### 原則4: 頻繁にリリースする 🚀

**📌 なぜ重要か:**
リリース間隔が長いと、問題の発見が遅れ、フィードバックループが回らない。

**✅ 実践方法:**

- 2週間〜1ヶ月ごとにリリース
- 継続的デリバリー(CD)の実践
- フィーチャーフラグで段階的な機能公開
- カナリアリリースでリスク軽減

**📈 リリース頻度と品質の関係:**

```mermaid
graph LR
    A[頻繁なリリース] --> B[早期フィードバック]
    B --> C[素早い改善]
    C --> D[品質向上]
    D --> A
    
    E[まとめてリリース] --> F[問題の蓄積]
    F --> G[大規模な修正]
    G --> H[品質低下]
    H --> E
    
    style A fill:#c8e6c9
    style D fill:#c8e6c9
    style E fill:#ffcdd2
    style H fill:#ffcdd2
```

---

### 原則5: 自動化を推進する 🤖

**📌 なぜ重要か:**
手動作業はミスが発生しやすく、時間もかかります。

**✅ 実践方法:**

```markdown
【自動化すべきもの】
✓ ビルド・テスト（CI）
✓ デプロイ（CD）
✓ コード品質チェック（静的解析）
✓ セキュリティスキャン
✓ ドキュメント生成
✓ バックアップ
```

**💡 投資対効果:**

- 初期コスト: 自動化設定に1-2週間
- 長期効果: 毎回のリリース時間が50-90%削減
- 品質向上: ヒューマンエラーの削減

---

### 原則6: 品質を妥協しない 💎

**📌 なぜ重要か:**
「後で直す」は「永遠に直らない」。技術的負債は複利で増えていきます。

**✅ 実践方法:**

1. **完了の定義(DoD)を守る**

   ```markdown
   【タスクの完了条件】
   □ 機能が正しく動作
   □ ユニットテスト作成（カバレッジ80%以上）
   □ コードレビュー完了
   □ ドキュメント更新
   □ 受入テスト合格
   ```

2. **技術的負債の定期的な返済**
   - スプリントの20%をリファクタリングに
   - 「Boy Scout Rule」: 触ったコードは前より良くして帰る

3. **品質メトリクスの可視化**
   - テストカバレッジ
   - コードの複雑度
   - バグ密度

---

### 原則7: 進捗を可視化する 📊

**📌 なぜ重要か:**
見えない問題は解決できません。全員が状況を把握できることが重要です。

**✅ 実践方法:**

1. **カンバンボードで作業状況を可視化**

   ```
   [TODO] → [進行中] → [レビュー] → [完了]
   ```

2. **バーンダウンチャートで進捗管理**
   - 残作業量を毎日プロット
   - スケジュール遅延を早期発見

3. **ダッシュボードで主要指標を表示**

   ```markdown
   【プロジェクトダッシュボード】
   ・残タスク数: 45/120
   ・テストカバレッジ: 78%
   ・未解決バグ: 重大3件、軽微8件
   ・今週のベロシティ: 32ポイント
   ```

---

### 原則8: 変更を恐れない 🔄

**📌 なぜ重要か:**
ビジネス環境は変わります。変化に対応できるシステムが生き残ります。

**✅ 実践方法:**

1. **変更しやすいアーキテクチャ**
   - 疎結合な設計
   - インターフェースの活用
   - マイクロサービス（必要に応じて）

2. **包括的なテストで安全に変更**
   - 自動テストで回帰テストを実施
   - 変更の影響範囲を最小化

3. **変更管理のプロセス**

   ```mermaid
   graph LR
       A[変更要求] --> B[影響分析]
       B --> C[承認]
       C --> D[実装]
       D --> E[テスト]
       E --> F[リリース]
       
       style A fill:#fff3e0
       style C fill:#ffcdd2
       style F fill:#c8e6c9
   ```

---

### 原則9: オープンなコミュニケーション 💬

**📌 なぜ重要か:**
情報の非対称性がプロジェクトの問題を生みます。

**✅ 実践方法:**

1. **デイリースタンドアップ**
   - 毎朝15分、全員で状況共有
   - 課題の早期発見

2. **透明性のある情報共有**
   - プロジェクトの状況を全員がアクセスできる場所に
   - 悪いニュースほど早く共有

3. **心理的安全性の確保**
   - 失敗を責めない文化
   - 質問しやすい雰囲気

**📊 コミュニケーションの5つのC:**

```markdown
1. Clear（明確）: 曖昧さを排除
2. Concise（簡潔）: 要点を絞る
3. Concrete（具体的）: 例を示す
4. Correct（正確）: 事実に基づく
5. Courteous（礼儀正しい）: 尊重する
```

---

### 原則10: 継続的な改善（カイゼン）🔄

**📌 なぜ重要か:**
完璧なプロセスはありません。常に改善し続けることが成功の鍵です。

**✅ 実践方法:**

1. **ふりかえり（レトロスペクティブ）**

   ```markdown
   【ふりかえりのフレームワーク】
   ① Keep: 良かったこと、続けること
   ② Problem: 問題だったこと
   ③ Try: 次に試すこと
   ```

2. **KPTフレームワークの活用**
   - 2週間ごとにチームで実施
   - 改善アクションを必ず決める

3. **メトリクスによる継続的な測定**

   ```markdown
   【測定すべき指標】
   ・開発速度（ベロシティ）
   ・バグ発生率
   ・リリース頻度
   ・顧客満足度
   ・チームの幸福度
   ```

4. **ポストモーテム（事後分析）**
   - プロジェクト終了後に振り返り
   - 学びを次のプロジェクトに活かす

**🎯 改善のサイクル（PDCA）:**

```mermaid
graph TD
    A[Plan<br/>計画] --> B[Do<br/>実行]
    B --> C[Check<br/>評価]
    C --> D[Act<br/>改善]
    D --> A
    
    style A fill:#fff3e0
    style B fill:#e1f5ff
    style C fill:#f3e5f5
    style D fill:#c8e6c9
```

---

## 第9章のまとめ

本章では、**プロジェクトを成功に導くためのチェックリストとベストプラクティス**を提供しました。

### 重要ポイントの再確認

```mermaid
mindmap
  root((成功する<br/>プロジェクト))
    チェックリスト
      各フェーズで確認
      必須成果物の確保
      品質基準のクリア
    失敗回避
      要件定義を丁寧に
      技術的負債を作らない
      テストを省略しない
    成功の原則
      小さく始める
      頻繁にリリース
      継続的改善
```

### 📋 最重要チェック項目TOP5

| 順位 | チェック項目 | フェーズ | 理由 |
|------|------------|---------|------|
| **1位** | 要件定義が完全か | 要件定義 | 後工程への影響が最大 |
| **2位** | テストが十分か | テスト | 品質の最後の砦 |
| **3位** | 非機能要件は明確か | 基本設計 | 運用時の問題に直結 |
| **4位** | コードレビューを実施したか | 実装 | 品質とチーム学習 |
| **5位** | ロールバック手順があるか | リリース | 障害時の被害最小化 |

### 🎓 次のステップ

1. **自分のプロジェクトでチェックリストを使ってみる**
   - まずは1つのフェーズから始める
   - プロジェクトに合わせてカスタマイズ

2. **失敗パターンを学ぶ**
   - 過去のプロジェクトを振り返る
   - 同じ過ちを繰り返さない

3. **10の原則を実践する**
   - 1つずつ取り入れていく
   - チーム全体で文化を作る

---

**次の第10章では、よくある質問（FAQ)にお答えします。**

---

# 第10章：FAQ（よくある質問）

## 10.1 初心者からの質問

### Q1-1: システム開発って何から始めればいいですか？ 🤔

**A: 「何を作るか」を明確にすることから始めましょう。**

具体的なステップ:

```mermaid
graph LR
    A[課題の特定] --> B[解決方法の検討]
    B --> C[システム化の判断]
    C --> D[要件のリストアップ]
    D --> E[優先順位付け]
    
    style A fill:#fff3e0
    style E fill:#c8e6c9
```

**実践的なアドバイス:**

1. **課題を具体化する**
   - ❌ 悪い例: 「業務を効率化したい」
   - ✅ 良い例: 「月末の売上集計に8時間かかっているのを1時間にしたい」

2. **5W1Hで整理する**

   ```markdown
   ・Who（誰が）: 営業部のメンバー全員が
   ・What（何を）: 顧客情報を
   ・Where（どこで）: 外出先からでも
   ・When（いつ）: リアルタイムで
   ・Why（なぜ）: 営業活動を効率化するために
   ・How（どのように）: スマホアプリで参照・更新できるようにする
   ```

3. **小さく始める**
   - 最初は1つの機能に絞る
   - 成功体験を積み重ねる

---

### Q1-2: ドキュメントって全部作らないとダメですか？ 📝

**A: プロジェクトの規模に応じて、必要なものだけ作りましょう。**

**プロジェクト規模別の推奨ドキュメント:**

| プロジェクト規模 | 期間 | 人数 | 必須ドキュメント | 推奨ドキュメント |
|---------------|------|------|----------------|----------------|
| **小規模** | 1-3ヶ月 | 1-3人 | ・要件メモ<br/>・README<br/>・ADR | ・簡易設計書<br/>・API仕様 |
| **中規模** | 3-6ヶ月 | 4-10人 | ・SRS<br/>・基本設計書<br/>・テスト仕様書<br/>・運用手順書 | ・詳細設計書<br/>・アーキテクチャ記述書 |
| **大規模** | 6ヶ月以上 | 10人以上 | ・全ての標準ドキュメント<br/>・トレーサビリティマトリクス | ・ISO準拠ドキュメント |

**💡 最小限のドキュメントセット（すべてのプロジェクトで必須）:**

```markdown
1. 【要件】何を作るか
2. 【設計】どう作るか（概要でOK）
3. 【テスト】どう確認するか
4. 【運用】どう使い続けるか
```

**📌 ドキュメント作成の判断基準:**
> 「3ヶ月後の自分が読んで理解できるか？」
> 「チームの他のメンバーが見て作業を続けられるか？」

この2つの質問にYesなら、そのドキュメントは必要です。

---

### Q1-3: ウォーターフォールとアジャイル、どっちを選べばいいですか？ 🌊🔄

**A: プロジェクトの特性に応じて選びましょう。**

**選択のフローチャート:**

```mermaid
graph TD
    Start[プロジェクト開始] --> Q1{要件は<br/>最初から<br/>明確？}
    Q1 -->|Yes| Q2{変更が<br/>少ない？}
    Q1 -->|No| Agile[アジャイル]
    
    Q2 -->|Yes| Q3{規制が<br/>厳しい？}
    Q2 -->|No| Agile
    
    Q3 -->|Yes| Water[ウォーターフォール]
    Q3 -->|No| Q4{チームに<br/>経験者が<br/>いる？}
    
    Q4 -->|Yes| Agile
    Q4 -->|No| Hybrid[ハイブリッド]
    
    style Water fill:#b3e5fc
    style Agile fill:#c8e6c9
    style Hybrid fill:#fff9c4
```

**具体的な選択基準:**

| 条件 | ウォーターフォール | アジャイル |
|------|-----------------|-----------|
| 要件の明確さ | ✅ 最初から明確 | ⚠️ 作りながら決める |
| 変更の頻度 | ✅ 変更が少ない | ⚠️ 頻繁に変更 |
| 規制・監査 | ✅ 厳しい規制あり | ❌ 柔軟に対応したい |
| チーム規模 | ✅ 大規模 | ⚠️ 小〜中規模 |
| リリース | ✅ 一括リリース | ⚠️ 段階的リリース |
| ドキュメント | ✅ 重厚なドキュメント | ⚠️ 軽量なドキュメント |

**💡 現実的な選択: ハイブリッド型**

```
上流工程（企画・要件定義）: ウォーターフォール的に計画
下流工程（実装・テスト）: アジャイル的に柔軟に
```

---

### Q1-4: プログラミング経験がないのですが、システム開発に関われますか？ 👶

**A: もちろんです！プログラミング以外の重要な役割がたくさんあります。**

**プログラミング不要な役割:**

```mermaid
graph TD
    A[システム開発<br/>プロジェクト] --> B[ビジネスアナリスト]
    A --> C[プロジェクトマネージャー]
    A --> D[UIデザイナー]
    A --> E[QAテスター]
    A --> F[テクニカルライター]
    A --> G[プロダクトオーナー]
    
    B --> B1[要件をヒアリング<br/>整理する]
    C --> C1[スケジュール<br/>予算を管理]
    D --> D1[使いやすい<br/>画面を設計]
    E --> E1[品質を<br/>チェック]
    F --> F1[マニュアルを<br/>作成]
    G --> G1[何を作るか<br/>決める]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:2px
    style B fill:#fff3e0
    style C fill:#f3e5f5
    style D fill:#fff9c4
    style E fill:#c8e6c9
    style F fill:#b3e5fc
    style G fill:#f8bbd0
```

**各役割の詳細:**

1. **ビジネスアナリスト（BA）**
   - 役割: ビジネス側とIT側の橋渡し
   - 必要スキル: ヒアリング力、文書化能力、業務知識
   - プログラミング: 不要

2. **プロジェクトマネージャー（PM）**
   - 役割: プロジェクト全体の管理
   - 必要スキル: リーダーシップ、コミュニケーション、計画力
   - プログラミング: 基礎知識があれば尚可

3. **QAテスター**
   - 役割: 品質保証・テスト
   - 必要スキル: 注意力、論理的思考、根気強さ
   - プログラミング: テスト自動化では必要になることも

**💡 最初の一歩:**

- まずは小さなプロジェクトでQAテスターから始める
- このガイドを読んで全体像を理解する
- コミュニケーション能力を磨く

---

### Q1-5: 専門用語が多すぎて理解できません... 😵

**A: 最初は誰でもそうです。少しずつ覚えていきましょう。**

**学習のコツ:**

1. **頻出する用語から覚える（優先度順）**

   ```markdown
   【必ず覚えるべきTOP10】
   1. 要件定義
   2. テスト
   3. リリース
   4. バグ
   5. API
   6. データベース
   7. フロントエンド/バックエンド
   8. レビュー
   9. デプロイ
   10. バージョン管理
   ```

2. **比喩で理解する**
   - API = レストランのメニュー（注文方法が決まっている）
   - データベース = 図書館（情報を整理して保管）
   - バグ = 料理の失敗（期待と違う結果）

3. **このガイドの第7章（用語集）を辞書として活用**
   - わからない言葉が出たらすぐ引く
   - 何度も出てくる言葉は自然に覚える

4. **実践で学ぶ**
   - 実際のプロジェクトで使いながら覚える
   - 使わない言葉は覚えなくてOK

**📚 おすすめ学習リソース:**

- このガイドの第7章（完全用語集）
- IPA（情報処理推進機構）の用語集
- IT用語辞典 e-Words

---

## 10.2 実務上の疑問

### Q2-1: 要件定義でお客様の要望が曖昧な場合、どうすればいいですか？ 💭

**A: 具体的な質問で要望を引き出しましょう。**

**効果的な質問テクニック:**

1. **5W1Hで深堀り**

   ```markdown
   お客様: 「使いやすいシステムにしてほしい」
   
   あなた: 「使いやすいとは、具体的にどのようなことでしょうか？」
   → What（何が使いやすい？）
   
   あなた: 「誰が一番よく使う機能ですか？」
   → Who（誰が使う？）
   
   あなた: 「どのくらいの操作時間が目標ですか？」
   → How（どのように？どのくらい？）
   ```

2. **現状の課題から逆算**

   ```markdown
   質問例:
   「現在のシステムで一番困っていることは何ですか？」
   「毎日の業務で、一番時間がかかっている作業は？」
   「どんな時にミスが起こりやすいですか？」
   ```

3. **具体例・シナリオで確認**

   ```markdown
   あなた: 「例えば、営業の田中さんが顧客訪問から帰ってきた時、
           どのような流れで情報を入力しますか？」
   → 具体的な利用シーンを描いてもらう
   ```

4. **プロトタイプ・モックアップで可視化**
   - 画面のイメージを見せて「こんな感じですか？」
   - 紙やホワイトボードで簡単なスケッチ
   - Figmaなどのツールで画面モックアップ

**⚠️ 注意点:**

- お客様が「技術的なことはわからない」と言っても諦めない
- 業務の話なら誰よりも詳しいはず
- わからないことを「わからない」と正直に伝えてもらう関係性を作る

---

### Q2-2: 開発中に仕様変更が頻繁に発生します。どう対応すべきですか？ 🔄

**A: 変更管理のプロセスを確立し、影響を明確にしましょう。**

**変更管理のプロセス:**

```mermaid
graph TD
    A[変更要求] --> B[影響分析]
    B --> C[見積もり<br/>工数・コスト・期間]
    C --> D[優先度評価]
    D --> E{承認?}
    E -->|Yes| F[計画に反映]
    E -->|No| G[却下/保留]
    F --> H[実装]
    H --> I[テスト]
    I --> J[リリース]
    
    G --> K[理由を記録]
    
    style A fill:#fff3e0
    style B fill:#f3e5f5
    style C fill:#fff9c4
    style E fill:#ffcdd2
    style F fill:#c8e6c9
    style J fill:#b3e5fc
```

**変更要求評価テンプレート:**

```markdown
## 変更要求 #123

【要求内容】
検索機能に「あいまい検索」を追加したい

【現状】
完全一致検索のみ実装済み

【変更の必要性】
ユーザーからの要望が多い（月10件以上）

【影響分析】
・開発工数: 3日
・テスト工数: 2日
・影響範囲: 検索API、データベースインデックス
・リスク: 検索性能が低下する可能性（対策必要）

【優先度】
高（ユーザー満足度に直結）

【推奨】
✅ 承認を推奨
理由: ユーザー要望が多く、ビジネス価値が高い
```

**対策:**

1. **変更リクエストの正式なフォーマットを用意**
   - 口頭やメールでなく、Jiraなどのツールで管理

2. **影響範囲を必ず明確化**
   - 「ちょっとした変更」は存在しない
   - 工数・スケジュール・リスクを見積もる

3. **変更の予算を確保**
   - プロジェクト予算の10-20%を変更対応用に確保

4. **定期的な変更レビュー会議**
   - 週次で変更要求を一括レビュー
   - 優先順位を付けて実装計画に反映

---

### Q2-3: テストはどこまでやればいいですか？ 🧪

**A: リスクと優先度に基づいて、メリハリをつけましょう。**

**テスト戦略のピラミッド:**

```mermaid
graph TD
    A[手動E2Eテスト<br/>少なく実施] --> B[自動E2Eテスト<br/>重要シナリオのみ]
    B --> C[統合テスト<br/>コンポーネント間]
    C --> D[ユニットテスト<br/>多く実施]
    
    A --> A1[5%]
    B --> B1[15%]
    C --> C1[30%]
    D --> D1[50%]
    
    style A fill:#ffcdd2
    style B fill:#fff3e0
    style C fill:#fff9c4
    style D fill:#c8e6c9
```

**優先度別テスト戦略:**

| 機能の重要度 | テストレベル | 例 |
|------------|------------|-----|
| **最重要** | ✅ 手動E2E<br/>✅ 自動E2E<br/>✅ 統合テスト<br/>✅ ユニットテスト | 決済処理、ログイン |
| **重要** | ✅ 自動E2E<br/>✅ 統合テスト<br/>✅ ユニットテスト | 商品検索、カート追加 |
| **普通** | ✅ 統合テスト<br/>✅ ユニットテスト | 設定画面、ヘルプ |
| **低** | ✅ ユニットテスト | 表示系の細かな機能 |

**リスクベースのテスト計画:**

```markdown
【テスト優先度の判断基準】

高優先度（必須）:
□ お金に関わる処理（決済、請求）
□ 個人情報を扱う処理
□ データを削除する処理
□ セキュリティに関わる処理（認証、認可）

中優先度（推奨）:
□ 主要なユーザーフロー
□ 頻繁に使われる機能
□ データを作成・更新する処理

低優先度（時間があれば）:
□ 管理画面の表示
□ エラーメッセージの細かな文言
□ 装飾的なアニメーション
```

**💡 現実的なテスト基準:**

- **ユニットテスト**: カバレッジ70-80%を目指す
- **統合テスト**: 主要なフローを全てカバー
- **E2Eテスト**: クリティカルなユーザーシナリオ10-20本
- **手動テスト**: リリース前に主要機能を1巡

---

### Q2-4: ドキュメントを書く時間がありません。どうすればいいですか？ ⏰

**A: ドキュメント作成を開発プロセスに組み込みましょう。**

**時間を作るための戦略:**

1. **ドキュメントを「後回し」にしない**

   ```markdown
   ❌ 悪い習慣:
   コード書く → 後でドキュメント書く（書かない）
   
   ✅ 良い習慣:
   設計書を書く → コードを書く → 設計書を更新
   ```

2. **完了の定義(DoD)に含める**

   ```markdown
   【タスクの完了条件】
   □ 機能が動作する
   □ テストが通る
   □ コードレビュー完了
   □ ドキュメント更新 ← これを含める
   ```

3. **自動生成できるものは自動化**

   ```markdown
   自動生成できるドキュメント:
   ・API仕様（Swagger/OpenAPIから）
   ・データベーススキーマ（DDLから）
   ・クラス図（コードから）
   ・コードドキュメント（Javadoc/JSDocから）
   ```

4. **軽量なドキュメント形式を採用**
   - 重厚なWord文書 → Markdown
   - 長文 → 箇条書き + 図
   - 完璧を目指さず、必要十分を目指す

**時間配分の目安:**

```markdown
要件定義: 20%
設計: 20%
実装: 30%
テスト: 20%
ドキュメント: 10% ← このくらいは確保する
```

**💡 最小限のドキュメント:**
1日30分ドキュメントに時間を使うだけでも、以下が作れます:

- README（1日目）
- 設計概要（2-3日目）
- API仕様（4-5日目）
- 運用手順（6-7日目）

---

### Q2-5: アジャイル開発でもドキュメントは必要ですか？ 📄

**A: はい、ただし「必要最小限」の軽量なドキュメントです。**

**アジャイル ≠ ドキュメント不要**

アジャイル宣言では、「動くソフトウェア」を「包括的なドキュメント」より重視すると言っていますが、ドキュメント不要とは言っていません。

**アジャイルでのドキュメント戦略:**

```mermaid
graph LR
    A[重厚なドキュメント] -->|アジャイル化| B[軽量なドキュメント]
    
    A --> A1[100ページの<br/>要件定義書]
    A --> A2[詳細な<br/>設計書]
    
    B --> B1[ユーザーストーリー<br/>受入基準]
    B --> B2[ADR<br/>設計決定記録]
    
    style A fill:#ffcdd2
    style B fill:#c8e6c9
```

**アジャイルプロジェクトで推奨されるドキュメント:**

| ドキュメント種類 | 形式 | 更新頻度 | 重要度 |
|---------------|------|---------|--------|
| **ユーザーストーリー** | Jira/Trello | 毎スプリント | ★★★★★ |
| **受入基準** | Gherkin/Markdown | 毎スプリント | ★★★★★ |
| **ADR** | Markdown | 設計判断時 | ★★★★☆ |
| **README** | Markdown | 随時 | ★★★★★ |
| **API仕様** | Swagger/OpenAPI | 随時 | ★★★★☆ |
| **アーキテクチャ図** | C4モデル | 変更時 | ★★★★☆ |

**ドキュメント作成のルール:**

```markdown
1. 動くコードで表現できることは、コードで表現
2. 自動生成できるものは自動生成
3. 判断の理由（Why）を重点的に記録
4. 完璧を目指さず、必要十分を目指す
```

---

### Q2-6: 外部の開発会社に委託する際の注意点は？ 🤝

**A: 要件定義を丁寧に行い、契約内容を明確にしましょう。**

**発注側がやるべきこと:**

```mermaid
graph TD
    A[開発委託の準備] --> B[要件を明確化]
    B --> C[RFP作成]
    C --> D[ベンダー選定]
    D --> E[契約]
    E --> F[開発開始]
    
    B --> B1[何を作るか<br/>詳細に決める]
    C --> C1[提案依頼書を<br/>作成]
    D --> D1[複数社から<br/>提案を受ける]
    E --> E1[契約書で<br/>責任範囲を明確化]
    
    style A fill:#e1f5ff
    style B fill:#fff3e0
    style C fill:#f3e5f5
    style D fill:#fff9c4
    style E fill:#ffcdd2
    style F fill:#c8e6c9
```

**チェックリスト:**

**【委託前】**

- [ ] 要件定義書を作成（曖昧さを排除）
- [ ] RFP（提案依頼書）を作成
- [ ] 予算と納期の目安を決める
- [ ] 複数のベンダーから提案を受ける
- [ ] 実績と評判を確認

**【契約時】**

- [ ] 成果物を明確に定義
- [ ] 検収基準を明確化
- [ ] 責任範囲を明確化（仕様変更時の費用など）
- [ ] 知的財産権の帰属を明記
- [ ] 瑕疵担保責任の範囲と期間を明記

**【開発中】**

- [ ] 定期的な進捗報告会を実施（週次推奨）
- [ ] 成果物を段階的にレビュー
- [ ] 変更要求は正式な手続きで
- [ ] コミュニケーションツールを統一（Slack、メールなど）

**【納品時】**

- [ ] 要件定義書と照らし合わせて検収
- [ ] ソースコード、ドキュメント一式を受領
- [ ] 運用マニュアル、保守手順を確認
- [ ] 保守契約の内容を確認

**⚠️ よくある失敗:**

- ❌ 要件が曖昧なまま発注 → 完成品が期待と違う
- ❌ 一番安い会社に発注 → 品質が低い
- ❌ 丸投げして進捗確認しない → 納期直前に問題発覚
- ❌ 契約書の内容を確認しない → トラブル時に対応できない

---

## 10.3 トラブルシューティング

### Q3-1: プロジェクトが炎上しています。どうすればいいですか？ 🔥

**A: まず現状を正確に把握し、優先順位を付けて対応しましょう。**

**炎上プロジェクトの救済ステップ:**

```mermaid
graph TD
    A[炎上発生] --> B[緊急対策会議]
    B --> C[現状把握]
    C --> D[問題の優先順位付け]
    D --> E[短期対策]
    E --> F[中長期対策]
    F --> G[再発防止策]
    
    C --> C1[何が問題か<br/>事実を整理]
    D --> D1[影響の大きい順に<br/>対応]
    E --> E1[即座に実行できる<br/>対策]
    F --> F1[根本原因への<br/>対応]
    
    style A fill:#ffcdd2,stroke:#c62828,stroke-width:3px
    style B fill:#fff3e0
    style E fill:#fff9c4
    style G fill:#c8e6c9
```

**現状把握のチェックリスト:**

```markdown
□ 何が問題なのか？（事実のみ）
□ なぜそうなったのか？（原因分析）
□ いつまでに何をする必要があるのか？
□ 現在のリソース（人・時間・予算）は？
□ ステークホルダーの期待値は？
```

**優先順位の付け方:**

```markdown
【最優先】レベル1: サービス停止を防ぐ
・システムダウンの回避
・セキュリティ事故の防止
・データ消失の防止

【高優先】レベル2: ユーザー影響を最小化
・重大なバグの修正
・主要機能の完成
・性能問題の解決

【中優先】レベル3: プロジェクト目標の達成
・予定機能の完成
・品質基準の達成
・ドキュメントの整備

【低優先】レベル4: 理想的な状態
・細かなUI改善
・追加機能
・リファクタリング
```

**短期対策（今週中に実行）:**

1. **人員の緊急投入**
   - 他プロジェクトからの応援
   - 外部リソースの活用

2. **スコープの削減**
   - 必須機能のみに絞る
   - Nice to haveは次期リリースへ

3. **デイリー進捗会議**
   - 毎朝15分、全員で状況共有
   - ブロッカーを即座に解消

4. **コミュニケーション強化**
   - ステークホルダーへの状況報告
   - 期待値の調整

**中長期対策（1-3ヶ月で実行）:**

1. **プロセスの見直し**
   - なぜ炎上したのか根本原因を分析
   - プロセス改善

2. **技術的負債の返済計画**
   - 後回しにした問題への対応

3. **チーム体制の強化**
   - 不足しているスキルの補強
   - 役割分担の明確化

**💡 重要な心構え:**
> 「完璧を目指すより、まず完成させる」
> 「全部やろうとせず、重要なことに集中」
> 「一人で抱え込まず、助けを求める」

---

### Q3-2: バグが多すぎてテストが終わりません 🐛

**A: バグの優先順位を付け、リリース判定基準を明確にしましょう。**

**バグの優先度分類:**

| 重大度 | 定義 | 例 | 対応 |
|--------|------|-----|------|
| **致命的** | サービス停止 | システムダウン、データ消失 | 即座に修正 |
| **重大** | 主機能が使えない | ログインできない、決済失敗 | 1日以内に修正 |
| **中** | 一部機能に支障 | エラーメッセージが出る | 1週間以内 |
| **軽微** | 使用可能だが不便 | 表示が遅い、誤字 | 次回リリース |
| **些細** | 改善要望レベル | UI微調整、文言変更 | 余裕があれば |

**リリース判定基準:**

```markdown
【リリース可能な条件】
✅ 致命的バグ: 0件
✅ 重大バグ: 0件
✅ 中バグ: 5件以下
⚠️ 軽微バグ: 既知の問題として公表
⚠️ 些細バグ: 次回リリースで対応

【リリース不可の条件】
❌ 致命的または重大バグが1件でもある
❌ セキュリティ上の問題がある
❌ データ整合性に問題がある
```

**バグを減らす戦略:**

1. **予防策: バグを作り込まない**

   ```markdown
   ・コードレビューの徹底
   ・ペアプログラミング
   ・ユニットテストの作成（カバレッジ80%以上）
   ・静的解析ツールの活用
   ```

2. **早期発見: バグを早く見つける**

   ```markdown
   ・CI/CDで自動テスト
   ・コミットごとにテスト実行
   ・デイリーで統合テスト
   ```

3. **効率的修正: バグを素早く直す**

   ```markdown
   ・再現手順を明確に記録
   ・原因を根本から特定
   ・修正後は必ず回帰テスト
   ```

**バグトリアージ会議:**
毎日30分、バグの優先度を判断する会議を実施

```markdown
参加者: PM、リードエンジニア、QAリーダー
議題:
1. 新規バグの優先度判定
2. 修正済みバグの確認
3. リリース判定
```

---

### Q3-3: 納期に間に合いそうにありません ⏳

**A: スコープ、リソース、時間のどれかを調整する必要があります。**

**プロジェクトの3大制約:**

```mermaid
graph TD
    A[プロジェクト] --> B[スコープ<br/>何を作るか]
    A --> C[時間<br/>いつまでに]
    A --> D[コスト<br/>リソース]
    
    B -.調整1.- B1[機能を減らす]
    C -.調整2.- C1[納期を延ばす]
    D -.調整3.- D1[人を増やす]
    
    B1 --> E[調整後のバランス]
    C1 --> E
    D1 --> E
    
    style A fill:#ffcdd2,stroke:#c62828,stroke-width:2px
    style E fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
```

**対策の選択肢:**

**選択肢1: スコープを削減（推奨）**

```markdown
【優先度付け】
✅ Must Have: 絶対に必要（コア機能）
⚠️ Should Have: あった方が良い
❌ Could Have: あれば嬉しい
❌ Won't Have: 今回はやらない

【具体的な削減例】
・管理画面の一部機能 → 次期リリースへ
・細かなUI調整 → 後回し
・追加の便利機能 → 見送り
```

**選択肢2: 納期を延ばす**

```markdown
【検討ポイント】
・ステークホルダーの承認が得られるか？
・ビジネスへの影響は許容範囲か？
・延長期間で本当に完成するか？

【現実的な延長期間】
・当初計画の10-20%の延長が一般的
・例: 3ヶ月プロジェクト → 2-3週間延長
```

**選択肢3: リソースを増やす**

```markdown
【注意点】
⚠️ ブルックスの法則:
「遅れているプロジェクトに人を追加すると、
  さらに遅れる」

【効果的なリソース追加】
✅ プロジェクト序盤の追加
✅ 専門スキルを持つ経験者
✅ 独立した作業ができるタスク
❌ プロジェクト終盤の追加
❌ 未経験者の追加
❌ 複雑な連携が必要なタスク
```

**💡 現実的な対応:**

```markdown
1. まずスコープ削減を検討
   → 最小限の機能でリリース
   
2. それでも難しければ納期調整
   → ステークホルダーと交渉
   
3. リソース追加は慎重に
   → 本当に効果があるか見極める
```

---

### Q3-4: チームメンバーが退職してしまいました 😢

**A: ドキュメントと引き継ぎプロセスで乗り切りましょう。**

**緊急対応（今すぐやること）:**

```mermaid
graph TD
    A[退職発覚] --> B[引き継ぎ計画]
    B --> C[ドキュメント整備]
    C --> D[ナレッジ転移]
    D --> E[後任者アサイン]
    
    C --> C1[設計書の確認<br/>不足部分の補完]
    D --> D1[ペアプログラミング<br/>レビュー会]
    E --> E1[役割の<br/>再分担]
    
    style A fill:#ffcdd2
    style B fill:#fff3e0
    style C fill:#fff9c4
    style D fill:#c8e6c9
    style E fill:#b3e5fc
```

**引き継ぎチェックリスト:**

**【ドキュメント】**

- [ ] 設計書の整備（足りない部分を補完）
- [ ] コードコメントの追記
- [ ] README更新
- [ ] 運用手順書の作成
- [ ] トラブルシューティングガイド

**【ナレッジ転移】**

- [ ] システム全体像の説明会
- [ ] 重要な設計判断の背景説明
- [ ] 既知の問題点・注意点の共有
- [ ] ペアプログラミングセッション
- [ ] Q&Aセッション

**【引き継ぎ期間の目安】**

```markdown
・簡単なプロジェクト: 1-2週間
・通常のプロジェクト: 2-4週間
・複雑なプロジェクト: 1-2ヶ月

並行期間: できれば1-2週間は新旧担当者が協力
```

**予防策（日頃から準備）:**

```markdown
【属人化を防ぐ文化】
✓ ドキュメントを常に最新に保つ
✓ コードレビューで知識を共有
✓ ペアプログラミング/モブプログラミング
✓ 定期的なナレッジ共有会
✓ バス係数を意識（1人に依存しない）

【バス係数とは】
「もしその人がバスに轢かれたら、
 プロジェクトが止まるか？」を示す指標
→ 2以上を目指す（複数人が理解している状態）
```

---

### Q3-5: ステークホルダー間で意見が対立しています 💢

**A: データと事実に基づいて、客観的に判断しましょう。**

**対立解消のステップ:**

```mermaid
graph TD
    A[意見対立] --> B[対立の構造を理解]
    B --> C[共通目標を確認]
    C --> D[データ収集]
    D --> E[選択肢の整理]
    E --> F[判断基準の設定]
    F --> G[意思決定]
    
    B --> B1[何が対立しているか<br/>明確化]
    C --> C1[皆が目指す<br/>ゴールは何か]
    D --> D1[客観的な<br/>事実を集める]
    G --> G1[決定事項を<br/>文書化]
    
    style A fill:#ffcdd2
    style C fill:#fff9c4
    style G fill:#c8e6c9
```

**対立解消のテクニック:**

1. **共通目標を再確認**

   ```markdown
   対立例:
   ・営業部: 「機能をもっと増やしたい」
   ・開発部: 「品質を優先したい」
   
   共通目標:
   → 「顧客満足度の高いシステムを作る」
   
   この視点で議論を再開
   ```

2. **データドリブンな判断**

   ```markdown
   感情や主観ではなく、データで判断
   
   例:
   ・ユーザーアンケート結果
   ・競合分析
   ・コスト試算
   ・リスク分析
   ```

3. **トレードオフの可視化**

   ```markdown
   | 選択肢 | メリット | デメリット | コスト | リスク |
   |--------|---------|----------|-------|--------|
   | 案A: 機能追加 | 営業しやすい | 品質リスク | 高 | 高 |
   | 案B: 品質優先 | 安定性高い | 機能少ない | 中 | 低 |
   | 案C: MVP | 早期リリース | 機能限定 | 低 | 中 |
   ```

4. **第三者の意見を求める**
   - 中立的な立場の人にレビューを依頼
   - 外部コンサルタントの活用

5. **段階的アプローチ**

   ```markdown
   両方を満たす段階的な計画
   
   例:
   フェーズ1: コア機能のみ実装（品質重視）
   フェーズ2: 追加機能を段階的に（営業要望）
   ```

**最終決定のルール:**

```markdown
【意思決定の権限を明確化】
・最終決定者は誰か（PM、プロダクトオーナー、CTO等）
・どのような場合に上位者にエスカレーションするか
・決定事項の記録方法

【決定後】
・決定事項を文書化（議事録、ADR）
・全員が合意した証拠を残す
・決定の理由を記録
```

---

## 第10章のまとめ

本章では、**実務でよく直面する質問や問題への対処法**を提供しました。

### 質問カテゴリ別まとめ

```mermaid
mindmap
  root((FAQ))
    初心者向け
      何から始めるか
      ドキュメントの量
      開発手法の選択
    実務上の疑問
      曖昧な要件への対応
      仕様変更の管理
      テストの範囲
    トラブル対応
      プロジェクト炎上
      バグ多発
      納期遅延
```

### 💡 重要な心構え

1. **完璧を求めすぎない**
   - まず動くものを作る
   - 段階的に改善

2. **コミュニケーションを重視**
   - わからないことは聞く
   - 問題は早めに共有

3. **ドキュメントは投資**
   - 将来の自分への投資
   - チームへの投資

4. **失敗から学ぶ**
   - ミスは改善のチャンス
   - 振り返りを大切に

### 🎓 さらなる学習リソース

```markdown
【公式ドキュメント・標準規格】
・ISO/IEC/IEEE 29148（要求工学）
・ISO/IEC/IEEE 42010（アーキテクチャ記述）
・PMBOK（プロジェクトマネジメント）

【コミュニティ】
・Stack Overflow（技術Q&A）
・GitHub（オープンソースプロジェクト）
・Qiita/Zenn（日本語技術記事）

【書籍】
・リーダブルコード
・Clean Architecture
・アジャイルサムライ
```

---

# 🎉 全章完了！おめでとうございます

このガイドを最後まで読んでいただき、ありがとうございました。

## あなたが得た知識

```mermaid
graph TD
    A[システム開発の<br/>完全知識] --> B[全体像の理解]
    A --> C[フェーズ別知識]
    A --> D[重要ドキュメント]
    A --> E[実践的手法]
    A --> F[国際標準規格]
    A --> G[完全用語集]
    A --> H[テンプレート集]
    A --> I[ベストプラクティス]
    A --> J[FAQ]
    
    style A fill:#e1f5ff,stroke:#0277bd,stroke-width:4px
    style B fill:#c8e6c9
    style C fill:#c8e6c9
    style D fill:#c8e6c9
    style E fill:#c8e6c9
    style F fill:#c8e6c9
    style G fill:#c8e6c9
    style H fill:#c8e6c9
    style I fill:#c8e6c9
    style J fill:#c8e6c9
```

## 次のステップ

### 🚀 初心者の方

1. 小さなプロジェクトから始める
2. このガイドのテンプレートを使ってみる
3. わからないことは第7章（用語集）で確認
4. 失敗を恐れず、経験を積む

### 💼 実務者の方

1. 現在のプロジェクトにベストプラクティスを適用
2. チームでチェックリストを使ってみる
3. ドキュメントの質を段階的に改善
4. 振り返りで継続的に改善

### 🎓 マネージャーの方

1. チーム全体でこのガイドを共有
2. プロセス改善のベースとして活用
3. 品質基準を明確化
4. チームの成長を支援

## 最後に

```markdown
システム開発は、決して一人で完結するものではありません。
チーム全員が同じ理解を持ち、同じ目標に向かうことが成功の鍵です。

このガイドが、あなたとあなたのチームの成功の一助となれば幸いです。

頑張ってください！そして、素晴らしいシステムを作ってください！
```

---

## 📚 ドキュメント情報

| 項目 | 内容 |
|------|------|
| **ドキュメント名** | システム開発ドキュメント完全ガイド【統合版】 |
| **バージョン** | 1.0（完全版） |
| **最終更新日** | 2025年10月23日 |
| **総ページ数** | 約400ページ相当 |
| **対象読者** | システム開発に関わる全ての方 |
| **難易度** | 初心者〜上級者 |

---

**【システム開発ドキュメント完全ガイド 完】**

**Happy Coding! 🎉**

---
